----------
Action
An action that can be assigned to a menu and/or shortcut.

Built-in actions will generally be of this type when retrieved from the L{ActionManager}. Custom user actions, which run Python scripts, will be L{ScriptAction} objects.

B{Example Code}

>>> # This example creates an action to print "Hello World" to the log and executes the action
>>> import mari
>>> action = mari.actions.create("MyCustomActions/Print Hello","mari.app.log('Hello World')")
>>> action.trigger()

>>> import mari
>>> # This example finds the action and executes it
>>> action = mari.actions.find("Mari/Scripts/MyCustomActions/Print Hello")
>>> action.trigger()
----------
Action.addToSet
Adds the action to an action set.

Adding an action to a set that is disabled will disable the action.

@type  SetName: str
@param SetName: The name of the set to add the action to. If the set does not exist, it will be created
@rtype: None
@raise ValueError: Raised if the set name was invalid.
@see: L{removeFromSet()}
----------
Action.iconPath
Returns the path to the icon used for the action.

@rtype: str
@return: The path to the icon. If no icon is used, this will be blank.
@raise TypeError: Raised if the action is of a built-in type that does not support icon path retrieval.
@see: L{setIconPath()}
----------
Action.isCheckable
Indicates whether the given action has a check box that can be turned on and off.

@rtype: bool
@return: True if the action has a check box, or False if not.
@see: L{setCheckable()}
----------
Action.isChecked
Returns True if the action is checked, False otherwise.

@rtype: bool
@return: Whether the action is checked or not
@see: L{setChecked()}
----------
Action.isEnabled
Indicates whether the action is enabled.

@rtype: bool
@return: True if the action is enabled, or False otherwise.
@see: L{setEnabled()}
----------
Action.name
Returns the name of the action.

This is the same as L{text()}.

@rtype: str
@return: The name of the action
@see: L{text()}, L{setText()}
----------
Action.path
Returns the path that this action is registered in.

If an internal action is registered in multiple paths, this will return the first one.

@rtype: str
@return: The path that this action is registered in, such as "Mari/Scripts/Custom Action". For a description of action paths, see L{ActionManager.create()}
----------
Action.removeFromSet
Removes the action from an action set.

@type  SetName: str
@param SetName: The set to remove the action from
@rtype: None
@raise ValueError: Raised if the set name was invalid.
@see: L{addToSet()}
----------
Action.removeShortcut
Removes any current shortcut for the action.

If the action specified does not have a shortcut, this function will complete successfully without raising an exception.

@rtype: None
@see: L{shortcut()}, L{setShortcut()}
----------
Action.setCheckable
Sets the action as being checkable i.e.

one that has an on/off state.

@type  Checkable: bool
@param Checkable: Whether the action is checkable or not
@rtype: None
@see: L{isCheckable()}
----------
Action.setChecked
Sets the action as being checked.

@type  Checked: bool
@param Checked: Whether the action is checked or not
@rtype: None
@see: L{isChecked()}
----------
Action.setEnabled
Enables or disables this action.

@type  Enabled: bool
@param Enabled: True to enable the action, or False to disable it.
@rtype: None
@see: L{isEnabled()}
----------
Action.setIcon
Sets the icon to display on menus for the action.

@type  IconPath: str
@param IconPath: The path to an icon to load
@rtype: None
@raise IOError: Raised if the icon failed to load.
@raise TypeError: Raised if the action is of a built-in type that does not support icon path retrieval.
@deprecated: This function will be removed in a future version. Please use L{setIconPath()} instead.
----------
Action.setIconPath
Sets the icon to display on menus for the action.

@type  IconPath: str
@param IconPath: The path to an icon to load
@rtype: None
@raise IOError: Raised if the icon failed to load.
@raise TypeError: Raised if the action is of a built-in type that does not support icon path retrieval.
@see: L{iconPath()}
----------
Action.setShortcut
Sets the shortcut key for the action.

Shortcuts can be single keys ("F1"), keys with modifiers ("Ctrl+A"), or empty to specify no shortcut.

@type  rString: str
@param rString: The new shortcut string for the given action. Pass in an empty string to clear the shortcut
@rtype: None
@raise ValueError: Raised if the shortcut string was invalid.
@see: L{shortcut()}, L{removeShortcut()}
----------
Action.setStatusTip
Sets the status tip displayed on all status bars by the action's top-level parent widget.

@type  StatusTip: str
@param StatusTip: The status tip for the action
@rtype: None
@see: L{statusTip()}
----------
Action.setText
Sets the text to display for the action.

@type  NewText: str
@param NewText: The new text for the action
@rtype: None
@see: L{name()}, L{text()}
----------
Action.setToolTip
Sets the tool tip for the action.

@type  ToolTip: str
@param ToolTip: The tool tip for the action
@rtype: None
@see: L{toolTip()}
----------
Action.setWhatsThis
Sets the "What's This?" text used to provide a brief description of the action.

@type  WhatsThis: str
@param WhatsThis: The "What's This?" text for the action
@rtype: None
@see: L{whatsThis()}
----------
Action.shortcut
Returns the string representation of the shortcut for the action.

@rtype: str
@return: A string returning the shortcut for the given action, or an empty string if there is no shortcut.
@note: This may not match the value originally set if something else has overridden the shortcut key since then.
@see: L{setShortcut()}, L{removeShortcut()}
----------
Action.statusTip
Returns the status tip for the action displayed on status bars.

@rtype: str
@return: The status tip for the action
@see: L{setStatusTip()}
----------
Action.text
Returns the text to display for the action when required.

@rtype: str
@return: The text to display for the action when required
@see: L{name()}, L{setText()}
----------
Action.toolTip
Returns the tool tip for the action.

@rtype: str
@return: The tool tip for the action
@see: L{setToolTip()}
----------
Action.trigger
Executes the script action.

@rtype: None
@see: L{triggered()}
----------
Action.triggered
This is emitted when the action is triggered by Python or GUI interaction.

@rtype: None
@see: L{trigger()}
----------
Action.whatsThis
Returns the "What's This?" text used to provide a brief description of the action.

@rtype: str
@return: The "What's This?" text for the action
@see: L{setWhatsThis()}
----------
ActionManager
Manages creation and manipulation of actions.

This class creates and manipulates Mari actions, which are used as menu commands, and can have shortcut keys bound to them. By default, any action created through scripting will be in the "/Mari/Scripts" path, but this can be customized if there is any need to avoid clashes.

Mari stores all of the available actions in a tree, and actions are identified by their path within this tree. For example, "/Mari/Tools/TestTool" refers to an action called TestTool in a subsection called Tools.

B{Example Code}

>>> # This example creates an action through mari.actions(ActionManager singleton instance) to print "Hello World" to the log and executes the action
>>> import mari
>>> action = mari.actions.create("MyCustomActions/Print Hello","mari.app.log('Hello World')")
>>> action.trigger()

>>> # This example finds the action and executes it
>>> import mari
>>> action = mari.actions.find("Mari/Scripts/MyCustomActions/Print Hello")
>>> action.trigger()
----------
ActionManager.actionFromShortcut
Returns the path of the action that is using the given shortcut.

@type  Shortcut: str
@param Shortcut: A text version of the shortcut you're interested in
@rtype: str
@return: The path to the action that uses the given shortcut, or an empty string if the shortcut is invalid or not in use
----------
ActionManager.addToSet
Adds an action to an action set.

This will not modify the enabled state of the action.

@type  SetName: str
@param SetName: The name of the set to add the action to. If the set does not exist, it will be created
@type  pAction: L{Action}
@param pAction: The action to add to the set
@rtype: None
@raise ValueError: Raised if the set name or action were invalid.
@see: L{enableSet()}, L{sets()}, L{disableSet()}, L{removeFromSet()}
----------
ActionManager.create
Creates a new action with the given name and scripting command.

The identifier supplied for an action is composed of an optional path and a name. The path, if supplied, gives the path in the action hierarchy where the action will be stored. These paths help conceptually group actions and avoid name clashes. If no path is provided to this function, it will use "/Mari/Scripts" by default. If a path is provided, it is assumed to be absolute if it starts with a slash (e.g. "/Mari/SomethingElse/" is used as is), or otherwise it is taken as relative (e.g. "My/Path/" becomes "/Mari/Scripts/My/Path/"). The remainder of the identifier is used as the display text for the action.

Both the path and the display text can contain spaces.

Note that you will need to assign the action to a menu or a shortcut before you will be able to do anything useful with it.

@type  rIdentifier: str
@param rIdentifier: The identifier that provides the action's path and display text. See the main description.
@type  rCommand: str
@param rCommand: The scripting command to run when the action is activated.
@rtype: L{ScriptAction}
@return: A new action object.
----------
ActionManager.disableSet
Disables all actions in the given set.

@type  SetName: str
@param SetName: The name of the action set to disable
@rtype: None
@see: L{addToSet()}, L{enableSet()}, L{sets()}, L{removeFromSet()}
----------
ActionManager.enableSet
Enables all actions in the given set.

@type  SetName: str
@param SetName: The name of the action set to enable
@rtype: None
@see: L{addToSet()}, L{sets()}, L{disableSet()}, L{removeFromSet()}
----------
ActionManager.find
Returns the Mari action that corresponds to the path provided.

Using this function, users can find an individual action. Calling L{Action.trigger()} on the action returned will execute it.

See L{create()} for a description of action paths.

@type  rPath: str
@param rPath: The path to the action to find
@rtype: L{Action}
@return: The requested action if found, or None otherwise
@see: L{get()}
----------
ActionManager.get
Returns the Mari action that corresponds to the path provided.

Using this function, users can find an individual action. Calling L{Action.trigger()} on the action returned will execute it.

See L{create()} for a description of action paths.

@type  rPath: str
@param rPath: The path to the action to find
@rtype: L{Action}
@return: The requested action
@raise ValueError: Raised if the requested action was not found.
@see: L{find()}
----------
ActionManager.list
Returns a list of the available actions.

Without a parameter this action will return a list of all actions, including the full path The user may optionally pass in a path to a subtree. Given a subtree, only actions in that subtree will be returned.

@type  rPath: str
@param rPath: An optional path to a subtree. If provided, only actions in that subtree will be returned
@rtype: list of str
@return: A list of actions, including their path
----------
ActionManager.loadUserShortcuts
Loads user shortcuts from the configuration file.

This is provided mainly for internal use, so user-specific shortcuts can be loaded after any shortcuts have been set up by the Python stage of the initialization process.

@rtype: None
----------
ActionManager.removeFromSet
Removes an action from an action set.

This will not modify the enabled state of the action.

@type  SetName: str
@param SetName: The set to remove the action from
@type  pAction: L{Action}
@param pAction: The action to remove
@rtype: None
@raise ValueError: Raised if the set name or action were invalid.
@see: L{addToSet()}, L{enableSet()}, L{disableSet()}, L{sets()}
----------
ActionManager.removeShortcut
Removes the given shortcut for the given action.

If the given shortcut is empty the first shortcut will be removed. If the action specified does not have any shortcuts, this function will complete successfully without raising an exception.

@type  Path: str
@param Path: The path to the action
@type  Shortcut: str
@param Shortcut: The shortcut to remove
@rtype: None
@raise ValueError: Raised if no action with the given path was found.
----------
ActionManager.removeShortcuts
Removes all shortcuts for the given action.

If the action specified does not any shortcuts, this function will complete successfully without raising an exception.

@type  Path: str
@param Path: The path to the action
@rtype: None
@raise ValueError: Raised if no action with the given path was found.
----------
ActionManager.setShortcut
Sets the shortcut for the given action.

Shortcuts can be single keys ("F1"), keys with modifiers ("Ctrl+A"), or empty to specify no shortcut.

@type  Path: str
@param Path: The path to the action
@type  Shortcut: str
@param Shortcut: The new shortcut string for the given action. Pass in an empty string to clear the shortcut
@rtype: bool
@return: Always True. On failure, it raises an exception. I{(See below - please do not use this return value)}
@raise ValueError: Raised if no action with the given path was found, or if the shortcut string was invalid.
@deprecated: Please avoid using the return value of this function. It will be removed in a future version.
@see: L{shortcut()}
----------
ActionManager.sets
Returns the list of defined action set names.

L{Action} sets are groups of actions that can be enabled and disabled as a group. This can be used to easily configure Mari depending on the context. If, for example, you have actions that only work on floating point channels, they can be added to an action set, and then enabled or disabled depending on the currently selected channel.

Actions can be added to multiple sets. However, please note that the sets themselves do not have an enabled state; only the actions do. This means that, for example, if an action has been added to two sets, and L{enableSet()} is called on one and then L{disableSet()} is called on the other, the action will be disabled - but, if the calls are the other way around, it will be enabled. In other words, there is no way of saying "disable (or enable) this action if either of its two sets are disabled (or enabled)". If this behavior is not suitable, please define a new set and enable and disable that one separately.

@rtype: list of str
@return: The list of defined action set names
@see: L{addToSet()}, L{enableSet()}, L{disableSet()}, L{removeFromSet()}
----------
ActionManager.shortcut
Returns the first shortcut for the given action.

@type  Path: str
@param Path: The path to the action
@rtype: str
@return: A string returning the first shortcut for the given action, or an empty string if there is no shortcut.
@see: L{setShortcut()}
----------
ActionManager.shortcutIsInUse
Indicates whether the given shortcut is in use.

@type  Shortcut: str
@param Shortcut: The string version of the shortcut to check (e.g. "Ctrl+S")
@rtype: bool
@return: True if the shortcut is in use, or False otherwise
----------
ActionManager.shortcuts
Returns all shortcuts for the given action.

@type  Path: str
@param Path: The path to the action
@rtype: list of str
@return: A list of all shortcuts for the given action, or an empty list if there is no shortcuts.
----------
AdjustableLayer
Adjustable layers can be set to apply an adjustment stack to their image data.

Adjustment stacks can be used to apply a set of adjustment operations to only the image data in the individual layer, without affecting those below it.

This is an abstract class; every layer that is an L{AdjustableLayer} will also be of a further-derived type, such as L{PaintableLayer}.

B{Example Code}

>>> #This example finds adjustmentable layers in the current channel.
>>> import mari
>>> adjustable_layers = []
>>> channel = mari.geo.current().currentChannel()
>>> for layer in channel.layerList():
...     if layer.isAdjustableLayer():
...         adjustable_layers.append(layer)
----------
AdjustableLayer.adjustmentStack
Returns the adjustment layer stack that is applied to this layers paint image set.

@rtype: L{LayerStack}
@return: Returns a layer stack
@raise RuntimeError: Raised if the layer has no paint adjustment stack.
----------
AdjustableLayer.hasAdjustmentStack
Indicates whether this layer has an adjustment stack.

@rtype: bool
@return: True is this layer has an adjustment stack
----------
AdjustableLayer.isAdjustmentStackEnabled
Indicates if the adjustment stack is disabled.

@rtype: bool
@return: False is an adjustment stack is present and disabled.
----------
AdjustableLayer.makeAdjustmentStack
Creates an adjustment stack on the layer.

@rtype: L{LayerStack}
@return: Returns the created layer stack
@raise RuntimeError: Raised if the layer adjustment stack cannot be create or already exists or the layer is not modifiable.
----------
AdjustableLayer.removeAdjustmentStack
Removes the adjustment stack from the layer

@rtype: None
@raise RuntimeError: Raised if the layer adjustment stack cannot be removed or does not exist or the layer is not modifiable.
----------
AdjustableLayer.setAdjustmentStackEnabled
Set the enabled state of the adjustment stack.

@type  Enabled: bool
@param Enabled: The enabled state to set the adjustment stack to
@rtype: None
----------
AdjustmentLayer
Adjustment layers modify the data from the layers below them in the layer stack.

You can access all types of layers from their containing L{Channel} objects - for example: C{channel.layerList()}

You can check for L{AdjustmentLayer} objects by calling L{Layer.isAdjustmentLayer()}:

B{Example Code}

>>> #This example finds adjustment layers in the current channel
>>> import mari
>>> adjustment_layers = []
>>> channel = mari.geo.current().currentChannel()
>>> for layer in channel.layerList():
...     if layer.isAdjustmentLayer():
...         adjustment_layers.append(layer)

>>> #This example creates an "Brightness" adjustment layers in the current channel
>>> import mari
>>> channel = mari.geo.current().currentChannel()
>>> layer = channel.createAdjustmentLayer("Brightness","Filter/Brightness")
>>> layer.isAdjustmentLayer()
True
----------
AdjustmentLayer.getPrimaryAdjustmentParameter
Retrieves the current value of a parameter from this primary adjustment layer.

@type  ParameterName: str
@param ParameterName: The name of the parameter to inspect
@rtype: variant
@return: The current value of the parameter
@raise ValueError: Raised if name of the parameter does not match any existing items.
@see: L{setPrimaryAdjustmentParameter()}
----------
AdjustmentLayer.getPrimaryAdjustmentParameterAsImage
Retrieves the current value of a parameter from this primary adjustment layer and, if possible, return the L{Image} it relates to.

@type  ParameterName: str
@param ParameterName: The name of the parameter to inspect.
@rtype: L{Image}
@return: L{Image} of the parameter. None if not image is assigned.
@raise ValueError: Raised if name of the parameter does not match any existing items.
@see: L{getPrimaryAdjustmentParameter()}
----------
AdjustmentLayer.getSecondaryAdjustmentParameter
Retrieves the current value of a parameter from this secondary adjustment layer.

@type  ParameterName: str
@param ParameterName: The name of the parameter to inspect.
@rtype: variant
@return: The current value of the parameter.
@raise ValueError: Raised if name of the parameter does not match any existing items.
@raise RuntimeError: Raised if the layer has no secondary adjustment.
@see: L{setSecondaryAdjustmentParameter()}
----------
AdjustmentLayer.getSecondaryAdjustmentParameterAsImage
Retrieves the current value of a parameter from this primary secondary layer and, if possible, return the L{Image} it relates to.

@type  ParameterName: str
@param ParameterName: The name of the parameter to inspect.
@rtype: L{Image}
@return: L{Image} of the parameter. None if not image is assigned.
@raise ValueError: Raised if name of the parameter does not match any existing items.
@see: L{getSecondaryAdjustmentParameter()}
----------
AdjustmentLayer.hasSecondaryAdjustment
Indicates whether this adjustment layer has a secondary adjustment.

@rtype: bool
@return: True is this layer has a secondary adjustment
----------
AdjustmentLayer.makeSecondaryAdjustment
Makes a secondary adjustment on this adjustment layer.

@type  AdjustmentKey: str
@param AdjustmentKey: the path key of the type of the adjustment to create
@rtype: None
@raise ValueError: Raised if adjustment key parameter does not match any valid value
@raise RuntimeError: Raised if the secondary adjustment cannot be create or already exists. Or the layer is not modifiable.
----------
AdjustmentLayer.primaryAdjustmentName
Get the name of the primary adjustment type.

@rtype: str
@return: The name of the type of primary adjustment, which will be of the form C{'Brightness.adjustment'}
@deprecated: Please use the more reliable function L{primaryAdjustmentType()} instead.
----------
AdjustmentLayer.primaryAdjustmentParameters
Returns the list of parameters on this primary adjustment layer.

@rtype: list of str
@return: A list of the parameter names for this primary adjustment layer
----------
AdjustmentLayer.primaryAdjustmentType
Returns the name of the primary adjustment type.

@rtype: str
@return: The name of the type of primary adjustment, which will be of the form C{'Filter/Brightness'}
----------
AdjustmentLayer.removeSecondaryAdjustment
Removes a secondary adjustment on this adjustment layer.

@rtype: None
@raise RuntimeError: Raised if the secondary adjustment cannot be removed or does not exist. Or the layer is not modifiable.
----------
AdjustmentLayer.secondaryAdjustmentName
Get the name of the secondary adjustment type.

@rtype: str
@return: The name of the type of secondary adjustment, which will be of the form C{'Brightness.adjustment'}
@raise RuntimeError: Raised if the layer has no secondary adjustment.
@deprecated: Please use the more reliable function L{secondaryAdjustmentType()} instead.
----------
AdjustmentLayer.secondaryAdjustmentParameters
Returns the list of parameters on this secondary adjustment layer.

@rtype: list of str
@return: A list of the parameter names for this secondary adjustment layer.
@raise RuntimeError: Raised if the layer has no secondary adjustment.
----------
AdjustmentLayer.secondaryAdjustmentType
Returns the name of the secondary adjustment type.

@rtype: str
@return: The name of the type of secondary adjustment, which will be of the form C{'Filter/Brightness'}
@raise RuntimeError: Raised if the layer has no secondary adjustment.
----------
AdjustmentLayer.setPrimaryAdjustmentParameter
Sets the value of a parameter on the primary adjustment.

@type  ParameterName: str
@param ParameterName: The name of the parameter to modify
@type  NewValue: variant
@param NewValue: The new value for the parameter. This can be of a variety of types.
@rtype: None
@raise ValueError: Raised if the parameter could not be found, or was invalid.
@see: L{getPrimaryAdjustmentParameter()}
----------
AdjustmentLayer.setSecondaryAdjustmentParameter
Sets the value of a parameter on the secondary adjustment.

@type  ParameterName: str
@param ParameterName: The name of the parameter to modify.
@type  NewValue: variant
@param NewValue: The new value for the parameter. This can be of a variety of types.
@rtype: None
@raise ValueError: Raised if the parameter could not be found, or was invalid.
@raise RuntimeError: Raised if the layer has no secondary adjustment.
@see: L{getSecondaryAdjustmentParameter()}
----------
AppVersion
This class contains detailed version information for Mari.

B{Example Code}

>>> # This example stores mari information in a string and prints it out to the application log
>>> import mari
>>> version = mari.app.version()
>>> mari_info_dict = {}
>>> mari_info_dict["major"]    = version.major()
>>> mari_info_dict["minor"]    = version.minor()
>>> mari_info_dict["revision"] = version.revision()
>>> mari_info_dict["stage"]    = version.stage()
>>> mari_info_string = "Mari {major}.{minor}.{revision}{stage}".format(**mari_info_dict)
>>> mari.app.log(mari_info_string)
----------
AppVersion.date
Returns the date that this version was built.

@rtype: str
@return: The build date as a string, in YYYY-MM-DD format.
----------
AppVersion.info
Returns an information string describing the build.

@rtype: str
----------
AppVersion.isLinux
Indicates whether Mari is running on Linux.

@rtype: bool
@return: True if on Linux, or False on other operating systems
----------
AppVersion.isMac
Indicates whether Mari is running on Mac OS X.

@rtype: bool
@return: True if on Mac OS X, or False on other operation systems
----------
AppVersion.isWindows
Indicates whether Mari is running on Windows.

@rtype: bool
@return: True if on Windows, or False on other operating systems
----------
AppVersion.iteration
Returns the iteration number, as used in alpha and beta builds.

For example, the iteration number of 1.2v3b4 is 4.

@rtype: int
----------
AppVersion.major
Returns the major version number of the build.

For example, the major version number of 1.2v3 is 1.

@rtype: int
----------
AppVersion.minor
Returns the minor version number of the build.

For example, the minor version number of 1.2v3 is 2.

@rtype: int
----------
AppVersion.number
Returns the full build version as an integer for comparison.

These build version integers can be compared to easily test whether one build comes before or after another.

The number consists of the major, minor, revision, stage, and iteration components of the version. For example, 1.5v6b7 would be 10506207 (with the 2 referring to the beta stage), and 1.5v6 would be 10506300 (with the 3 for the release stage).

@rtype: quint64
----------
AppVersion.qt
Returns the Qt version as a string.

@rtype: str
@return: The version of Qt that Mari was built with, in x.x.x format.
----------
AppVersion.revision
Returns the 'v' revision number of the build.

For example, the revision number of 1.2v3 is 3.

@rtype: int
----------
AppVersion.stage
Returns the build stage - development, alpha, beta, or release.

@rtype: L{Stage}
----------
AppVersion.string
Returns the full build version as a string for display.

@rtype: str
----------
AppVersion.time
Returns the time that this version was built.

@rtype: str
@return: The build time as a string, in 24 hour HH-MM format.
----------
Application
This object handles basic operations to be performed on the entire application.

B{Example Code}

>>> # This example prints out "Hello World" to the application log
>>> import mari
>>> mari.app.log("Hello World")
----------
Application.activateMainWindow
Sets the desktop focus to the Mari window.

The standard focus rules for the OS apply. For example, on Windows the application must have permission to set the foreground window; otherwise, it flashes the taskbar icon instead.

@rtype: None
@see: U{MSDN: SetForegroundWindow() (for Windows)<http://msdn.microsoft.com/en-us/library/windows/desktop/ms633539%28v=vs.85%29.aspx>}
----------
Application.addTab
Adds a custom tab to the main window.

Users can add custom tabs to the tab bar on the main window. The user is responsible for enabling and disabling these tabs when required.

@type  Name: str
@param Name: The name of the new tab. This will appear in the tab bar
@type  Widget: QWidget
@param Widget: The widget for the new tab
@rtype: None
@raise ValueError: Raised if the name or widget were invalid.
@see: L{removeTab()}
----------
Application.autosaveReset
This is emitted when the application autosave is reset.

@rtype: None
----------
Application.autosaveTriggered
This is emitted when the application autosave is triggered.

We call the autosave manager several times at various places throughout the application. The autosave manager is responsible to maintain the current time and when the autosave should next happen and update the timer accordingly. This means that we could call the autosave manager a hundred times and only one call will get through at the scheduled time. This makes the autosaving efficient. To that end, if the autosave call is not completed (because it's not yet time), we return the scheduled time as a string. Otherwise, if the call does go through and an autosave is performed, we return an empty string here.

@type  ScheduledTime: str
@param ScheduledTime: This is the time when the autosave is scheduled next.
@rtype: None
----------
Application.backgroundJobCaption
Returns the caption for the background job ID.

@type  JobID: qint64
@param JobID: The ID of the job to query the caption.
@rtype: str
@return: The caption for the background job ID.
----------
Application.backgroundJobIDs
Returns the list of job IDs for background jobs.

@rtype: list of  qint64
@return: The list of job IDs for background jobs.
----------
Application.backgroundJobsRunning
This is emitted when Mari begins and end background processing of jobs.

Mari can run multiple jobs in the background while the user is working. These can be tasks like exporting or importing images or performing long running processing. This signal informs the user when Mari starts or end processing background tasks. This is only emitted as True when Mari goes from a state where no background jobs are running to running background jobs. If Mari is currently running background jobs and new jobs are added this signal is not emitted. 
C{#Print out a message when background jobs start or stop}

C{def printRunning(a):}

C{print 'Background Job Running ', a}

C{mari.utils.connect(mari.app.backgroundJobsRunning, printRunning)}

@type  AreJobsRunning: bool
@param AreJobsRunning: True if background jobs are now scheduled, or False if there are no more background jobs
@rtype: None
----------
Application.canceledProcessing
This is emitted when the user cancels a long-running job.

Note that this is the signal version. The matching function call is L{wasProcessingCanceled()}.

Avoid immediately showing GUI elements in response to this signal. The application will not be processing user input at this stage, and may become unresponsive if a blocking element (such as a message box) is displayed.

@rtype: None
@see: L{startingProcessing}, L{endingProcessing}, L{wasProcessingCanceled()}
----------
Application.canvasHeight
Get the current height of the canvas area.

@rtype: int
----------
Application.canvasSize
(Deprecated) Get the current size of the canvas area

@rtype: QSize
@deprecated: Please use L{canvasWidth()} and L{canvasHeight()} instead.
----------
Application.canvasWidth
Get the current width of the canvas area.

@rtype: int
----------
Application.captureDesktop
Captures a pixmap of the desktop and returns it.

@rtype: QPixmap
@return: A QPixmap containing the desktop image
----------
Application.clearScriptOutput
Clears the script console output.

@rtype: None
----------
Application.commandPortEnabled
Indicates whether the command port is currently enabled.

@rtype: bool
@return: True if the command port is ready to accept connections, or False if not
----------
Application.commandPortNumber
Returns the port number that the command port will accept connections on.

@rtype: int
@see: L{enableCommandPort()}, L{setCommandPortNumber()}
----------
Application.createCustomDisplayWidget
Creates and returns a custom display widget into which Display Render Plugin can render.

@type  Name: str
@param Name: The name of the custom display widget to create
@type  OffscreenBufferWidth: int
@param OffscreenBufferWidth: The width of the offscreen buffer inside the custom display widget.
@type  OffscreenBufferHeight: int
@param OffscreenBufferHeight: The height of the offscreen buffer inside the custom display widget.
@type  Widget: QWidget
@param Widget: The PySide QWidget object into which the custom display widget is created.
@rtype: None
@return: A custom display widget into which Display Render Plugin can render.
----------
Application.createToolBar
Creates a custom toolbar and adds it to the main window.

Users can add custom toolbars to the main window. The user is responsible for enabling and disabling these toolbars when required.

@type  Name: str
@param Name: The name of the new toolbar
@type  Area: L{ToolBarArea}
@param Area: The area of the main window to place the toolbar in
@type  IsVisible: bool
@param IsVisible: Whether the toolbar is initially visible.
@rtype: L{ToolBar}
@return: The newly-created toolbar.
@raise ValueError: Raised if the name was invalid, or a toolbar with the given name already exists.
@see: L{deleteToolBar()}
----------
Application.deleteToolBar
Removes a custom tab from the main window.

@type  Name: str
@param Name: The name of the tab to remove
@rtype: None
@raise ValueError: Raised if no tab with the given name was found
----------
Application.enableCommandPort
Enables or disables the command port.

After enabling, Mari will accept connections on the specific command port.

@type  Enabled: bool
@rtype: None
@see: L{commandPortNumber()}
----------
Application.endingProcessing
This is emitted when all long-running jobs have finished.

Note that startingProcessing is emitted for each job that begins, but endingProcessing is only emitted once, when all active jobs have completed.

@rtype: None
@see: L{canceledProcessing}, L{startingProcessing}
----------
Application.exit
Exits Mari.

This is the same as L{quit()}, but allows the caller to specify a result code.

@type  ResultCode: int
@param ResultCode: The result code to return to the application's caller.
@type  ConfirmIfProjectModified: bool
@param ConfirmIfProjectModified: When set to True (the default), a confirmation dialog will be shown if a project is open and needs saving. When set to False, this exits without confirmation.
@rtype: None
@note: When running in terminal mode, the project will always be closed without confirmation.
----------
Application.exiting
This is emitted just before Mari exits.

The signal will only be emitted if the user accepts any confirmation dialogs (such as the save project before closing dialog). If so, the project will be closed, and then the signal will be emitted before any further shut down processing is performed.

For example, it is safe to perform project maintenance operations in response to this signal if desired.

@rtype: None
----------
Application.findToolBar
Returns the tool bar with the given name, or None if not found.

@type  Name: str
@rtype: L{ToolBar}
@return: The tool bar with the given name, or None if not found.
----------
Application.fullScreenChanging
This is emitted when the full screen state of the main window is about to change.

@type  FullScreen: bool
@param FullScreen: True if the main window is becoming full screen, or False if it is becoming windowed.
@rtype: None
----------
Application.geometry
Returns the geometry of the main window.

@rtype: QRect
@return: The geometry of the main window.
@see: L{setGeometry()}
----------
Application.hasPendingPortCommands
Returns whether any commands have been received by the command port but not yet executed.

@rtype: bool
@return: True if any commands are pending, or False if not
----------
Application.inRestrictedVersion
Indicates whether the app is running in a restricted version (i.e, Minion or non commercial mode).

This indicates whether the application is run in a restricted mode (Indie or non commercial mode).

@rtype: bool
@return: True if the app has restrictions.
----------
Application.inTerminalMode
Indicates whether the app is running in terminal mode.

This includes interactive terminal mode ("mari -t") and execute mode ("mari -x").

@rtype: bool
@return: True if the app is in terminal mode, or False if not.
----------
Application.isBackgroundJobFinished
Returns whether the job of the given job ID has finished running in the background.

@type  JobID: qint64
@param JobID: The ID of the job to check the status.
@rtype: bool
@return: Whether the job of the given job ID has finished running in the background.
----------
Application.isFullScreen
Returns whether the main window is set to full screen.

@rtype: bool
@return: True if the main window is covering the full screen, or False if not.
----------
Application.isMaximized
Returns whether the main window is maximized.

@rtype: bool
@return: True if the main window is maximized, or False if not.
----------
Application.isMinimized
Returns whether the main window is minimized.

@rtype: bool
@return: True if the main window is minimized, or False if not.
----------
Application.isProcessing
Returns whether or not a long processing operation is active.

This will perform a poll of the processing state. It is advisable to use the L{startingProcessing()} and L{endingProcessing()} signals to track processing operations in a non-blocking way.

@rtype: bool
@return: True if a long processing operation is active or False otherwise.
@see: L{progress()}, L{endingProcessing()}, L{progressDescription()}, L{startingProcessing()}
----------
Application.isRunning
Returns whether the application is currently running.

This is currently only for internal use.

@rtype: bool
@return: True when Mari is running (currently in all practical cases for users), or False in some special internal cases such as documentation generation.
----------
Application.isSafeFeatureBypassUserEnvironmentResourceKeysEnabled
Indicates whether the app is running in safe mode at a level where we want to bypass any user environment resource key values settings.

@rtype: bool
@return: True if the app is in safe mode, or False if not.
----------
Application.log
Writes the given message to the log file for the application.

In verbose mode, the message will also appear in the terminal, in the same way as many application debug messages.

@type  Message: str
@param Message: The message to write
@rtype: None
----------
Application.maximize
Maximizes the main window.

@rtype: None
----------
Application.minimize
Minimizes the main window.

@rtype: None
----------
Application.numProcessingSteps
Returns he number of steps to be performed in the current long running processing operation.

This is only valid if a processing operation is active.

@rtype: int
@return: The number of steps to be performed in the processing.
@raise RuntimeError: Raised if there is no processing operation active.
@see: L{progress()}, L{endingProcessing()}, L{progressDescription()}, L{startingProcessing()}
----------
Application.onProgress
This is emitted to update the progress of a long-running job.

@type  Progress: int
@param Progress: The progress of the currently running job, as an integer between 0 and NumSteps, inclusive.
@rtype: None
----------
Application.processEvents
Processes events such as redrawing the screen and updating the GUI.

This is for use during long running operations.

This function is called automatically by many of the processing functions, such as L{setProgress()}. If you perform other long-running operations, or do not call L{setProgress()} very often, consider calling this function manually to improve the interactivity of the application.

@rtype: None
@see: L{canceledProcessing()}, L{wasProcessingCanceled()}, L{setProgress()}, L{setProgressDescription()}, L{stopProcessing()}, L{stepProgress()}, L{startProcessing()}
----------
Application.progress
Returns the progress of the current long running processing operation.

This is only valid if a processing operation is active.

@rtype: int
@return: The number of steps completed in this processing operation.
@raise RuntimeError: Raised if there is no processing operation active.
@see: L{canceledProcessing()}, L{wasProcessingCanceled()}, L{setProgress()}, L{setProgressDescription()}, L{stopProcessing()}, L{processEvents()}, L{stepProgress()}, L{startProcessing()}
----------
Application.progressDescription
Returns the process description of the current long running processing operation.

This is only valid if a processing operation is active.

@rtype: str
@return: The user-readable description of the process.
@raise RuntimeError: Raised if there is no processing operation active.
@see: L{canceledProcessing()}, L{wasProcessingCanceled()}, L{setProgressDescription()}, L{stopProcessing()}, L{processEvents()}, L{stepProgress()}, L{startProcessing()}
----------
Application.progressDescriptionChanged
This is emitted to update the description of a long-running job.

@type  NewDescription: str
@param NewDescription: A description of the job for display.
@rtype: None
----------
Application.quit
Quits Mari.

This is the same as L{exit()}.

@type  ConfirmIfProjectModified: bool
@param ConfirmIfProjectModified: When set to True (the default), a confirmation dialog will be shown if a project is open and needs saving. When set to False, this exits without confirmation.
@rtype: None
@note: When running in terminal mode, the project will always be closed without confirmation.
----------
Application.removeTab
Removes a custom tab from the main window.

@type  Name: str
@param Name: The name of the tab to remove
@rtype: None
@raise ValueError: Raised if no tab with the given name was found
@see: L{addTab()}, L{tabNames()}
----------
Application.restore
Restores the main window to the size it was before minimize, maximize or full screen.

@rtype: None
----------
Application.restoreCursor
Restores cursor.

Restores the cursor after calling setBusyCursor.

@rtype: None
@see: setBusyCursor()
----------
Application.resumeProcessing
Resumes a temporarily suspended long processing operation.

Call this function as soon as the user interaction that the processing was suspended for has been performed.

@rtype: None
@see: L{suspendProcessing()}
----------
Application.setActiveTab
Sets the currently active, visible tab.

@type  Name: str
@param Name: The name of the tab to make active
@rtype: None
@raise ValueError: Raised if no tab with the given name was found
@see: L{tabNames()}
----------
Application.setCommandPortNumber
Sets the port number that the command port should accept connections on.

This will close any existing connections and restart the command port on a new socket.

@type  Number: int
@rtype: None
@see: L{commandPortNumber()}
----------
Application.setFixedCanvasSize
Set the current canvas area to a fixed size.

This fixes the canvas area to a certain size, preventing the user from modifying it in any way, until unfixed. Passing in an invalid size will unfix the canvas area and enable the user to modify the size again.

@type  Width: int
@param Width: The width to fix the canvas area too, or zero or less to unfix.
@type  Height: int
@param Height: The height to fix the canvas area too, or zero or less to unfix.
@rtype: None
----------
Application.setFullScreen
Sets the full screen state of the main window.

@type  FullScreen: bool
@param FullScreen: True will set Mari to full screen mode; False will set it to normal windowed behavior.
@rtype: None
----------
Application.setGeometry
Sets the geometry of the main window.

@type  Geom: QRect
@param Geom: The new geometry of the main window.
@rtype: None
@see: L{geometry()}
----------
Application.setNukeConnectionActive
Sets the status of the Nuke connection indicator.

@type  Active: bool
@param Active: True to show the indicator, or False to hide it
@type  ConnectionInfo: str
@param ConnectionInfo: Text info describing the connection. This will be displayed in the status bar as "Connected to Nuke" followed by the given text
@rtype: None
----------
Application.setProgress
Provides an indication of the progress of a long running processing operation.

This will update the status bar on the main window.

This function will automatically call L{processEvents()} once to ensure that the change to the status bar is displayed to the user.

@type  Progress: int
@param Progress: The number of steps completed in this processing operation. This should be at least zero and at most the value passed as NumSteps to L{startProcessing()}.
@rtype: None
@see: L{canceledProcessing()}, L{wasProcessingCanceled()}, L{setProgressDescription()}, L{stopProcessing()}, L{progress()}, L{processEvents()}, L{stepProgress()}, L{startProcessing()}
----------
Application.setProgressDescription
Sets the process description displayed in the status bar.

This will update the status bar on the main window replacing the description provided to L{startProcessing()}.

This function will automatically call L{processEvents()} once to ensure that the change to the status bar is displayed to the user.

@type  Description: str
@param Description: A user-readable description of the process - e.g. "Processing Data". This will be displayed in the status bar.
@rtype: None
@see: L{canceledProcessing()}, L{wasProcessingCanceled()}, L{stopProcessing()}, L{processEvents()}, L{progressDescription()}, L{stepProgress()}, L{startProcessing()}
----------
Application.setWaitCursor
Switches cursor to Qt::WaitCursor.

Switches cursor to Qt::WaitCursor. Restore by calling restoreCursor.

@rtype: None
@see: L{restoreCursor()}
----------
Application.startProcessing
Registers the start of a long processing operation.

Mari gives the user feedback on the status of long running processes. This method indicates the start of one of these processes. It is a good idea to always start this when processing data. Mari will display a busy icon, and calls to L{setProgress()} will update a status bar in the bottom right corner of the application GUI.

Calls to L{startProcessing()} must always be followed by a L{stopProcessing()} call. It may also be useful to call L{processEvents()} during your processing loop to give the application time to update the GUI.

This function will automatically call L{processEvents()} once to ensure that the new status bar is displayed to the user.

@type  Description: str
@param Description: A user-readable description of the process - e.g. "Processing Data". This will be displayed in the status bar.
@type  NumSteps: int
@param NumSteps: The number of steps to be performed in the processing. Calls to setProgress should indicate the number of steps completed.
@type  CanCancel: bool
@param CanCancel: Set this to True if the action being executed can be safely canceled
@rtype: None
@attention: If run in the script editor, this function will cause Mari to become non-interactive until L{stopProcessing()} is called, so make sure you call it as part of your script or you will not be able to enter any further commands.
@see: L{suspendProcessing()}, L{canceledProcessing()}, L{wasProcessingCanceled()}, L{setProgress()}, L{setProgressDescription()}, L{stopProcessing()}, L{processEvents()}, L{stepProgress()}, L{numProcessingSteps()}
----------
Application.startingProcessing
This is emitted when a long-running job starts.

@type  Operation: str
@param Operation: A description of the job for display.
@type  NumSteps: int
@param NumSteps: The number of steps involved in this job
@rtype: None
@see: L{canceledProcessing}, L{endingProcessing}
----------
Application.stepProgress
Moves forward the progress indicator of a long running processing operation by one step.

This will update the status bar on the main window.

This function will automatically call L{processEvents()} once to ensure that the change to the status bar is displayed to the user.

@rtype: None
@raise RuntimeError: Raised if the current progress is already at 100%.
@see: L{canceledProcessing()}, L{wasProcessingCanceled()}, L{setProgress()}, L{stopProcessing()}, L{processEvents()}, L{setProgressDescription()}, L{startProcessing()}
----------
Application.stopProcessing
Registers the end of a long processing operation.

This should always be called after L{startProcessing()}.

@rtype: None
@see: L{canceledProcessing()}, L{wasProcessingCanceled()}, L{setProgress()}, L{setProgressDescription()}, L{processEvents()}, L{stepProgress()}, L{startProcessing()}
----------
Application.suspendProcessing
Temporarily suspends a long processing operation.

Normally, long-running processing operations ignore mouse and keyboard input from the user while running. Use this function to suspend the processing temporarily, and allow mouse and keyboard input again, if input is required from the user - such as in the case of a message box querying the user for action.

Make sure you call L{resumeProcessing()} again as soon as possible, or the status bar will not be updated, and users may be able to interfere with processing operations by making changes through the GUI at the same time.

@rtype: None
@see: L{resumeProcessing()}
----------
Application.tabNames
Lists the available tabs in the main window.

@rtype: list of str
@see: L{setActiveTab()}, L{removeTab()}, L{addTab()}
----------
Application.toggleFullScreen
Toggle the main window between full screen and windowed states.

@rtype: None
----------
Application.toolBar
Returns the tool bar with the given name.

@type  Name: str
@rtype: L{ToolBar}
@return: The tool bar with the given name
@raise ValueError: Raised if no tool bar with the given name exists.
----------
Application.toolBarsCreated
This is emitted when the window tool bars are created.

@rtype: None
----------
Application.version
Returns an object that contains version information for Mari.

@rtype: L{AppVersion}
----------
Application.wasProcessingCanceled
Checks to see if the user has chosen to cancel a long-running process.

Users can cancel many long-running processes by clicking the 'X' button on the progress bar when one is present, or by pressing the "Escape" key.

Note that this is the function version. There is a matching signal called L{canceledProcessing()}.

@rtype: bool
@return: True if the current processing should be canceled, or False otherwise
@note: This function should be called sporadically, because calling this method may also call L{processEvents()} and slow down processing if called continuously.
@see: L{setProgress()}, L{setProgressDescription()}, L{stopProcessing()}, L{canceledProcessing}, L{processEvents()}, L{stepProgress()}, L{startProcessing()}
----------
BakePointLayer
BakePoint layers contain an image for each patch that can be painted directly.

You can access all types of layers from their containing L{Channel} objects - for example: C{channel.layerList()}

You can check for L{BakePointLayer} objects by calling L{Layer.isBakePointLayer()}:

This examples shows how to create a Bake Point layer and checks if it's a BakePoint layer

>>> import mari
>>> channel = mari.geo.current().currentChannel()
>>> bakePointLayer = channel.createBakePointLayer("Test")
>>> bakePointLayer.isBakePointLayer()
True
----------
BakePointLayer.bake
Bakes the result at this layer into the image set.

Bakes the result at this layer into the image set.

The result of baking can be obtained by L{bakedResult()}.

@rtype: None
----------
BakePointLayer.bakedResult
Returns the image set of baked result.

@rtype: L{ImageSet}
@return: The image set this layer holds as baked result.
@raise RuntimeError: Raised if the image set cannot be found.
----------
BakePointLayer.deleteBakedResult
Deletes the baked result.

@rtype: None
----------
BakePointLayer.hasBakedResult
Returns whether there is baked result.

@rtype: bool
----------
BakePointLayer.isBakedResultUpToDate
Returns whether the baked result is up to date.

Returns whether the baked result is up to date.

If there is no baked result yet, this will return False.

@rtype: bool
----------
BakePointLayer.setUseBaked
Sets whether this layer should use the baked result if available.

@type  UseBaked: bool
@rtype: None
@see: L{useBaked()}
----------
BakePointLayer.useBaked
Returns whether this layer should use the baked result or not.

@rtype: bool
@see: L{setUseBaked()}
----------
BakePointNode
Represents node speciailizing in baking result of intermediate point in the L{NodeGraph}.

B{Example Code}

This example shows how to create a L{BakePointNode}

>>> import mari
>>> nodeGraph = mari.geo.current().nodeGraph()
>>> paintNode = nodeGraph.createBakePointNode( 1024, 1024, 8, mari.Color(1.0,1.0,0.0,1.0) )

This example obtains a L{BakePointNode} from the node graph of the current geo entity and

>>> for node in nodeGraph.nodeList():
...   if node.isBakePointNode():
...     mari.app.log( "Found BakePointNode : "+node.nodeName() )
----------
BakePointNode.bake
Bakes the result at this node into the image set.

Bakes the result at this node into the image set.

The result of baking can be obtained by L{bakedResult()}.

@rtype: None
----------
BakePointNode.bakedResult
Returns the image set of baked result.

@rtype: L{ImageSet}
@return: The image set this node holds as baked result.
@raise RuntimeError: Raised if the image set cannot be found.
----------
BakePointNode.deleteBakedResult
Deletes the baked result.

@rtype: None
----------
BakePointNode.depth
Returns the depth of this BakePoint node.

@rtype: L{Image.Depth}
@return: The depth of this BakePoint node
----------
BakePointNode.exportPath
Returns the export path, where the baked textures will be exported to.

@rtype: str
@return: The export path, where the baked textures will be exported to
@see: L{setExportPath()}
----------
BakePointNode.hasBakedResult
Returns whether there is baked result.

@rtype: bool
----------
BakePointNode.isBakePointNode
Returns whether this node is a L{BakePointNode}.

@rtype: bool
@return: Whether this node is a L{BakePointNode}
----------
BakePointNode.isBakedResultUpToDate
Returns whether the baked result is up to date.

Returns whether the baked result is up to date.

If there is no baked result yet, this will return False.

@rtype: bool
----------
BakePointNode.setExportPath
Sets the export path, where the baked textures will be exported to.

@type  Path: str
@param Path: The export path, where the baked textures will be exported to
@rtype: None
@see: L{exportPath()}
----------
BakePointNode.setUseBaked
Sets whether this node should use the baked result if available.

@type  UseBaked: bool
@rtype: None
@see: L{useBaked()}
----------
BakePointNode.useBaked
Returns whether this node should use the baked result or not.

@rtype: bool
@see: L{setUseBaked()}
----------
Camera
Provides 3D camera settings.

B{Example Code}

>>> # This example obtains the camera of the current canvas view
>>> import mari
>>> camera = mari.canvases.current().camera()
>>> mari.app.log("Position = "+str(camera.translation().asTuple()))
----------
Camera.adjustClipPlanes
Adjusts the Near and Far clip planes so they contain the current geometry.

@rtype: None
----------
Camera.attributeChanged
This is emitted when the camera has had an internal attribute changed.

For example, this can be triggered by changes to the field of view, near or far clip plane, type, or name.

@rtype: None
----------
Camera.farClip
Returns the far clip plane.

@type  Frame: int
@rtype: float
@see: L{setFarClip()}
----------
Camera.fieldOfView
Returns the field of view.

@type  Frame: int
@rtype: float
@return: The field of view in degrees
@raise RuntimeError: Raised if the camera is not a perspective camera.
@see: L{setFieldOfView()}
----------
Camera.fieldOfViewX
Returns the horizontal field of view.

@type  Frame: int
@rtype: float
@return: The field of view in degrees
@raise RuntimeError: Raised if the camera is not a perspective camera.
@see: L{setFieldOfViewX()}
----------
Camera.fieldOfViewY
Returns the vertical field of view.

@type  Frame: int
@rtype: float
@return: The field of view in degrees
@raise RuntimeError: Raised if the camera is not a perspective camera.
@see: L{setFieldOfViewY()}
----------
Camera.isAnimated
Returns whether the camera is animated.

@rtype: bool
@return: True if the camera can be accessed for animation data, or False otherwise.
----------
Camera.lookAt
Returns the present look-at point.

@type  Frame: int
@rtype: L{VectorN}
@return: The 3D position the camera is looking at
@see: L{setLookAt()}
----------
Camera.moved
This is emitted after the camera has been moved: translated, scaled or rotated.

@rtype: None
----------
Camera.name
Returns the name of the camera.

@rtype: str
@return: The name of the camera.
@see: L{setName()}
----------
Camera.nearClip
Returns the near clip plane.

@type  Frame: int
@rtype: float
@see: L{setNearClip()}
----------
Camera.perspectiveAspectRatio
Returns the camera perspective aspect ratio

@rtype: float
@raise RuntimeError: Raised if the camera is not a perspective camera.
----------
Camera.projectionMatrix
Returns the entire 4x4 projection matrix of the camera.

The result will be a tuple of four tuples of floats representing the rows of the matrix - for example: 
  - ((1.0, 0.0, 0.0, 0.0), (0.0, 1.0, 0.0, 0.0), (0.0, 0.0, 1.0, 0.0), (0.0, 0.0, 0.0, 1.0))
The matrix will use the right-handed coordinate system.

@type  AspectRatio: float
@param AspectRatio: The ratio of width to height of the viewport. If not supplied (or zero), it defaults to the camera's L{viewportAspectRatio()}
@type  Frame: int
@param Frame: The frame number to return the matrix for, or -1 (the default) to return the value for the current frame
@rtype: variant
@return: The camera's view matrix, as described above
----------
Camera.scale
Returns the camera scale.

@rtype: float
@return: The camera view scale
@see: L{setScale()}
----------
Camera.setAnimated
Sets if the camera is animated.

@type  Animated: bool
@rtype: None
----------
Camera.setFarClip
Sets the distance to the far clip plane.

@type  FarClip: float
@rtype: None
@see: L{farClip()}
----------
Camera.setFieldOfView
Sets both the horizontal and vertical fields of view.

This also removes existing animation key frames.

@type  FieldOfView: float
@rtype: None
@raise RuntimeError: Raised if the camera is not a perspective camera.
@see: L{fieldOfView()}
----------
Camera.setFieldOfViewX
Sets the horizontal field of view.

This also removes existing animation key frames.

@type  FieldOfView: float
@rtype: None
@raise RuntimeError: Raised if the camera is not a perspective camera.
@see: L{fieldOfViewX()}
----------
Camera.setFieldOfViewY
Sets the vertical field of view.

This also removes existing animation key frames.

@type  FieldOfView: float
@rtype: None
@raise RuntimeError: Raised if the camera is not a perspective camera.
@see: L{fieldOfViewY()}
----------
Camera.setLookAt
Rotates the camera to look at the provided position.

@type  pLookAt: L{VectorN}
@rtype: None
@see: L{lookAt()}
----------
Camera.setName
Sets the camera name.

@type  Name: str
@rtype: None
@see: L{name()}
----------
Camera.setNearClip
Sets the distance to the near clip plane.

@type  NearClip: float
@rtype: None
@see: L{nearClip()}
----------
Camera.setScale
Sets the camera scale.

@type  Scale: float
@rtype: None
@see: L{scale()}
----------
Camera.setTranslation
Sets the translation (or position) of the camera.

@type  pLookAt: L{VectorN}
@rtype: None
@see: L{translation()}
----------
Camera.setType
Sets the camera display mode.

@type  Type: L{Type}
@rtype: None
@see: L{type()}
----------
Camera.setUp
Rotates the camera so that the specified vector is straight "up".

@type  pLookAt: L{VectorN}
@rtype: None
@see: L{up()}
----------
Camera.translation
Returns the camera location.

@type  Frame: int
@rtype: L{VectorN}
@return: The 3D position of the camera
@see: L{setTranslation()}
----------
Camera.type
Return the display mode of the camera.

@rtype: L{Type}
@return: the type of camera
@see: L{setType()}
----------
Camera.up
Returns the present up vector.

@type  Frame: int
@rtype: L{VectorN}
@return: The 3D direction pointing "up" from the top of the camera
@see: L{setUp()}
----------
Camera.viewMatrix
Returns the entire 4x4 view matrix of the camera.

The result will be a tuple of four tuples of floats representing the rows of the matrix - for example: 
  - ((1.0, 0.0, 0.0, 0.0), (0.0, 1.0, 0.0, 0.0), (0.0, 0.0, 1.0, 0.0), (0.0, 0.0, 0.0, 1.0))
The matrix will use the right-handed coordinate system.

@type  Frame: int
@param Frame: The frame number to return the matrix for, or -1 (the default) to return the value for the current frame
@rtype: variant
@return: The camera's view matrix, as described above
----------
Camera.viewport
Returns a rectangle describing the camera viewport.

@rtype: QRect
@return: The rectangle of the viewport.
----------
Camera.viewportAspectRatio
Returns the viewport aspect ratio.

@rtype: float
@return: The aspect ratio of the viewport
----------
Canvas
A canvas is a Mari viewport.

Canvases are the geometry viewport containers in the Mari window.

You can access canvas objects through the L{CanvasManager} - for example: C{mari.canvases.current()}

B{Example Code:}

>>> # This example shows how to access the current canvas object and to print canvas size to the application log
>>> import mari
>>> canvas = mari.canvases.current()
>>> mari.app.log(str(canvas.size()))
----------
Canvas.averageColor
Calculate the average color for an area in the canvas.

This allows a script to calculate the average pixel color values from the canvas. The x and y position must be in the range returned by L{size()} The color returned may be an HDR value with r, g, b values above 1.0 This method is relatively slow to execute and should not be used to the query lots of pixels 


C{#Pick a pixel in the middle of the screen}

C{Size = mari.canvases.current().size();}

C{c = mari.canvases.current().pickColor(Size.width()/2, Size.height()/2)}

C{print c.toString()}

@type  X: int
@param X: The x coordinate of the sample area. These coordinates are relative to the top left corner of the canvas
@type  Y: int
@param Y: The y coordinate of the sample area. These coordinates are relative to the top left corner of the canvas
@type  Width: int
@param Width: The width of the sample area. These coordinates are relative to the top left corner of the canvas
@type  Height: int
@param Height: The height of the sample area. These coordinates are relative to the top left corner of the canvas
@type  Space: L{PickSpace}
@param Space: The space in which to pick pixels in
@rtype: L{Color}
@return: The average color of the pixels at the canvas location (x, y, x + width, y + height)
@raise ValueError: Emitted if the sample area is outside of the range (0, 0) - L{size()}
----------
Canvas.camera
Returns the interface to the camera on the canvas, or None if none exists.

@rtype: L{Camera}
@return: The camera on the canvas, or None if none exists
----------
Canvas.capture
Captures an image of the canvas and returns it.

This is used for preview images of projects, for example.

@rtype: QImage
@return: A QImage containing the frame buffer image
----------
Canvas.captureImage
Captures a pixmap of the canvas and returns it.

This is used for preview images of projects, for example.

@type  ScaledWidth: int
@param ScaledWidth: If non-zero, the captured image is scaled to this width in pixels
@type  ScaledHeight: int
@param ScaledHeight: If non-zero, the captured image is scaled to this height in pixels
@rtype: QPixmap
@return: A QPixmap containing the frame buffer image
@deprecated: This function will be removed in a future version. Please use L{capture()} instead and then convert to a QPixmap if required.
----------
Canvas.displayPropertyList
Returns display property names that can be used as keys to manipulate any of the properties individually.

C{mari.canvases.current().displayPropertyList()}

@rtype: list of str
@return: a list of property keys
----------
Canvas.getDisplayProperty
Determines the state of a display property.

Get whether HUD is visible

C{mari.canvases.current().getDisplayProperty("HUD/RenderHud")}

Get the background image of the canvas

C{mari.canvases.current().getDisplayProperty("Background/BackgroundTexture")}

Get the grid size

C{mari.canvases.current().getDisplayProperty("Grid/UvGridSize")}

@type  PropertyKey: str
@param PropertyKey: A display property key to query, in the form "group name/sub property name". e.g : HUD/RenderHud
@rtype: variant
@return: A display property value
----------
Canvas.pickColor
Pick a color from the canvas.

This allows a script to pick pixel color values from the canvas. The x and y position must be in the range returned by L{size()} The color returned may be an HDR value with r, g, b values above 1.0 This method is relatively slow to execute and should not be used to the query lots of pixels 


C{#Pick a pixel in the middle of the screen}

C{Size = mari.canvases.current().size();}

C{c = mari.canvases.current().pickColor(Size.width() / 2, Size.height() / 2)}

C{print c.toString()}

@type  X: int
@param X: The x coordinate of the pixel. These coordinates are relative to the top left corner of the canvas
@type  Y: int
@param Y: The y coordinate of the pixel. These coordinates are relative to the top left corner of the canvas
@type  Space: L{PickSpace}
@param Space: The space in which to pick pixels in
@rtype: L{Color}
@return: The color of the pixel at the canvas location (x, y)
@raise ValueError: Emitted if X or Y are outside of the range (0, 0) - L{size()}
----------
Canvas.repaint
Forces the canvas to repaint itself immediately.

@rtype: None
----------
Canvas.requestRepaint
Requests the canvas to be repainted during the next events' processing.

@rtype: None
----------
Canvas.sceneCamera
Returns the interface to the scene camera associated with canvas's camera, or None, if none exists.

@rtype: L{Camera}
@return: The scene camera associated with canvas's camera, or None, if none exists.
----------
Canvas.setDisplayProperty
Sets the state of a display property.

Enable HUD

C{mari.canvases.current().setDisplayProperty("HUD/RenderHud", True)}

Set the background image of the canvas

C{mari.canvases.current().setDisplayProperty("Background/BackgroundTexture", "/tmp/bluesky.jpg")}

Set the grid size

C{mari.canvases.current().setDisplayProperty("Grid/UvGridSize", 5)}

@type  PropertyKey: str
@param PropertyKey: A display property key to set, in the form "group name/sub property name". e.g : HUDRenderHud
@type  NewValue: variant
@param NewValue: The new value to set
@rtype: None
----------
Canvas.size
Return the size of the L{Canvas} in pixels.

C{print mari.canvases.current().size()}

@rtype: QSize
@return: The Size of the canvas in pixels
----------
CanvasManager
This object handles the list of canvases, or viewports, available in the project.

B{Example Code:}

>>> # This example shows how to access the current canvas object and to print canvas size to the application log
>>> import mari
>>> canvas = mari.canvases.current()
>>> mari.app.log(str(canvas.size()))

>>> # This example show hot obtain the list of canvases
>>> import mari
>>> canvases = mari.canvases.list()
----------
CanvasManager.aboutToRenderCanvas
This is emitted when a canvas is about to be drawn.

@type  CanvasToDraw: L{Canvas}
@param CanvasToDraw: The canvas about to be drawn
@rtype: None
----------
CanvasManager.current
Returns the interface to the current canvas.

@rtype: L{Canvas}
@return: The currently active canvas, or None if no canvas is active.
----------
CanvasManager.fps
Returns the current frame rate.

@rtype: float
@return: The rate at which the canvas is being updated, in frames per second
----------
CanvasManager.list
Returns a list of the available canvases as L{Canvas} objects.

@rtype: list of  L{Canvas}
@return: A list of objects describing the available canvases
----------
CanvasManager.paintBuffer
Returns the current paint buffer.

The paint buffer is the transparent, screen-aligned plane that users paint into.

@rtype: L{PaintBuffer}
@return: The current paint buffer
----------
CanvasManager.renderError
This is emitted whenever a rendering error occurs in one of the canvases.

@type  ErrorCanvas: L{Canvas}
@param ErrorCanvas: The canvas where the errors have occurred
@type  ErrorMessages: list of str
@param ErrorMessages: The descriptions of the errors that have occurred
@rtype: None
----------
CanvasManager.renderedCanvas
This is emitted when a canvas has just been drawn.

@type  CanvasDrawn: L{Canvas}
@param CanvasDrawn: The canvas about to be drawn
@rtype: None
----------
CanvasManager.setPauseShaderCompiles
Toggles shader compilation on the canvas.

The canvas rendering uses a shader and it gets compiled on occasions. L{Shader} compilation can be expensive, so it is useful to pause shader compilation during long operation such as baking nodes, flattening layers or converting procedural to paintable. This function provides the ability to pause and unpause shader compilation on the canvas.

@type  Pause: bool
@param Pause: Flag to pause shader compilation.
@rtype: None
----------
CanvasManager.size
Returns the dimensions of every canvas, in pixels.

All canvases have the same dimensions, so the function L{Canvas.size()} will return the same value.

@rtype: list of  int
@return: The dimensions of every canvas, in pixels, in the format: (width, height)
----------
Channel
Channels are collections of layers that combine sets of image data to display using L{Shader} objects.

You can access channels through their parent L{GeoEntity} objects - for example: C{mari.geo.current().currentChannel()}

B{Example Code}

>>> # This example shows how to obtain the current channel of the current GeoEntity object
>>> import mari
>>> channel = mari.geo.current().currentChannel()
----------
Channel.bakeTo
Bakes the current channel into an existing layer.

@type  TargetLayer: L{Layer}
@param TargetLayer: The layer to bake the channel into.
@type  SelectedOnly: bool
@param SelectedOnly: Whether or not to bake the result into all patches or only the selected patches.
@rtype: bool
@return: True if successful.
@raise ValueError: The target layer provided was invalid, or not paintable.
----------
Channel.bleed
Returns True if the textures in this channel will bleed when baked.

TODO: Texture bleeding or necessary for most of Mari operations . However, shared paintable layers and individual patches may not respect this file space depending on how it been adjusted elsewhere.

@rtype: bool
@return: The texture bleed setting for this channel.
@see: L{setBleed()}
----------
Channel.channelNode
Returns the node graph node that corresponds to this L{Channel}.

@rtype: L{BakePointNode}
@return: the node graph node that corresponds to this L{Channel}
----------
Channel.colorSpace
Returns the preferred colorspace of paintable layers in this channel.

New paintable layers created in this channel will use this colorspace. However, shared paintable layers and individual patches may not respect this colorspace depending on how it been adjusted elsewhere.

@rtype: L{Image.ColorSpace}
@return: The preferred file space of paintable layers.
@deprecated: This concept has been replaced by the OCIO colorspace system so is no longer used. It will be removed in a future version. Please use L{colorspaceConfig()} instead.
@see: L{setColorSpace()}
----------
Channel.colorspaceConfig
Returns the colorspace configuration for color data of the channel.

New paintable layers created in this channel will use this colorspace configuration. However, shared paintable layers and individual patches may not respect this colorspace depending on how it's been adjusted elsewhere.

@rtype: L{ColorspaceConfig}
@return: The colorspace configuration for color data.
@see: L{setColorspaceConfig()}
----------
Channel.colorspaceConfigChanged
This is emitted after the colorspace config for color data is modified for the channel.

@type  Config: L{ColorspaceConfig}
@rtype: None
----------
Channel.convertColorSpaceTo
Converts this channel's data to a new colorspace.

@type  NewColorSpace: str
@param NewColorSpace: The colorspace to convert this channel to
@type  Option: L{ConvertOption}
@param Option: The option on which layers to convert
@rtype: None
----------
Channel.createSnapshot
Creates a new snapshot of the object.

@type  Name: str
@param Name: A descriptive name for this snapshot. There is no restriction on naming convention, so it is recommended to make this clear, such as "new test version".
@type  ID: str
@param ID: An optional identifier for this snapshot. This value can be used to group together sets of snapshots, as described in L{Snapshot.setID()}.
@rtype: L{Snapshot}
@return: The newly created snapshot.
@raise NotImplementedError: Raised if the function is called on a L{Ptex} channel.
----------
Channel.currentLayer
Returns the currently active layer on the channel.

@rtype: L{Layer}
@see: L{setCurrentLayer()}
----------
Channel.deleteSnapshot
Deletes the given snapshot.

@type  ShotToDelete: L{Snapshot}
@param ShotToDelete: The snapshot to delete
@rtype: None
@raise ValueError: The snapshot provided was invalid, or not owned by this object.
@raise NotImplementedError: Raised if the function is called on a L{Ptex} channel.
@warning: This method cannot be undone, so please use caution.
----------
Channel.depth
Returns the preferred depth of paintable layers.

New paintable layers created in this channel will use this depth. Resizing the channel will also use this depth to calculate relative resizing sizes. However, shared paintable layers and individual patches may not respect this depth depending on how it has been adjusted elsewhere.

@rtype: L{Image.Depth}
@return: The preferred height of paintable layers.
@see: L{setDepth()}
----------
Channel.fileSpace
Returns the preferred file space of paintable layers in this channel.

New paintable layers created in this channel will use this file space. However, shared paintable layers and individual patches may not respect this file space depending on how it been adjusted elsewhere.

@rtype: L{Image.FileSpace}
@return: The preferred file space of paintable layers.
@see: L{setFileSpace()}
----------
Channel.findSnapshotWithID
Returns the snapshot with the given identifier, if found.

If more than one snapshot with the given identifier exists, the first one will be returned.

@type  ID: str
@param ID: The shot identifier to search for
@rtype: L{Snapshot}
@return: The first snapshot with the given identifier, or None
@raise NotImplementedError: Raised if the function is called on a L{Ptex} channel.
----------
Channel.flatten
Merges all the layers in the channel into a single paintable layer and returns the layer.

@rtype: L{Layer}
@return: The resulting paintable layer into which all the layers are flattened into.
----------
Channel.geoEntity
Returns the L{GeoEntity} that this channel belongs to.

@rtype: L{GeoEntity}
@return: The L{GeoEntity} that this channel belongs to.
----------
Channel.height
Returns either the maximum height of all patches in this channel, or a single patch.

New paintable layers created in this channel will use this height. Resizing the channel will also use this height to calculate relative resizing sizes. However, shared paintable layers and individual patches may not respect this height depending on how they have been resized elsewhere.

@type  UVIndex: int
@param UVIndex: The UV index of the patch to return the height of, or -1 to return the maximum height of all patches.
@rtype: int
@return: The maximum height of all patches, or the height of a single patch.
@raise ValueError: Raised if an invalid UV index was specified.
@raise NotImplementedError: Raised if the function is called on a L{Ptex} channel.
----------
Channel.isLocked
Indicates whether this channel is locked, and if so, unmodifiable.

@rtype: bool
@return: True if this image is locked, or False if unlocked
@see: L{lock()}, L{unlock()}, L{setLocked()}
----------
Channel.isPtex
Returns True if this channel is L{Ptex} based.

@rtype: bool
----------
Channel.isShaderStack
Returns True if this is a ShaderStack.

@rtype: bool
----------
Channel.layerMadeCurrent
This is emitted when a layer from the channel is made current.

@type  pLayer: L{Layer}
@param pLayer: The current layer
@rtype: None
----------
Channel.lock
Locks the channel to prevent modifications.

@rtype: None
@see: L{isLocked()}, L{setLocked()}, L{unlock()}
----------
Channel.lockedChanged
This is emitted after the channel is locked or unlocked.

@type  Locked: bool
@param Locked: True if the channel is now locked, or False otherwise
@rtype: None
----------
Channel.makeCurrent
Sets this channel as the currently active channel on its L{GeoEntity}.

@rtype: None
----------
Channel.name
Returns the name of the channel.

@rtype: str
@return: The name of this channel.
@see: L{setName()}
----------
Channel.nameChanged
This is emitted after the channel has had its name changed.

@type  NewName: str
@param NewName: The new name.
@rtype: None
----------
Channel.resize
Resize a set of patches in the channel.

@type  NewSize: L{ImageSet.Size}
@param NewSize: The desired size for the patch.
@type  UVIndexList: list of  int
@param UVIndexList: Pass in a list of zero-based UV indices if desired to specify which patches to resize the images of. If not specified or empty, all patches will be resized. The UDIM for a patch is the zero-based UV index plus 1001.
@rtype: None
@raise ValueError: Raised if the size provided was invalid, or if an invalid UV index was specified.
@raise NotImplementedError: Raised if the function is called on a L{Ptex} channel.
----------
Channel.revertToSnapshot
Reverts the state of the object to that in the given snapshot.

@type  OldSnapshot: L{Snapshot}
@param OldSnapshot: A valid snapshot of this object
@rtype: None
@raise ValueError: The snapshot provided was invalid, or not owned by this object.
@raise NotImplementedError: Raised if the function is called on a L{Ptex} channel.
----------
Channel.scalarColorspaceConfig
Returns the colorspace configuration for scalar data of the channel.

New masks created in this channel will use this colorspace configuration. However, shared masks and individual patches may not respect this colorspace depending on how it's been adjusted elsewhere.

@rtype: L{ColorspaceConfig}
@return: The colorspace configuration for scalar data.
@see: L{setScalarColorspaceConfig()}
----------
Channel.scalarColorspaceConfigChanged
This is emitted after the colorspace config for scalar data is modified for the channel.

@type  Config: L{ColorspaceConfig}
@rtype: None
----------
Channel.setBleed
Sets the Texture L{Bleed} setting for this channel.

TODO: The file space set here will be propagated down to all non-shared paintable layers and their patches contained in this channel. The file space for Images (patches) may be altered by calling the appropriate functions on these objects.

@type  Bleed: bool
@param Bleed: The texture bleed setting for this channel.
@rtype: None
@see: L{bleed()}
----------
Channel.setColorSpace
Sets the colorspace of non-shared paintable layers in this channel.

The colorspace set here will be propagated down to all non-shared paintable layers and their patches contained in this channel. The colorspace for Images (patches) may be altered by calling the appropriate functions on these objects.

@type  ColorSpace: L{Image.ColorSpace}
@param ColorSpace: The colorspace to set non-shared layers to.
@rtype: None
@deprecated: This concept has been replaced by the OCIO colorspace system so is no longer used. It will be removed in a future version. Please use L{setColorspaceConfig()} instead.
@see: L{colorSpace()}
----------
Channel.setColorspaceConfig
Sets the colorspace configuration for color data of the channel.

The colorspace configuration set here will be propagated down to all non-shared paintable layers and their patches contained in the channel. The colorspace configuration for Images (patches) may be altered by calling the appropriate functions on these objects.

@type  Config: L{ColorspaceConfig}
@param Config: The colorspace configuration for color data.
@rtype: None
@raise ValueError: Raised if the colorspace configuration is invalid.
@see: L{colorspaceConfig()}
----------
Channel.setCurrentLayer
Sets the given layer as the currently active layer on the channel and selects it.

@type  NewCurrentLayer: L{Layer}
@param NewCurrentLayer: The layer that is to be made current.
@rtype: None
@raise ValueError: Raised if the layer is not in this channel.
@see: L{currentLayer()}
----------
Channel.setDepth
Sets the depth of this channel and converts internal layers' bit depths.

@type  Depth: L{Image.Depth}
@param Depth: The bit depth to convert this channel to
@type  Option: L{ConvertOption}
@param Option: The option on which layers to convert bit depth of
@rtype: None
@see: L{depth()}
----------
Channel.setFileSpace
Sets the file space of non-shared paintable layers in this channel.

The file space set here will be propagated down to all non-shared paintable layers and their patches contained in this channel. The file space for Images (patches) may be altered by calling the appropriate functions on these objects.

@type  FileSpace: L{Image.FileSpace}
@param FileSpace: The file space to set non-shared layers to.
@rtype: None
@see: L{fileSpace()}
----------
Channel.setLocked
Locks or unlocks the channel, to optionally prevent modifications.

@type  Locked: bool
@rtype: None
@see: L{isLocked()}, L{lock()}, L{unlock()}
----------
Channel.setName
Sets the name of the channel.

@type  NewName: str
@param NewName: The new name for the channel.
@rtype: None
@see: L{name()}
----------
Channel.setScalarColorspaceConfig
Sets the colorspace configuration for scalar data of the channel.

The colorspace configuration set here will be propagated down to all non-shared masks and their patches contained in the channel. The colorspace configuration for Images (patches) may be altered by calling the appropriate functions on these objects.

@type  Config: L{ColorspaceConfig}
@param Config: The colorspace configuration for scalar data.
@rtype: None
@raise ValueError: Raised if the colorspace configuration is invalid.
@see: L{scalarColorspaceConfig()}
----------
Channel.snapshotAdded
This is emitted after a snapshot is created for this object.

@type  NewSnapshot: L{Snapshot}
@rtype: None
----------
Channel.snapshotList
Returns a list of the snapshots available on the object.

@rtype: list of  L{Snapshot}
@return: A list of the available snapshots
@raise NotImplementedError: Raised if the function is called on a L{Ptex} channel.
----------
Channel.snapshotRemoved
This is emitted after a snapshot is deleted for this object.

@type  OldSnapshot: L{Snapshot}
@rtype: None
----------
Channel.unlock
Unlocks the channel and allows modifications.

@rtype: None
@see: L{isLocked()}, L{lock()}, L{setLocked()}
----------
Channel.width
Returns either the maximum width of all patches in this channel, or a single patch.

New paintable layers created in this channel will use this width. Resizing the channel will also use this width to calculate relative resizing sizes. However, shared paintable layers and individual patches may not respect this width depending on how they have been resized elsewhere.

@type  UVIndex: int
@param UVIndex: The UV index of the patch to return the width of, or -1 to return the maximum width of all patches.
@rtype: int
@return: The maximum width of all patches, or the width of a single patch.
@raise ValueError: Raised if an invalid UV index was specified.
@raise NotImplementedError: Raised if the function is called on a L{Ptex} channel.
----------
ChannelInfo
Provides information about a channel to create or import.
----------
ChannelInfo.__init__
Constructor for L{ChannelInfo}.

This class contains the information for creating a new channel. Note that this API is not complete, as not all options are fully supported yet.

@type  rName: str
@param rName: Name of the channel. A value exception is raised if this is empty.
@type  Width: int
@param Width: The width of the channel's textures in pixels. The default is 4K (4096).
@type  Height: int
@param Height: The height of the channel's textures in pixels. The default is 4K (4096).
@type  BitDepth: L{Image.Depth}
@param BitDepth: The bit depth of the channel's textures: mari.Image.DEPTH_BYTE (8, the default), mari.Image.DEPTH_HALF (16) or mari.Image.DEPTH_FLOAT (32).
@type  Scalar: bool
@param Scalar: True if the channel should be scalar, or False (the default) for color.
@type  pFillColor: L{Color}
@param pFillColor: Specifies a color to fill the channel's texture with on creation. If invalid, it uses a default gray.
@type  FileSpace: L{Image.FileSpace}
@param FileSpace: The file space the channel will import and export data as: mari.Image.FILESPACE_NORMAL, mari.Image.VECTOR or mari.Image.FILESPACE_VECTOR_Y_FLIP.
@type  ColorspaceSettings: L{ColorspaceConfig}
@param ColorspaceSettings: The colorspace settings for color data of the channel.
@type  ScalarColorspaceSettings: L{ColorspaceConfig}
@param ScalarColorspaceSettings: The colorspace settings for scalar data of the channel.
@rtype: L{ChannelInfo}
@raise ValueError: Raised if the channel name was empty, or the requested dimensions are not supported.
@raise ValueError: Raised if invalid colorspace configurations were supplied.
@deprecated: The Scalar parameter is no longer used, and will be removed in a future version.
@see: L{mari.Image.Depth}, L{mari.Image.FileSpace}
----------
ChannelInfo.colorspaceConfig
Returns the colorspace configuration for color data of the channel.

@rtype: L{ColorspaceConfig}
@return: The colorspace configuration.
@see: L{setColorspaceConfig()}
----------
ChannelInfo.depth
Returns the bit depth of the channel.

@rtype: L{Image.Depth}
@see: L{setDepth()}
----------
ChannelInfo.fileSpace
Returns the name of the file space the channel will import and export data as.

@rtype: L{Image.FileSpace}
@see: L{setFileSpace()}
----------
ChannelInfo.fileTemplate
Returns the template used to generate the file name.

@rtype: str
@return: The template for the file name. See L{setFileTemplate()} for details of the supported replaceable tokens.
@see: L{setFileTemplate()}
----------
ChannelInfo.fillColor
Returns the color that the channel will be filled with on creation.

@rtype: L{Color}
@see: L{setFillColor()}
----------
ChannelInfo.height
Returns the height of the channel's textures.

Textures in channels must always be square, so this will be the same as the width.

@rtype: int
@see: L{width()}, L{setSize()}, L{setWidth()}, L{size()}, L{setHeight()}
----------
ChannelInfo.isScalar
Returns True if the channel is scalar, or False if it is color.

@rtype: bool
@deprecated: This concept has been replaced by the OCIO colorspace system so is no longer used. It will be removed in a future version.
----------
ChannelInfo.name
Returns the name of the channel.

@rtype: str
@see: L{setName()}
----------
ChannelInfo.path
Returns the base path for the channel's textures.

@rtype: str
@see: L{setPath()}
----------
ChannelInfo.scalarColorspaceConfig
Returns the colorspace configuration for scalar data of the channel.

New masks created in this channel will use this colorspace configuration. However, shared masks and individual patches may not respect this colorspace depending on how it's been adjusted elsewhere.

@rtype: L{ColorspaceConfig}
@return: The colorspace configuration for scalar data.
@see: L{setScalarColorspaceConfig()}
----------
ChannelInfo.setColorspaceConfig
Sets the colorspace configuration for color data of the channel.

@type  Config: L{ColorspaceConfig}
@param Config: The colorspace configuration.
@rtype: None
@raise ValueError: Raised if the colorspace configuration is invalid.
@see: L{colorspaceConfig()}
----------
ChannelInfo.setDepth
Sets the bit depth of the channel.

@type  NewDepth: L{Image.Depth}
@rtype: None
@see: L{depth()}
----------
ChannelInfo.setFileSpace
Set the name of the file space the channel will import and export data as.

@type  FileSpace: L{Image.FileSpace}
@rtype: None
@see: L{fileSpace()}
----------
ChannelInfo.setFileTemplate
Sets the template used to generate the file name.

File templates are used to create the file names for each individual patch to load for the channel. The file names are copied from the template, with the following supported tokens replaced with their appropriate values: 
  - $PATH - The base path for the textures, as returned by the L{path()} function
  - $ENTITY - The name of the geometry object (or entity) that the images are being imported into
  - $CHANNEL - The name of the channel in the geometry object (or entity)
  - $LAYER - The name of the individual layer in the channel
  - $IMAGESET - The UUID of the channel in the layer
  - $UDIM - A special number indicating the index of the patch in the channel
  - $NUMBER - The number of the patch within the batch, starting from zero
  - $INDEX - Same as $NUMBER
  - $COUNT - The number of patches in the channel
See L{GeoPatch.udim()} for a description of UDIM values.

@type  rTemplate: str
@param rTemplate: The template string to use for the patch file names
@rtype: None
@see: L{fileTemplate()}, L{mari.examples.create_blacksmith_project.createBlacksmithProject()}
----------
ChannelInfo.setFillColor
Sets the color that the channel will be filled with on creation.

@type  pCol: L{Color}
@rtype: None
@see: L{fillColor()}
----------
ChannelInfo.setHeight
Sets the height (and width) of the channel's textures.

@type  Height: int
@rtype: None
@raise ValueError: Raised if the new dimensions of the channel (after setting both the width and height) are invalid.
@note: Textures in channels must always be square, so this will set the width as well as the height.
@see: L{width()}, L{setWidth()}, L{height()}, L{setSize()}, L{size()}
----------
ChannelInfo.setName
Sets the name of the channel.

@type  rName: str
@rtype: None
@see: L{name()}
----------
ChannelInfo.setPath
Sets the base path for the channel's textures.

@type  rPath: str
@rtype: None
@see: L{path()}
----------
ChannelInfo.setScalar
Sets the channel to be scalar (True) or color (False).

@type  Scalar: bool
@rtype: None
@deprecated: This concept has been replaced by the OCIO colorspace system so is no longer used. It will be removed in a future version.
----------
ChannelInfo.setScalarColorspaceConfig
Sets the colorspace configuration for scalar data of the channel.

The colorspace configuration set here will be propagated down to all non-shared masks and their patches contained in the channel. The colorspace configuration for Images (patches) may be altered by calling the appropriate functions on these objects.

@type  Config: L{ColorspaceConfig}
@param Config: The colorspace configuration for scalar data.
@rtype: None
@raise ValueError: Raised if the colorspace configuration is invalid.
@see: L{scalarColorspaceConfig()}
----------
ChannelInfo.setShader
Sets the shader category of the channel.

@type  rShader: str
@param rShader: The shader that this channel should be plugged into.
@rtype: None
@see: L{shader()}
----------
ChannelInfo.setSize
Sets the width and height of the channel, which must be the same.

@type  WidthAndHeight: int
@param WidthAndHeight: The width and height of the channel, which must be the same
@rtype: None
@raise ValueError: Raised if the new dimensions of the channel are invalid.
@see: L{width()}, L{setWidth()}, L{height()}, L{setHeight()}, L{size()}
----------
ChannelInfo.setWidth
Sets the width (and height) of the channel's textures.

@type  Width: int
@rtype: None
@raise ValueError: Raised if the new dimensions of the channel (after setting both the width and height) are invalid.
@note: Textures in channels must always be square, so this will set the height as well as the width.
@see: L{width()}, L{setSize()}, L{height()}, L{setHeight()}, L{size()}
----------
ChannelInfo.shader
Returns the shader category of the channel.

@rtype: str
@see: L{setShader()}
----------
ChannelInfo.size
Returns the width and height of the channel, which must be the same.

@rtype: int
@return: The width and height of the channel, which must be the same
@see: L{width()}, L{setSize()}, L{setWidth()}, L{height()}, L{setHeight()}
----------
ChannelInfo.width
Returns the width of the channel's textures.

Textures in channels must always be square, so this will be the same as the height.

@rtype: int
@see: L{setSize()}, L{setWidth()}, L{height()}, L{setHeight()}, L{size()}
----------
ChannelLayer
L{Channel} layers add the image output of a L{Channel} into another stack as a layer.

You can access all types of layers from their containing L{Channel} objects - for example: C{channel.layerList()}

You can check for L{ChannelLayer} objects by calling L{Layer.isChannelLayer()}:

B{Example Code}

>>> #This example finds channel layers in the current channel
>>> import mari
>>> channel_layers = []
>>> channel = mari.geo.current().currentChannel()
>>> for layer in channel.layerList():
...     if layer.isChannelLayer():
...         channel_layers.append(layer)
----------
ChannelLayer.channel
Returns the channel that the layer uses for its data.

@rtype: L{Channel}
@return: The channel that the layer uses for its data
----------
ChannelSnapshot
A copy of the state of a channel at a particular time.

By creating snapshots, users can easily preserve the state of an object and return to that state at some later time.

For example, this could be used to preserve the history of a design, or to try new ideas without risking the current textures. The user could snapshot the current state, paint some modifications, ask for approval, and if the changes are not accepted, quickly and easily revert to the previous state.

B{Example Code}

>>> # This example shows how to obtain the current channel of the current GeoEntity object
>>> import mari
>>> channel = mari.geo.current().currentChannel()
>>> channel_snapshot = channel.createSnapshot("Test Snapshot")
----------
ChannelSnapshot.extract
Extracts the snapshot into a new channel.

@type  NewChannelName: str
@param NewChannelName: The name to give the new channel. This must be unique on the L{GeoEntity}.
@rtype: None
@raise ValueError: Raised if the channel name was empty or not unique for the object.
----------
Clock
Controls for Mari's internal animation clock.

Using this class the user can control playback of animation in Mari. Various things can be animated in Mari, including geometry, cameras, and textures. The frame range may be set to any required values, and animated scene elements will clamp their animation to the frames they have available. The clock can be run forwards or backwards at different frame rates. The behavior for when the end of the frame range is reached can also be customized, so playback can stop, loop, or bounce. 
B{Example Code}

>>> # This example obtains the current animation frame
>>> import mari
>>> current_frame = mari.clock.frame()
----------
Clock.frame
Returns the current frame number.

@rtype: int
@return: The current frame number
@see: L{setFrame()}
----------
Clock.frameChanged
This is emitted when the frame number changes.

@type  Frame: int
@param Frame: The new frame number
@rtype: None
----------
Clock.frameCount
Returns the number of frames in the current frame range.

@rtype: int
@return: The number of frames in the current frame range
----------
Clock.frameRate
Returns the animation playback frame rate, in FPS.

@rtype: int
@return: The current frame rate, in frames per second.
@see: L{setFrameRate()}
----------
Clock.frameRateChanged
This is emitted when the frame rate changes.

@type  NewFps: int
@param NewFps: The new frame rate, in frames per second.
@rtype: None
----------
Clock.loopCount
Returns the number of animation loops that have been completed.

When in bounce playback mode, playing all frames forwards and then all in reverse counts as one loop.

@rtype: int
@return: The number of animation loops that have been completed.
@see: L{BOUNCE}
----------
Clock.play
Starts animation playback.

@type  Direction: L{PlayDirection}
@param Direction: Indicates whether to play forwards (the default) or backwards
@rtype: None
----------
Clock.playing
Indicates whether animation playback is active.

@rtype: bool
@return: True if the clock is currently playing
----------
Clock.playingChanged
This is emitted when animation starts or stops.

@type  IsPlaying: bool
@param IsPlaying: True when playing, or False when stopped
@rtype: None
----------
Clock.rangeChanged
This is emitted when the frame range changes.

@type  Start: int
@param Start: The start frame of the new range
@type  End: int
@param End: The end frame of the new range
@rtype: None
----------
Clock.repeatType
Indicates how the clock handles reaching the end of the frame range during playback.

@rtype: L{RepeatType}
@return: The current repeating behavior
@see: L{setRepeatType()}
----------
Clock.reset
Resets all the internal clock values to sensible defaults.

@rtype: None
----------
Clock.rewind
Rewinds to the first frame.

@rtype: None
----------
Clock.setFrame
Sets the current frame.

@type  Frame: int
@param Frame: The new frame number
@rtype: None
@see: L{frame()}
----------
Clock.setFrameRange
Sets the animation frame range.

Animation will run between the start and end of the range.

@type  Start: int
@param Start: The start frame of the new range
@type  End: int
@param End: The end frame of the new range
@rtype: None
----------
Clock.setFrameRate
Sets the animation playback frame rate, in FPS.

@type  fps: int
@param fps: The new frame rate, in frames per second.
@rtype: None
@see: L{frameRate()}
----------
Clock.setRepeatType
Sets how the clock should handle reaching the end of the frame range during playback.

@type  Type: L{RepeatType}
@param Type: The new repeating behavior
@rtype: None
@see: L{repeatType()}
----------
Clock.setSourceFrameRate
Sets the frame rate of the source material, in FPS.

@type  Fps: int
@param Fps: The frame rate, in frames per second, that the material in the current project should be played at. For film this is generally 24 FPS.
@rtype: None
@see: L{sourceFrameRate()}
----------
Clock.sourceFrameRate
Returns the frame rate of the source material, in FPS.

@rtype: int
@return: The frame rate, in frames per second, that material in the current project is played at
@see: L{setSourceFrameRate()}
----------
Clock.startFrame
Returns the start frame.

@rtype: int
@return: The starting frame of the current frame range
----------
Clock.stepBack
Steps back to the frame before the current one.

@rtype: None
----------
Clock.stepForward
Steps forward to the frame after the current one.

@rtype: None
----------
Clock.stop
Stops animation playback.

@rtype: None
----------
Clock.stopFrame
Returns the end frame.

@rtype: int
@return: The end frame of the current frame range
----------
Clock.time
Returns the animation playback time in HH:MM:SS:MS format.

@rtype: str
@return: A string representation of the current animation playback time. When at the first frame, this will be "00:00:00:00".
----------
Color
Objects of this class hold information about an individual color value.

All channels are specified in the range [0, 1] - so passing in a value of 1 will set the channel to 100% intensity.

RGB and HSV/L values are updated automatically. For example, if you set the color from RGB values, you can immediately retrieve the HSV equivalents of those if desired.

B{Example Code}

>>> # This example constructs a Color object and sets the foreground color with it
>>> import mari
>>> foreground_color = mari.Color(1,1,0,1)
>>> mari.colors.setForeground(foreground_color)

>>> # This example obtains the current foreground color
>>> import mari
>>> foreground_color = mari.colors.foreground()
>>> print foreground_color.toString()
(1,1,0,1)
----------
Color.__init__
Sets to the color specified by the given components.

All color components are optional. This provides the convenience of being able to specify only R, G, and B components to default to opaque (100% alpha), or not provide any parameters to create a default color of opaque black.

@type  Red: float
@type  Green: float
@type  Blue: float
@type  Alpha: float
@rtype: L{Color}
----------
Color.a
Returns the alpha component.

@rtype: float
@see: L{setA()}
----------
Color.b
Returns the blue component.

@rtype: float
@see: L{setB()}
----------
Color.exposure
Returns the exposure value of the color.

@rtype: float
----------
Color.g
Returns the green component.

@rtype: float
@see: L{setG()}
----------
Color.h
Returns the hue component.

@rtype: float
@see: L{setH()}
----------
Color.hsl
Returns the color as a list of hue, saturation, and lightness components.

@rtype: list of  float
----------
Color.hsla
Returns the color as a list of hue, saturation, lightness, and alpha components.

@rtype: list of  float
----------
Color.hsv
Returns the color as a list of hue, saturation, and value components.

@rtype: list of  float
----------
Color.hsva
Returns the color as a list of hue, saturation, value, and alpha components.

@rtype: list of  float
----------
Color.l
Returns the lightness component.

@rtype: float
@see: L{setL()}
----------
Color.lum
Returns the luminance value of the color.

@rtype: float
----------
Color.r
Returns the red component.

@rtype: float
@see: L{setR()}
----------
Color.rgb
Returns the color as a list of red, green, and blue components.

@rtype: list of  float
----------
Color.rgba
Returns the color as a list of red, green, blue, and alpha components.

@rtype: list of  float
----------
Color.s
Returns the saturation component.

@rtype: float
@see: L{setS()}
----------
Color.setA
Sets the alpha component.

@type  Alpha: float
@rtype: None
@see: L{a()}
----------
Color.setB
Sets the blue component.

@type  Blue: float
@rtype: None
@see: L{b()}
----------
Color.setG
Sets the green component.

@type  Green: float
@rtype: None
@see: L{g()}
----------
Color.setH
Sets the hue component.

@type  Hue: float
@rtype: None
@see: L{h()}
----------
Color.setHSL
Sets the color using hue, saturation, and lightness components.

@type  Hue: float
@type  Saturation: float
@type  Lightness: float
@rtype: None
----------
Color.setHSLA
Sets the color using hue, saturation, lightness, and alpha components.

@type  Hue: float
@type  Saturation: float
@type  Lightness: float
@type  Alpha: float
@rtype: None
----------
Color.setHSV
Sets the color using hue, saturation, and value components.

@type  Hue: float
@type  Saturation: float
@type  Value: float
@rtype: None
----------
Color.setHSVA
Sets the color using hue, saturation, value, and alpha components.

@type  Hue: float
@type  Saturation: float
@type  Value: float
@type  Alpha: float
@rtype: None
----------
Color.setL
Sets the lightness component.

@type  Lightness: float
@rtype: None
@see: L{l()}
----------
Color.setR
Sets the red component.

@type  Red: float
@rtype: None
@see: L{r()}
----------
Color.setRGB
Sets the color using red, green, and blue components.

@type  Red: float
@type  Green: float
@type  Blue: float
@rtype: None
----------
Color.setRGBA
Sets the color using red, green, blue, and alpha components.

@type  Red: float
@type  Green: float
@type  Blue: float
@type  Alpha: float
@rtype: None
----------
Color.setS
Sets the saturation component.

@type  Saturation: float
@rtype: None
@see: L{s()}
----------
Color.setV
Sets the value component.

@type  Value: float
@rtype: None
@see: L{v()}
----------
Color.toString
Returns a string representation of the color.

For example, opaque black will be displayed as "(0,0,0,1)".

@rtype: str
----------
Color.userReadable
Returns a user-readable description of the color.

This will be a three line string showing the RGB, HSV, and alpha components.

@rtype: str
----------
Color.v
Returns the value component.

@rtype: float
@see: L{setV()}
----------
Colors
Provides access to various color-related functionality.

This includes setting and retrieving the foreground and background colors.

B{Example Code}

>>> # This example constructs a Color object and sets the foreground color with it
>>> import mari
>>> foreground_color = mari.Color(1,1,0,1)
>>> mari.colors.setForeground(foreground_color)

>>> # This example obtains the current foreground color
>>> import mari
>>> foreground_color = mari.colors.foreground()
>>> print foreground_color.toString()
(1,1,0,1)
----------
Colors.background
Returns the current background color.

@rtype: L{Color}
@return: The currently selected background color
@see: L{setBackground()}
----------
Colors.backgroundChanged
This is emitted when the background color is changed.

@rtype: None
----------
Colors.foreground
Returns the current foreground color.

@rtype: L{Color}
@return: The currently selected foreground color
@see: L{setForeground()}
----------
Colors.foregroundChanged
This is emitted when the foreground color is changed.

@rtype: None
----------
Colors.pick
Displays the Mari color picking widget, and returns the color picked.

@type  InitialColor: L{Color}
@param InitialColor: The initial color to display in the picker widget
@rtype: L{Color}
@raise RuntimeError: Raised if the user cancelled the color selection.
----------
Colors.setBackground
Sets a new background color.

@type  NewColor: L{Color}
@param NewColor: The new background color
@rtype: None
@see: L{background()}
----------
Colors.setForeground
Sets a new foreground color.

@type  NewColor: L{Color}
@param NewColor: The new foreground color
@rtype: None
@see: L{foreground()}
----------
ColorspaceConfig.__init__
Creates a new colorspace config.

@type  FileName: str
@type  ColorSpaces: list of str
@type  AutomaticTypes: list of  L{ColorspaceType}
@type  Raw: bool
@type  Scalar: bool
@rtype: L{ColorspaceConfig}
@raise ValueError: Raised if an invalid number of colorspaces or automatic types is given.
----------
ColorspaceConfig.automaticColorspace
Returns the automatic colorspace or role for a particular stage.

@type  Stage: L{ColorspaceStage}
@param Stage: The stage in the pipeline where a colorspace or role can be defined.
@rtype: str
@return: The automatic colorspace or role of the pipeline stage.
@raise IndexError: Raised if the stage index is out of range.
@see: L{setAutomaticColorspace()}
----------
ColorspaceConfig.automaticType
Returns the automatic data type for either the native and output stages.

@type  Stage: L{ColorspaceStage}
@param Stage: The stage in which a data type can be defined.
@rtype: L{ColorspaceType}
@return: The automatic data type of the pipeline stage.
@raise IndexError: Raised if the stage index is neither the native or output stage.
@see: L{setAutomaticType()}
----------
ColorspaceConfig.availableColorspaces
Returns a list of all the available colorspaces and roles present in the OCIO config file for a particular stage.

If COLORSPACE_STAGE_COUNT is passed in for L{Stage} then only the colorspaces and roles defined in the OCIO config file will be checked and none of the extras for the stages such as 'Automatic'.

@type  Stage: L{ColorspaceStage}
@param Stage: The stage in the pipeline where a colorspace or role can be defined.
@rtype: list of str
@return: The list of colorspaces and roles within the OCIO config file for a particular stage.
@raise IndexError: Raised if the stage index is out of range.
----------
ColorspaceConfig.colorspace
Returns the colorspace or role for a particular stage.

This may not actually be a colorspace or role within the OCIO config file. Please use 'resolveColorSpace' to get the actual colorspace name.

@type  Stage: L{ColorspaceStage}
@param Stage: The stage in the pipeline where a colorspace or role can be defined.
@rtype: str
@return: The colorspace or role of the pipeline stage.
@raise IndexError: Raised if the stage index is out of range.
@see: L{setColorspace()}
----------
ColorspaceConfig.defaultColorspace
Returns the default colorspace or role for a particular stage.

@type  Stage: L{ColorspaceStage}
@param Stage: The stage in the pipeline where a colorspace or role can be defined.
@rtype: str
@return: The default colorspace or role of the pipeline stage.
@raise IndexError: Raised if the stage index is out of range.
----------
ColorspaceConfig.fileName
Returns the OCIO config file.

This may not actually be a name or path of a OCIO config file. Please use 'resolveFileName' to get the actual name or path.

@rtype: str
@see: L{setFileName()}
----------
ColorspaceConfig.isColorspaceValid
Returns True if the given colorspace or role is present in the OCIO config file and is valid for a particular stage.

If COLORSPACE_STAGE_COUNT is passed in for L{Stage} then only the colorspaces and roles defined in the OCIO config file will be checked and none of the extras for the stages such as 'Automatic'.

@type  Colorspace: str
@param Colorspace: The colorspace or role to look for.
@type  Stage: L{ColorspaceStage}
@param Stage: The stage in the pipeline where a colorspace or role can be defined.
@type  Strict: bool
@param Strict: When set the automatic colorspaces are parsed to determine whether they can be resolved to an actual colorspace within the OCIO config file.
@rtype: bool
@return: True if the colorspace or role is present in the OCIO config file and is valid for the stage, False otherwise.
@raise IndexError: Raised if the stage index is out of range.
----------
ColorspaceConfig.isFileCustom
Returns True if the OCIO config file is not one of the standard ones packaged with Mari.

@rtype: bool
----------
ColorspaceConfig.isFileValid
Returns True if the OCIO config file is valid.

@rtype: bool
----------
ColorspaceConfig.isValid
Returns True if the OCIO config file and corresponding colorspace stages are valid.

@rtype: bool
----------
ColorspaceConfig.raw
Returns whether the configuration is enabled and to be used to convert data between colorspaces.

@rtype: bool
@return: True if the configuration is enabled.
@see: L{setRaw()}
----------
ColorspaceConfig.reset
Sets both the OCIO config file and each of the colorspace stages to their default.

@rtype: None
----------
ColorspaceConfig.resolveColorspace
Returns the colorspace found within the OCIO config file for a particular stage.

@type  Stage: L{ColorspaceStage}
@param Stage: The stage in the pipeline where a colorspace or role can be defined.
@rtype: str
@return: The colorspace of the pipeline stage.
@raise IndexError: Raised if the stage index is out of range.
----------
ColorspaceConfig.resolveFileName
Returns the name or path of the OCIO config file.

@rtype: str
----------
ColorspaceConfig.resolveRaw
Returns whether the configuration should be used to convert between color-spaces.

This takes into consideration, not only the internal flag, the global default raw option and whether the L{OpenColorIO} is valid.

@rtype: bool
----------
ColorspaceConfig.scalar
Returns whether the configuration is targeting masks, heights, normals, depths, and other non-color images.

@rtype: bool
@return: True if the configuration is targeting non-color data.
@see: L{setScalar()}
----------
ColorspaceConfig.setAutomaticColorspace
Sets the automatic colorspace or role for a particular stage.

@type  Stage: L{ColorspaceStage}
@param Stage: The stage in the pipeline where a colorspace or role can be defined.
@type  Colorspace: str
@param Colorspace: The automatic colorspace or role of the pipeline stage.
@rtype: None
@raise IndexError: Raised if the stage index is out of range.
@raise ValueError: Raised if an invalid colorspaces, for the OCIO config file, is given.
@see: L{automaticColorspace()}
----------
ColorspaceConfig.setAutomaticType
Sets the automatic data type for either the native and output stages.

@type  Stage: L{ColorspaceStage}
@param Stage: The stage in which a data type can be defined.
@type  Type: L{ColorspaceType}
@param Type: The automatic data type of the pipeline stage.
@rtype: None
@raise IndexError: Raised if the stage index is neither the native or output stage.
@see: L{automaticType()}
----------
ColorspaceConfig.setColorspace
Sets the colorspace or role for a particular stage.

@type  Stage: L{ColorspaceStage}
@param Stage: The stage in the pipeline where a colorspace or role can be defined.
@type  Colorspace: str
@param Colorspace: The new colorspace or role of the stage in the pipeline.
@rtype: None
@raise IndexError: Raised if the stage index is out of range.
@raise ValueError: Raised if an invalid colorspaces, for the OCIO config file, is given.
@see: L{colorspace()}
----------
ColorspaceConfig.setFileName
Sets the OCIO config file.

This causes the stages to be validated and updated to sensible defaults if they aren't within the new OCIO config file.

@type  FileName: str
@param FileName: Either the name of a standard OCIO config file packaged with Mari or a path to a custom one.
@rtype: None
@see: L{fileName()}
----------
ColorspaceConfig.setRaw
Sets whether the configuration is enabled and to be used to convert data between colorspaces.

@type  Enable: bool
@param Enable: Whether the configuration is enabled.
@rtype: None
@see: L{raw()}
----------
ColorspaceConfig.setScalar
Sets whether the configuration is targeting masks, heights, normals, depths, and other non-color images.

@type  Enable: bool
@param Enable: Whether the configuration is targeting non-color data.
@rtype: None
@see: L{scalar()}
----------
ColorspaceConfig.toString
Returns a string representation of the color space.

@rtype: str
@return: Colorspace data.
----------
ColorspaceDefaults.__init__
Creates a new colorspace config.

@type  FileName: str
@type  ColorSpaces: list of str
@type  ColorManagementEnabled: bool
@rtype: L{ColorspaceDefaults}
@raise ValueError: Raised if an invalid number of colorspaces is given.
----------
ColorspaceDefaults.availableColorspaces
Returns a list of all the available colorspaces present in the OCIO config file for a particular target.

@rtype: list of str
@return: The list of colorspaces within the OCIO config file for a particular target.
----------
ColorspaceDefaults.colorManagementEnabled
Returns True if color management is enabled on the project.

@rtype: bool
@see: L{setColorManagementEnabled()}
----------
ColorspaceDefaults.colorspace
Returns the colorspace or role for a particular target.

@type  Target: L{ColorspaceTarget}
@param Target: The target in the pipeline where a colorspace or role can be defined.
@rtype: str
@return: The colorspace or role of the target data type or device.
@raise IndexError: Raised if the target index is out of range.
@see: L{setColorspace()}
----------
ColorspaceDefaults.defaultColorspace
Returns the default colorspace or role for a particular target.

@type  Target: L{ColorspaceTarget}
@param Target: The target data type or device for which a colorspace can be defined.
@rtype: str
@return: The default colorspace or role of the target data type or device.
@raise IndexError: Raised if the target index is out of range.
----------
ColorspaceDefaults.fileName
Returns the OCIO config file.

@rtype: str
@see: L{setFileName()}
----------
ColorspaceDefaults.hasColorspace
Returns True if the given colorspace is present in the OCIO config file.

@type  Colorspace: str
@param Colorspace: The colorspace or role to look for.
@rtype: bool
@return: True if the colorspace is present in the configuration file, False otherwise.
----------
ColorspaceDefaults.isFileCustom
Returns True if the OCIO config file is not one of the standard ones packaged with Mari.

@rtype: bool
----------
ColorspaceDefaults.isFileValid
Returns True if the OCIO config file is valid.

@rtype: bool
----------
ColorspaceDefaults.isValid
Returns True if the OCIO config file and corresponding colorspace targets are valid.

@rtype: bool
----------
ColorspaceDefaults.reset
Sets both the OCIO config file and each of the colorspace targets to their default.

@rtype: None
----------
ColorspaceDefaults.setColorManagementEnabled
Sets whether color management is enabled on the project.

@type  Enable: bool
@param Enable: Whether color management is enabled.
@rtype: None
@see: L{colorManagementEnabled()}
----------
ColorspaceDefaults.setColorspace
Sets the colorspace for a particular target.

@type  Target: L{ColorspaceTarget}
@param Target: The target data type or device for which a colorspace can be defined.
@type  Colorspace: str
@param Colorspace: The new colorspace of the target data type or device.
@rtype: None
@raise IndexError: Raised if the target index is out of range.
@raise ValueError: Raised if an invalid colorspaces, for the OCIO config file, is given.
@see: L{colorspace()}
----------
ColorspaceDefaults.setFileName
Sets the OCIO config file.

This causes the targets to be validated and updated to sensible defaults if they aren't within the new OCIO config file.

@type  FileName: str
@param FileName: Either the name of a standard OCIO config file packaged with Mari or a path to a custom one.
@rtype: None
@see: L{fileName()}
----------
CustomLUTFilter
A post processing filter that applies a LUT from custom provided color values.

L{CustomLUTFilter} objects can be created by calling L{PostFilterCollection.createCustomLUT()}.

B{Example Code}

>>> # This examples creates a new CustomLUTFilter object through GLRender and PostFilterCollection
>>> import mari
>>> filter_collection = mari.gl_render.createPostFilterCollection("New Filter Collection")
>>> file_lut = filter_collection.createCustomLUT("New Custom LUT")
>>> mari.gl_render.deletePostFilterCollection(filter_collection)
----------
CustomLUTFilter.setData
Sets the complete color data for the LUT.

@type  Data: list of  L{Color}
@param Data: A list of all 1024 color entries that make up the LUT.
@rtype: None
----------
DDI
This class gives access to some of the functionality of Mari's Dynamic Data Interface.

The Dynamic Data Interface, or L{DDI}, is the low level data handling system in Mari. This system manages the caches on disk and in memory.

The functionality provided can be used to test Mari's performance on different systems.

A good test of raw performance is to set the cache size to 1 GB (but remember to change this back!) and then run a profile test for 4 or 5 GB. This ensures that all of the memory created during the test is saved and loaded. You should use a new, empty project for this sort of testing. 

B{Example Code}

>>> import mari
>>> mari.ddi.garbageCollect()
----------
DDI.clearMemoryCache
Releases RAM by uncaching currently cached data blocks.

After calling this method, the number of data blocks reported by liveBlocks should be significantly reduced.

@rtype: None
----------
DDI.dataBlocks
Returns the total number of data blocks managed by Mari.

Mari manages data as individual blocks. This method returns the number of blocks that Mari currently knows about in the current project. Each block may be of any size, and may be reused multiple times.

@rtype: qint64
@return: The number of individual blocks that Mari knows about in the current project
----------
DDI.garbageCollect
Performs a full garbage collection on the cache directory.

Mari records all of your brush strokes to the L{DDI} as you are painting. When you exit the application, or remove those undo records, the data on disk is no longer needed. These garbage files are removed by Mari automatically.

If you want to optimize your cache (just before archiving, for example) you can use this method. It should be used in conjunction with the L{History.clear()} method. This will ensure that only valid data remains in the cache.

@rtype: None
@note: This may take a while to execute, depending on the size of the cache.
----------
DDI.liveBlocks
Returns the number of blocks that are loaded into system RAM.

This can be smaller than the total number of blocks.

@rtype: qint64
@return: The number of blocks that are live - i.e. loaded into system RAM
----------
DDI.liveBytes
Returns the number of bytes currently loaded into system RAM.

The number of bytes currently loaded into system RAM

@rtype: qint64
----------
DDI.memoryCacheSize
Returns the size of the memory cache.

@rtype: qint64
@return: The size in bytes of the memory cache
@see: L{setMemoryCacheSize}
----------
DDI.profile
Runs performance tests on the L{DDI}.

This can help to track down problems on systems showing poor performance. This method will create a number of blocks of a given size. These blocks will be filled with random data to ensure they are unique, registered with the L{DDI}, and then freed. The time taken for this in milliseconds will be returned. If the operation detects any problems they will be reported into the Mari Log.

@type  NumberOfBlocks: int
@param NumberOfBlocks: The number of blocks to register while profiling
@type  BlockSize: unsigned int
@param BlockSize: The maximum size of block to create while profiling, in bytes
@type  RandomSize: bool
@param RandomSize: If set to True, each block will be of a random size between 1 and L{BlockSize} bytes; otherwise all blocks will be exactly L{BlockSize} bytes.
@rtype: int
@return: The time in milliseconds that the test took to run
----------
DDI.setMemoryCacheSize
Sets the amount of system memory used by the L{DDI} for caching.

Mari maintains an area of system memory that it uses to cache data blocks. Blocks are loaded from disk into this cache, and then removed in a least-recently-used scheme. i.e. if blocks are used, they are kept around, but if a block is not used for a while and some memory needs to be freed, it will be cleared to make room for a new block.

This method controls the size of this cache. It does not need to be too big, as Mari is very efficient at managing this data. It is a good idea to limit this so other programs on your system have memory to work with.

@type  Size: qint64
@param Size: The number of bytes Mari should use for memory caching
@rtype: None
@warning: If set to a large value, Mari will use all of the RAM on your system, and you will see degraded performance.
@see: L{memoryCacheSize()}
----------
EnvironmentLight
An object for creating lighting effects on a 3D mesh.

You can access lights through the L{LightManager} - for example: C{mari.lights.list()}
----------
EnvironmentLight.canvasBlur
Return the blur for this environment light canvas display.

@rtype: float
@return: The blur value
@see: L{setCanvasBlur()}
----------
EnvironmentLight.canvasBlurChanged
Emitted when canvasBlur changes.

@type  Blur: float
@param Blur: The new value
@rtype: None
----------
EnvironmentLight.canvasDisplay
Return the enabled state for this environment light canvas display.

@rtype: bool
@return: The enabled state value
@see: L{setCanvasDisplay()}
----------
EnvironmentLight.canvasDisplayChanged
Emitted when canvasDisplay changes.

@type  Display: bool
@param Display: The new value
@rtype: None
----------
EnvironmentLight.clearCubeImageCache
Clear out the internally cached cubeImage data.

@rtype: None
----------
EnvironmentLight.clearLightCache
Clear out the internally cached environment data.

@rtype: None
----------
EnvironmentLight.cubeImage
Returns the image manager image used to produce the environment light.

Some image types cannot be stored in the image manager (i.e. DDS cubemaps). These types of files will return None as there is no image manager entry for them. In these cases use L{cubeImageFilename()} instead

@rtype: L{Image}
@return: The image manager image
@see: L{cubeImageFilename()}, L{setCubeImage()}
----------
EnvironmentLight.cubeImageFilename
Returns the filename of the image used as to produce the environment light.

@rtype: str
@return: The filename of the image
----------
EnvironmentLight.cubeImageFilenameChanged
Emitted when cubeImageFilename changes.

@type  Filename: str
@param Filename: The new value
@rtype: None
----------
EnvironmentLight.cubeImageResolution
Returns the cube image resolution.

This resolution is used for all X, Y and Z sides of the cubemap.

@rtype: int
@return: The image up resolution
@see: L{setCubeImageResolution()}
----------
EnvironmentLight.cubeImageResolutionChanged
Emitted when cubeImageResolution changes.

@type  Resolution: int
@param Resolution: The new value
@rtype: None
----------
EnvironmentLight.cubeImageType
Returns the present method used to convert the image into a cubemap.

@rtype: L{CubeImageType}
@return: The cube image conversion type
@see: L{setCubeImageType()}
----------
EnvironmentLight.cubeImageTypeChanged
Emitted when cubeImageType changes.

@type  Type: int
@param Type: The new value
@rtype: None
----------
EnvironmentLight.cubeImageUpAxis
Returns the image axis that is treated as 'up'.

@rtype: L{ImageUpAxis}
@return: The image up axis
@see: L{setCubeImageUpAxis()}
----------
EnvironmentLight.cubeImageUpAxisChanged
Emitted when cubeImageUpAxis changes.

@type  Axis: int
@param Axis: The new value
@rtype: None
----------
EnvironmentLight.fixedTo
Returns the type of object that the light is fixed to.

Lights can be fixed to either the world or the camera. This allows lights to follow the view, ensuring models are illuminated at all times.

@rtype: L{FixedTo}
@return: L{Light.SCENE} if the light is fixed to the scene, or L{Light.CAMERA} if fixed to the camera.
@see: L{setFixedTo()}
----------
EnvironmentLight.fixedToChanged
Emitted when fixedTo changes.

@type  Type: int
@param Type: The new value
@rtype: None
----------
EnvironmentLight.intensity
Return the intensity value for this environment light.

@rtype: float
@return: The intensity value
@see: L{setIntensity()}
----------
EnvironmentLight.intensityChanged
Emitted when intensity changes.

@type  Intensity: float
@param Intensity: The new value
@rtype: None
----------
EnvironmentLight.printLightCacheKeys
Print out the internal environment light cache keys return Cache keys.

@rtype: list of str
----------
EnvironmentLight.rotationUp
Return the rotation angle for this environment light.

@rtype: float
@return: The rotation angle
@see: L{setRotationUp()}
----------
EnvironmentLight.rotationUpChanged
Emitted when rotationUp changes.

@type  Rotation: float
@param Rotation: The new value
@rtype: None
----------
EnvironmentLight.rotationUpMode
Return the rotation mode for this environment light.

@rtype: L{RotationMode}
@return: The rotation mode
@see: L{setRotationUpMode()}
----------
EnvironmentLight.rotationUpModeChanged
Emitted when rotationUpMode changes.

@type  Mode: int
@param Mode: The new value
@rtype: None
----------
EnvironmentLight.rotationUpSpeed
Return the rotation speed for this environment light.

@rtype: float
@return: The rotation speed, in rotations per second
@see: L{setRotationUpSpeed()}
----------
EnvironmentLight.rotationUpSpeedChanged
Emitted when rotationUpSpeed changes.

@type  Speed: float
@param Speed: The new value
@rtype: None
----------
EnvironmentLight.setCanvasBlur
Set the blur for the environment light canvas dislay.

@type  Blur: float
@param Blur: The new blur for the environment light canvas display
@rtype: None
@see: L{canvasBlur()}
----------
EnvironmentLight.setCanvasDisplay
Set the enable for the environment light canvas dislay.

@type  Display: bool
@param Display: The enable state for the environment light canvas display
@rtype: None
@see: L{canvasDisplay()}
----------
EnvironmentLight.setCubeImage
Sets the image and how to convert it to a cubemap.

@type  rImage: variant
@param rImage: Value to set image as. Can be a L{Image} or a string file path
@type  Type: L{CubeImageType}
@param Type: How to convert the image into the cubemap image. Use TYPE_GUESS to allow auto detection to be used
@rtype: None
@raise ValueError: Raised if the rImage is empty, of an unsupported type or contains an invalid entry.
@see: L{cubeImage()}
----------
EnvironmentLight.setCubeImageResolution
Sets the cube image resolution.

@type  Resolution: int
@param Resolution: The cube image size used for all X, Y and Z sides of the cubemap.
@rtype: None
@raise ValueError: Raise if resolution is invalid
@see: L{cubeImageResolution()}
----------
EnvironmentLight.setCubeImageType
Sets the image conversion type.

@type  Type: L{CubeImageType}
@param Type: How to convert the image into the cubemap image. This metyhod cannot accept the TYPE_GUESS value, use L{setCubeImage()}
@rtype: None
@raise ValueError: Raised if the TYPE_GUESS value is used.
@see: L{setCubeImage()}, L{cubeImageType()}
----------
EnvironmentLight.setCubeImageUpAxis
Sets the image axis that is treated as 'up'.

@type  Axis: L{ImageUpAxis}
@param Axis: The image axis to treat up
@rtype: None
@raise ValueError: Raise if the axis is invalid
@see: L{cubeImageUpAxis()}
----------
EnvironmentLight.setFixedTo
Sets the type of object that the light should be fixed to.

@type  TargetType: L{FixedTo}
@param TargetType: L{Light.SCENE} if the light is to be fixed to the scene, or L{Light.CAMERA} if fixed to the camera.
@rtype: None
@see: L{fixedTo()}
----------
EnvironmentLight.setIntensity
Set the intensity for the environment light.

@type  Intensity: float
@param Intensity: The new L{Intensity} for the environment light
@rtype: None
@see: L{intensity()}
----------
EnvironmentLight.setRotationUp
Set the rotation about the up direction for the environment light.

@type  Angle: float
@param Angle: The new angle for the environment light rotation, in degrees
@rtype: None
@see: L{rotationUp()}
----------
EnvironmentLight.setRotationUpMode
Set the rotation mode for the environment light.

@type  Mode: L{RotationMode}
@param Mode: The new rotation mode for the environment light
@rtype: None
@see: L{rotationUpMode()}
----------
EnvironmentLight.setRotationUpSpeed
Set the rotation speed about the up direction for the environment light.

@type  Speed: float
@param Speed: The new speed for the environment light rotation, in rotations per second
@rtype: None
@see: L{rotationUpSpeed()}
----------
Event
Provides a method for sending events to the system.

B{Example Code}

>>> #This example sends "B" key to the canvas, which bakes the paint by default
>>> import mari
>>> import PySide
>>> mari.event.sendKeyEvent(mari.event.KEY_PRESS,PySide.QtCore.Qt.Key_B,0,False)
----------
Event.isPlaying
Returns whether or not any events are currently queued for playback.

@rtype: bool
@return: True one or more events are in the event queue.
----------
Event.playbackComplete
This is emitted after the event queue has finished playing any events it had queued.

@rtype: None
----------
Event.recordPlay
Playback all the events currently recorded.

@rtype: None
----------
Event.recordStart
Called to begin recording of the events sent to the receiver.

@type  Space: L{EventCoordinateSpace}
@param Space: The coordinate space to use for any mouse and/or tablet events.
@type  Normalized: bool
@param Normalized: Whether recorded positions should be specified in normalised device coordinates(0.0 - 1.0) or pixels.
@rtype: None
----------
Event.recordStop
Called to end recording triggered by a previous call to 'recordStart'.

@rtype: None
----------
Event.recordString
Returns the commands required to playback the events currently recorded.

@rtype: str
@return: The playback commands.
----------
Event.sendKeyEvent
Triggers a key event directly in the receiver.

@type  Type: L{EventType}
@param Type: The type of key event to trigger.
@type  Key: int
@param Key: The key code that triggers the event.
@type  Modifiers: int
@param Modifiers: The keyboard modifier flags that existed immediately before the event occurred.
@type  AutoRepeat: bool
@param AutoRepeat: True if this event comes from an auto-repeating key; False if it comes from an initial key press.
@type  Msecs: int
@param Msecs: How many milliseconds to wait before sending the event.
@rtype: None
----------
Event.sendMouseEvent
Triggers a mouse event directly in the receiver.

@type  Type: L{EventType}
@param Type: The type of mouse event to trigger.
@type  Pos: QPointF
@param Pos: The mouse cursor's position relative to the receiver.
@type  Button: L{MouseButton}
@param Button: The button that triggers the event.
@type  Buttons: int
@param Buttons: Returns the button state when the event was generated. The button state is a combination of 'MouseButton' values.
@type  Modifiers: int
@param Modifiers: The keyboard modifier flags that existed immediately before the event occurred.
@type  Space: L{EventCoordinateSpace}
@param Space: The coordinate space of the given position 'Pos'.
@type  Normalized: bool
@param Normalized: Whether the given position 'Pos' is specified in normalized device coordinates(0.0 - 1.0) or pixels.
@type  Msecs: int
@param Msecs: How many milliseconds to wait before sending the event.
@rtype: None
----------
Event.sendTabletEvent
Triggers a tablet event directly in the receiver.

@type  Type: L{EventType}
@param Type: The type of tablet event to trigger.
@type  Pos: QPointF
@param Pos: The mouse cursor's position relative to the receiver.
@type  Pressure: qreal
@param Pressure: The pressure for the device. 0.0 indicates that the stylus is not on the tablet, 1.0 indicates the maximum amount of pressure for the stylus.
@type  Modifiers: int
@param Modifiers: The keyboard modifier flags that existed immediately before the event occurred.
@type  Space: L{EventCoordinateSpace}
@param Space: The coordinate space of the given position 'Pos'.
@type  Normalized: bool
@param Normalized: Whether the given position 'Pos' is specified in normalised device coordinates(0.0 - 1.0) or pixels.
@type  Msecs: int
@param Msecs: How many milliseconds to wait before sending the event.
@rtype: None
----------
ExportItem
Represents the data model of export item.

B{Example Code}

>>> # Get Current GeoEntity
>>> geo = mari.geo.current()
>>> # Get a Channel from the GeoEntity
>>> channel = geo.channelList()[0]
>>> # Create an ExportItem for the Channel and configure its source and target
>>> eItem = mari.ExportItem()
>>> eItem.setSourceNodeName(channel.name())
>>> eItem.setFileTemplate("$CHANNEL.$UDIM.tif")
>>> # Add ExportItem to ExportManager
>>> mari.exports.addExportItem(eItem, mari.current.geo())
>>> # Export the ExportItem with a resolution override
>>> mari.exports.exportTextures([eItem], "/tmp", Overrides = {"RESOLUTION": "512 x 512"})
----------
ExportItem.colorspace
Returns the colorspace to which exported textures are converted.

@rtype: str
@return: The colorspace to convert the textures to
@see: L{setColorspace()}
----------
ExportItem.depth
Returns the depth in which textures are exported.

@rtype: str
@return: The texture depth for export
@see: L{setDepth()}
----------
ExportItem.deserializeFromString
Populate this L{ExportItem} from the L{XMLString} representing an L{ExportItem}.

@type  XMLString: str
@param XMLString: The L{XMLString} representing an L{ExportItem}
@rtype: None
----------
ExportItem.errorStringList
Returns the error string of L{ExportItem}.

If this L{ExportItem} has errors such as depth and file format mismatch. This function returns the string describing the error.

@rtype: list of str
@return: The error string of L{ExportItem}
@see: L{setErrorStringList()}
----------
ExportItem.exportEnabled
Returns whether this L{ExportItem} is enabled for export.

@rtype: bool
@return: Whether this L{ExportItem} is enabled for export
@see: L{setExportEnabled()}
----------
ExportItem.fileOptions
Returns the image file options of textures to be exported.

@rtype: variant
@return: The image file options of textures to be exported
@see: L{setFileOptions()}
----------
ExportItem.fileOptionsString
Returns the string representation of image file options.

@rtype: str
@return: The string representation of image file options.
----------
ExportItem.fileTemplate
Returns the file template of textures to be exported.

@rtype: str
@return: The file template of textures to be exported
@see: L{setFileTemplate()}
----------
ExportItem.geoEntity
Returns the L{GeoEntity} this L{ExportItem} is associated with.

@rtype: L{GeoEntity}
@see: L{setGeoEntity()}
----------
ExportItem.postProcessCommand
Returns the post process command to run after the export.

@rtype: str
@return: The post process command to run after the export
@see: L{setPostProcessCommand()}
----------
ExportItem.resolution
Returns the resolution at which textures are exported.

@rtype: str
@return: The texture resolution for export
@see: L{setResolution()}
----------
ExportItem.resolveExportFilePaths
Processes the L{fileTemplate()} and returns the list of file paths with tokens replaced.

@type  RootPath: str
@param RootPath: Optional root path to prepend to the file template
@rtype: list of str
@return: The list of file paths the L{fileTemplate()} is resolved to
----------
ExportItem.resolveFileTemplate
Replaces $ tokens in the fileTemplate and returns the resulting file path.

@rtype: str
@return: The file path after replacing $ tokens in the fileTemplate
----------
ExportItem.serializeToString
Serializes this L{ExportItem} as an XMLString.

@rtype: str
@return: The XMLString representing this L{ExportItem}
----------
ExportItem.setColorspace
Sets the colorspace to which exported textures are converted.

@type  Colorspace: str
@param Colorspace: The colorspace to convert the textures to
@rtype: None
@see: L{colorspace()}
----------
ExportItem.setDepth
Sets the depth in which textures are exported.

@type  Depth: str
@param Depth: The texture depth for export
@rtype: None
@see: L{depth()}
----------
ExportItem.setErrorStringList
Sets the error string of L{ExportItem}.

If this L{ExportItem} has errors such as depth and file format mismatch. Set the error string via this function.

@type  ErrorStringList: list of str
@param ErrorStringList: The error string of L{ExportItem}
@rtype: None
@see: L{errorStringList()}
----------
ExportItem.setExportEnabled
Sets whether this L{ExportItem} is enabled for export.

@type  ExportEnabled: bool
@param ExportEnabled: boolean to specify whether this L{ExportItem} is enabled for export.
@rtype: None
@see: L{exportEnabled()}
----------
ExportItem.setFileOptions
Sets the image file options of textures to be exported.

@type  FileOptions: variant
@param FileOptions: The image file options of textures to be exported
@rtype: None
@see: L{fileOptions()}
----------
ExportItem.setFileTemplate
Sets the file template of textures to be exported.

@type  FileTemplate: str
@param FileTemplate: The file template of textures to be exported
@rtype: None
@see: L{fileTemplate()}
----------
ExportItem.setGeoEntity
Sets the L{GeoEntity} this L{ExportItem} is associated with.

@type  Entity: L{GeoEntity}
@param Entity: the L{GeoEntity} objrect this L{ExportItem} is associated with
@rtype: None
@see: L{geoEntity()}
----------
ExportItem.setPostProcessCommand
Sets the post process command to run after the export.

@type  PostProcessCommand: str
@param PostProcessCommand: The post process command to run after the export
@rtype: None
@see: L{postProcessCommand()}
----------
ExportItem.setResolution
Sets the resolution at which textures are exported.

@type  Resolution: str
@param Resolution: The texture resolution for export
@rtype: None
@see: L{resolution()}
----------
ExportItem.setSourceNode
Sets the source node at which textures are flattened and exported from.

@type  SourceNode: L{Node}
@param SourceNode: the source node at which textures are flattened and exported from
@rtype: None
@see: L{sourceNode()}
----------
ExportItem.setUvIndexList
Set UV Index list to export.

@type  UVIndexList: list of  int
@param UVIndexList: UV Index list to export
@rtype: None
@see: L{uvIndexList()}
----------
ExportItem.setWarningStringList
Sets the warning string of L{ExportItem}.

If this L{ExportItem} has warnings such as files to be overwritten. Set the warning string via this function.

@type  WarningStringList: list of str
@param WarningStringList: The warning string of L{ExportItem}
@rtype: None
@see: L{warningStringList()}
----------
ExportItem.sourceColorspace
Returns the colorspace of the source node.

@rtype: str
@return: The colorspace of the source node
----------
ExportItem.sourceDepth
Returns the depth of the source node.

@rtype: L{Image.Depth}
@return: The depth of the source node in number of bits
----------
ExportItem.sourceDepthAsInternalFormat
Returns the depth of the source node in OpenGL integer format.

@rtype: int
@return: The depth of the source node in OpenGL integer format
----------
ExportItem.sourceNode
Returns the source node at which textures are flattened and exported from.

@rtype: L{Node}
@return: The source node at which textures are flattened and exported from
@see: L{setSourceNode()}
----------
ExportItem.sourceNodeName
Returns the name of source node at which textures are flattened and exported from.

@rtype: str
@return: The name of source node at which textures are flattened and exported from
----------
ExportItem.sourceResolution
Returns the resolution of the source node.

@rtype: str
@return: The resolution of the source node
----------
ExportItem.uvIndexList
Return UV Index list to export.

@rtype: list of  int
@return: UV Index list to export
@see: L{setUvIndexList()}
----------
ExportItem.warningStringList
Returns the warning string of L{ExportItem}.

If this L{ExportItem} has warnings such as files to be overwritten. this function returns the string describing the warning.

@rtype: list of str
@return: The warning string of L{ExportItem}
@see: L{setWarningStringList()}
----------
ExportManager
Manages export functionality of Mari.

B{Example Code}

>>> # Get Current GeoEntity
>>> geo = mari.geo.current()
>>> # Get a Channel from the GeoEntity
>>> channel = geo.channelList()[0]
>>> # Create an ExportItem for the Channel and configure its source and target
>>> eItem = mari.ExportItem()
>>> eItem.setSourceNodeName(channel.name())
>>> eItem.setFileTemplate("$CHANNEL.$UDIM.tif")
>>> # Add ExportItem to ExportManager
>>> mari.exports.addExportItem(eItem, mari.current.geo())
>>> # Export the ExportItem with a resolution override
>>> mari.exports.exportTextures([eItem], "/tmp", Overrides = {"RESOLUTION": "512 x 512"})
----------
ExportManager.addExportItem
Adds L{ExportItem} associated with the given L{GeoEntity}.

@type  Item: L{ExportItem}
@param Item: The L{ExportItem} to add to the L{Entity}
@type  Entity: L{GeoEntity}
@param Entity: The parent L{GeoEntity} to add the L{ExportItem} to
@rtype: None
----------
ExportManager.colorspaceList
Returns the list of supported texture colorspace for export.

Use this function to obtain the list of supported texture colorspace. "Original" indicates the original colorspace specified in the original channel or node.

@rtype: list of str
@return: The list of supported texture colorspace for export
----------
ExportManager.depthList
Returns the list of supported texture depth for export.

Use this function to obtain the list of supported texture depth. "Original" indicates the original depth specified in the original channel or node.

@rtype: list of str
@return: The list of supported texture depth for export
----------
ExportManager.exportItemList
Returns the list of L{ExportItem} for the given L{GeoEntity}.

@type  Entity: L{GeoEntity}
@param Entity: The L{GeoEntity} the list of L{ExportItem} is returned for
@rtype: list of  L{ExportItem}
@return: the list of L{ExportItem} for the given L{GeoEntity}
----------
ExportManager.exportTextures
Export textures with the settings from given L{ExportItem} applied.

>>> #This example globally overrides the patch list to export using an integer list in UV_INDICES overrides
>>> eItems = []
>>> for geo in mari.geo.list():
...   eItem = mari.ExportItem()
...   for node in geo.nodeGraph().nodeList():
...     if node.nodeName()=="diffuse":
...       eItem.setSourceNode(node)
...   eItem.setFileTemplate("$ENTITY/$CHANNEL.$UDIM.tif")
...   mari.exports.addExportItem(eItem, geo)
...   eItems.append(eItem)
>>>
>>> mari.exports.exportTextures(
...   eItems,
...   "/tmp",
...   L{Overrides}={"UV_INDICES": [0, 1, 2, 5]} # Export UDIMs 1001-1003 & 1006 of all GeoEntities
... )

>>> geo1, geo2 = mari.geo.list() # Assigns two GeoEntity instances to variables
>>> eItems = []
>>> for geo in (geo1,geo2):
...   eItem = mari.ExportItem()
...   for node in geo.nodeGraph().nodeList():
...     if node.nodeName()=="diffuse":
...       eItem.setSourceNode(node)
...   eItem.setFileTemplate("$ENTITY/$CHANNEL.$UDIM.tif")
...   mari.exports.addExportItem(eItem, geo)
...   eItems.append(eItem)
>>>
>>> mari.exports.exportTextures(
...   eItems,
...   "/tmp",
...   L{Overrides}={"UV_INDICES": {geo1.uuid():[0], geo2.uuid():[5]}} # Export UDIM 1001 from Geo1 and 1006 from Geo2
... )

@type  ExportItems: list of  L{ExportItem}
@type  ExportRootPath: str
@type  Overrides: variant
@rtype: str
@return: Returns the error message encountered during export
----------
ExportManager.imageFileExtensionList
Returns the list of supported image file extensions for export.

Use this function to obtain the list of supported image file extensions. "Original" indicates the original file format specified in the original channel or node.

@rtype: list of str
@return: The list of supported image file extensions for export
----------
ExportManager.imageFileOptions
Returns the dictionary of image file options for the given file extension.

Use this function to obtain the result of

@type  Extension: str
@param Extension: File extension to query the image file options for
@rtype: variant
@return: the dictionary for the file type specific options
----------
ExportManager.imageFileOptionsWidget
Returns the widget to select the file type specific options.

@type  Extension: str
@param Extension: File extension to show the image file options for
@rtype: QWidget
@return: the widget for selecting the file type specific options
----------
ExportManager.itemExported
Emitted upon completion of exporting textures for the L{ExportItem}.

@type  Item: L{ExportItem}
@param Item: L{ExportItem} object that has been exported
@rtype: None
----------
ExportManager.postProcessCommandList
Returns the list of post process commands for export.

Use this function to obtain the list of post process commands.

@rtype: list of str
@return: The list of post process commands
----------
ExportManager.registerPostProcessCommand
Registers a post process command to be listed by L{postProcessCommandList()}.

The post process command is run per image after exporting an image. $EXPORTED token within the command will be replaced by the file path of the exported image.

@type  Command: str
@param Command: The post process command to be run after exporting an image. $EXPORTED token will be replaced by the file path for each exported image.
@rtype: None
----------
ExportManager.removeExportItem
Removes the given L{ExportItem}.

@type  Item: L{ExportItem}
@param Item: The L{ExportItem} to remove
@rtype: None
----------
ExportManager.resolutionList
Returns the list of supported texture resolutions for export.

Use this function to obtain the list of supported texture resolutions. "Original" indicates the original resolution specified in the original channel or node.

@rtype: list of str
@return: The list of supported texture resolutions for export
----------
FaceSelectionGroup
A specialised selection group that consists of faces.
----------
FileLUTFilter
A post processing filter that reads a 1D LUT from a file.

L{FileLUTFilter} objects can be created by calling L{PostFilterCollection.createFileLUT()}.

B{Example Code}

>>> # This examples creates a new FileLUTFilter object through GLRender and PostFilterCollection
>>> import mari
>>> filter_collection = mari.gl_render.createPostFilterCollection("New Filter Collection")
>>> file_lut = filter_collection.createFileLUT("New File LUT")
>>> mari.gl_render.deletePostFilterCollection(filter_collection)
----------
FileLUTFilter.filePath
Returns the file path of the LUT.

@rtype: str
@return: The current file path to read the LUT from.
@see: L{setFilePath()}
----------
FileLUTFilter.setFilePath
Sets the file path of the LUT.

@type  FilePath: str
@param FilePath: The new file path to read the LUT from.
@rtype: None
@see: L{filePath()}
----------
FileList
Stores a list of files and directories that can be used for custom attributes.

B{Example Code}

>>> # This example creates a FileList object with a sample file path
>>> import mari
>>> file_list = mari.FileList(mari.FileList.TYPE_SINGLE_FILE)
>>> file_list.append("/tmp/Hello.txt")
----------
FileList.__init__
Creates a new file list.

@type  Value: variant
@param Value: This can either be a L{FileList.Type} or another L{FileList}.
@rtype: L{FileList}
----------
FileList.acceptNonExisting
Returns True if the file list accepts non-existent files.

@rtype: bool
@return: Whether the file list accepts non-existent files
@see: L{setAcceptNonExisting()}
----------
FileList.append
Inserts a file at the end of the list.

@type  File: str
@param File: The file to append
@rtype: None
----------
FileList.at
Returns the file at the given index in the list.

@type  Index: int
@param Index: The index of the file to return
@rtype: str
@return: The file at the given index
----------
FileList.clear
Removes all files from the list.

@rtype: None
----------
FileList.contains
Returns True if the list contains an occurrence of the file, otherwise returns False.

@type  File: str
@param File: The file to search for
@rtype: bool
@return: Whether the list contains an occurrence of the given file
----------
FileList.count
Returns the number of files in the list.

@rtype: int
@return: The number of files in the list
----------
FileList.defaultDirectory
Returns the default directory.

@rtype: str
@return: The default directory
@see: L{setDefaultDirectory()}
----------
FileList.filter
Returns the filter used in selecting files.

@rtype: str
@return: The file filter
@see: L{setFilter()}
----------
FileList.insert
Inserts the file at the given index in the list.

If index is 0, the value is prepended to the list. If index is the size of the list, the file is appended to the list.

@type  Index: int
@param Index: The position to insert the file at
@type  File: str
@param File: The file to insert
@rtype: None
----------
FileList.isEmpty
Returns True if the list contains no files, otherwise returns False.

@rtype: bool
@return: Whether the list contains no files
----------
FileList.pathKey
Returns the path key used by the widgets and dialogs for default path saving.

@rtype: str
@return: The path key used for default path saving
@see: L{setPathKey()}
----------
FileList.pickedFile
Returns the currently picked file.

@rtype: str
@return: The currently picked file
@see: L{setPickedFile()}
----------
FileList.removeAt
Removes the file at the given index.

@type  Index: int
@param Index: The index of the file to remove
@rtype: None
----------
FileList.setAcceptNonExisting
Sets whether the file list should accept non-existent files.

@type  AcceptNonExisting: bool
@param AcceptNonExisting: Whether the file list accepts non-existent files
@rtype: None
@see: L{acceptNonExisting()}
----------
FileList.setDefaultDirectory
Sets the default directory to open to (only if this is of type directory).

@type  DefaultDirectory: str
@param DefaultDirectory: The default directory to open to
@rtype: None
@see: L{defaultDirectory()}
----------
FileList.setFilter
Sets the filter used in selecting files.

@type  Filter: str
@param Filter: The file filter
@rtype: None
@see: L{filter()}
----------
FileList.setPathKey
Sets the path key used by widgets and dialogs for default path saving.

@type  PathKey: str
@param PathKey: The path key used for default path saving
@rtype: None
@see: L{pathKey()}
----------
FileList.setPickedFile
Sets the currently chosen file.

@type  PickedFile: str
@param PickedFile: The currently picked file
@rtype: None
@see: L{pickedFile()}
----------
FileList.setType
Sets the type of the file list.

@type  T: L{Type}
@param T: The type to set the file list to
@rtype: None
@see: L{type()}
----------
FileList.type
Returns the type of the file list.

@rtype: L{Type}
@return: The type of the file list
@see: L{setType()}
----------
FloatSlider
A floating-point slider widget.

Provides a custom single-precision floating-point slider widget.

B{Example Code}

>>> # This example creates a new FloatSlider object, add it to a QWidget and show it
>>> import mari
>>> import PySide
>>> float_slider = mari.FloatSlider()
>>> container = PySide.QtGui.QWidget()
>>> container.setLayout(PySide.QtGui.QHBoxLayout())
>>> float_slider.addToLayout(container.layout())
>>> container.show()
----------
FloatSlider.__init__
Sets to the float slider specified by the given components.

@type  Parent: QWidget
@rtype: L{FloatSlider}
----------
FloatSlider.setValue
Sets the value of the slider.

@type  Value: float
@param Value: The value to set the slider to.
@rtype: None
@see: L{value()}
----------
FloatSlider.value
Returns the value of the slider.

@rtype: float
@return: The value of the slider.
@see: L{setValue()}
----------
FloatSlider.valueChanged
This is emitted when the value of the slider changes.

@type  Value: float
@param Value: The value the slider has changed to.
@rtype: None
----------
GLRender
Manages Mari's OpenGL Renderer and associated objects.

Mari uses OpenGL to render in 3D. This object gives access to this renderer, allowing configuration of available shaders and other settings.

L{Shader} modules can be applied using the appropriate methods on L{GeoEntity} objects. 

B{Example Code}

>>> # This example checks if color manager is applied
>>> import mari
>>> is_color_manager_ppplied = mari.gl_render.isPostProcessingEnabled()
----------
GLRender.applyFilter
Applies a filter to current layer.

@type  Filter: L{PostFilter}
@param Filter: The filter to apply
@rtype: bool
@return: True if filter successfully applied
----------
GLRender.clearError
Makes a single call to OpenGL's 'glGetError()' and outputs the result to the log if an error is detected.

@rtype: None
----------
GLRender.createPostFilterCollection
Creates a new post process filter collection.

The creates a new post process filter stack with given name, and sets it as current.

@type  Name: str
@param Name: The name for the new post process filter collection.
@rtype: L{PostFilterCollection}
@raise ValueError: Raised if a collection with the given name already exists.
@see: L{findPostFilterCollection()}, L{deletePostFilterCollection()}, L{currentPostFilterCollection()}, L{setPostFilterCollection()}
----------
GLRender.createQuickApplyGLSL
Creates a new GLSL post processing filter that can be applied to the viewport.

Mari supports post-render processing effects. These can be used to color-correct, blur, filter or warp the viewport display to achieve different effects.

Filters are implemented as two snippets of GLSL shader code: 
  - The L{DefinitionsSnippet} defines uniforms and functions required for the filter
  - The L{BodySnippet} contains the implementation of the filter itself
As multiple instances of a filter can be created, we need to give each instance a unique ID. To do this, all uniforms and function names in the shader should have a _$ID_ appended to their names. Mari takes this token internally and adds a unique ID. This preventing name collisions in shaders. For example, a definitions snippet that looks like:

C{uniform float ScaleX_$ID_;}

C{uniform float ScaleY_$ID_;}

will be translated internally into:

C{uniform float ScaleX1;}

C{uniform float ScaleY2;}

Body snippets should be protected with braces, and can expect the color value of the pixel being processed to be available in a vec4 called "Out".

If you wanted to simply multiply the viewport display pixels by a floating point value, for example, you could write something like:

C{definition_snippet = "uniform float ScaleValue_$ID_;"}

C{body_snippet = "{ Out.rgb *= ScaleValue_$ID_; }"}

The values passed into the shader can be controlled by modifying a metadata value on the L{PostFilter} object. The metadata value should have the same name and type as the uniform, but should not include the _$ID_. In the scaling example above, we could add some metadata to the filter called ScaleValue, and this would then be passed into the shader automatically.

@type  Name: str
@param Name: The name for the new filter
@type  DefinitionsSnippet: str
@param DefinitionsSnippet: A snippet of GLSL code that defines the uniforms and functions used by this post process filter
@type  BodySnippet: str
@param BodySnippet: A snippet of GLSL code that defines the body of the post process filter
@type  IconPath: str
@param IconPath: Path of the icon used to represent the filter with
@type  DisplayMetadata: bool
@param DisplayMetadata: If set to True the dialog will expose the metadata set on the filter allowing users to manipulate it
@rtype: L{GLSLFilter}
@return: A new post process filter object
@raise ValueError: Raised if a filter of the given name already exists.
----------
GLRender.currentPostFilterCollection
Returns the currently active post process filter collection.

These post process filters are executed in order.

@rtype: L{PostFilterCollection}
@see: L{createPostFilterCollection()}, L{findPostFilterCollection()}, L{deletePostFilterCollection()}, L{setPostFilterCollection()}, L{setCurrentPostFilterCollection()}
----------
GLRender.currentPostFilterCollectionModified
This is emitted whenever the settings of any filter in the current post filter collection is changed.

@rtype: None
----------
GLRender.deletePostFilterCollection
Deletes a post process filter collection.

@type  Collection: L{PostFilterCollection}
@param Collection: The post filter collection to delete.
@rtype: None
@see: L{createPostFilterCollection()}, L{findPostFilterCollection()}, L{currentPostFilterCollection()}, L{setPostFilterCollection()}
----------
GLRender.findFilter
Finds a filter.

@type  Name: str
@param Name: The name of filter required
@rtype: L{PostFilter}
@return: None if filter not found
----------
GLRender.findPostFilterCollection
Returns the post process filter collection of given name.

These post process filters are executed in order.

@type  Name: str
@param Name: The name for the post process filter collection to find.
@rtype: L{PostFilterCollection}
@return: The post process filter collection with the given name, or None if no matching collection exists
@see: L{createPostFilterCollection()}, L{deletePostFilterCollection()}, L{currentPostFilterCollection()}, L{setPostFilterCollection()}
----------
GLRender.findQuickApplyFilter
Returns the first occurrence of a filter with the given name.

@type  Name: str
@param Name: The name of filter to find
@rtype: L{PostFilter}
@return: A filter with the given name, or None if not found
----------
GLRender.isCurrentGLShaderProgramValid
Returns whether the current GL shader program is compiled and linked fine.

Returns whether the current GL shader program is compiled and linked fine. If the current shader is built in the background, it will wait for the completion.

@rtype: bool
----------
GLRender.isPostProcessingEnabled
Indicates whether post processing color management is applied to the viewport.

@rtype: bool
@return: True if post processing is enabled, or False if not
----------
GLRender.lutEnabled
Indicates whether a display LUT is being applied to the viewport.

@rtype: bool
@return: True if the display-time LUT is enabled, or False otherwise
@deprecated: Please use L{isPostProcessingEnabled()} instead.
@see: L{setLutEnabled()}
----------
GLRender.platformInformation
Returns key/value pairs of OpenGL information obtained from the main OpenGL context

This can be due to system issues or running in terminal mode.

@rtype: variant
----------
GLRender.postFilterCollectionAdded
This is emitted when a new post processing filter collection is added.

@type  Collection: L{PostFilterCollection}
@param Collection: The newly added post filter collection
@rtype: None
----------
GLRender.postFilterCollectionNames
Returns the names of all the post filter collections.

@rtype: list of str
@return: The names of all the post filter collections
----------
GLRender.postFilterCollectionRemoved
This is emitted when a post processing filter collection is removed.

@type  Name: str
@param Name: The name of the post filter collection that was removed
@rtype: None
----------
GLRender.postFilterCollections
Returns all the post filter collections.

@rtype: list of  L{PostFilterCollection}
@return: All the post filter collections
----------
GLRender.postProcessingEnabled
This is emitted when post processing is enabled or disabled.

@type  Enabled: bool
@param Enabled: Whether of not post processing is enabled
@rtype: None
@see: L{setPostProcessingEnabled()}
----------
GLRender.registerCustomAdjustmentLayerFromXMLFile
Registers a new adjustment layer type from the given XML file path.

@type  Name: str
@param Name: The name of the layer. Paths separated by / in the name will appear as nested menu groups.
@type  FilePath: str
@param FilePath: The XML file path that defines the adjustment
@rtype: None
@raise ValueError: Raised if the given XML file does not contain a valid XML string
@raise RuntimeError: Raised if the given Name exists
@raise IOError: Raised if the given XML file does not exist
----------
GLRender.registerCustomBlendMode
Registers a new custom blend mode.

Registers a new custom blend mode written in GLSL. The code must contain a function : 
  - that returns the result of blending in vec4
  - that takes in three arguments where the first argument is the base value in vec4, the second argument is the blended value in vec4, and the third argument is the blend amount
  - that has the function name matching the L{FunctionName} parameter
B{Example Code}

>>> # This example registers a custom blend mode
>>> mari.gl_render.registerCustomBlendMode("My Mix", "Comp_MyMix",'''
... vec4 Comp_MyMix(vec4 base, vec4 over, float blend_amount)
... {
...     //Blends using standard OpenGL mix for RGB with the blend_amount while the alpha is the max of base or over
...     return vec4( mix(base.rgb, over.rgb, blend_amount), max(base.a,over.a) );
... }
... ''')

@type  DisplayName: str
@param DisplayName: The name of the blend mode to display in the GUI.
@type  FunctionName: str
@param FunctionName: The name of the GLSL function to call.
@type  BlendModeCode: str
@param BlendModeCode: The blend mode logic written in GLSL.
@rtype: None
----------
GLRender.registerCustomCodeFile
Registers a new custom code file written in GLSL.

Registers a new custom code file written in GLSL. The text contents of the given file will be included in the compilation of Mari's GLSL shader. In combination with the header file registered with L{registerCustomHeaderFile()}, the functions defined in the registered file will be available to custom layers and shaders. This behaves like .c file of C language. The L{UUID} uniquely identifies the file. Another path registered with the same L{UUID} is regarded as a new version for the file and replace the old one. The L{UUID} and path pair is also used to track missing files.

@type  UUID: str
@param UUID: Unique ID of the file
@type  FilePath: str
@param FilePath: The file path containing the GLSL
@rtype: None
@raise IOError: Raised if the given file does not exist
----------
GLRender.registerCustomDiffuseShaderFromXMLFile
Registers a new diffuse shader type from the given XML file path.

@type  Name: str
@param Name: The name of the layer.
@type  FilePath: str
@param FilePath: The XML file path that defines the diffuse shader
@rtype: None
@raise ValueError: Raised if the given XML file does not contain a valid XML string
@raise RuntimeError: Raised if the given Name exists
@raise IOError: Raised if the given XML file does not exist
----------
GLRender.registerCustomHeaderFile
Registers a new custom header file written in GLSL.

Registers a new custom header file written in GLSL. The text contents of the given file will be included in relevant parts of the shader system. L{Shader} and layer GLSL code can access function declarations and variables declared in the header file. This behaves like .h file of C language. The L{UUID} uniquely identifies the file. Another path registered with the same L{UUID} is regarded as a new version for the file and replace the old one. The L{UUID} and path pair is also used to track missing files.

@type  UUID: str
@param UUID: Unique ID of the file
@type  FilePath: str
@param FilePath: The file path containing the GLSL
@rtype: None
@raise IOError: Raised if the given file does not exist
----------
GLRender.registerCustomLayeredShaderFromXMLFile
Registers a new layered shader type from the given XML file path.

@type  Name: str
@param Name: The name of the layered shader.
@type  FilePath: str
@param FilePath: The XML file path that defines the layered shader
@rtype: None
@raise ValueError: Raised if the given XML file does not contain a valid XML string
@raise RuntimeError: Raised if the given Name exists
@raise IOError: Raised if the given XML file does not exist
----------
GLRender.registerCustomNodeFromXMLFile
Registers a new node type from the given XML file path.

@type  Name: str
@param Name: The name of the node. Paths separated by / in the name will appear as nested menu groups.
@type  FilePath: str
@param FilePath: The XML file path that defines the adjustment
@rtype: None
@raise ValueError: Raised if the given XML file does not contain a valid XML string
@raise RuntimeError: Raised if the given Name exists
@raise IOError: Raised if the given XML file does not exist
----------
GLRender.registerCustomProceduralLayerFromXMLFile
Registers a new procedural layer type from the given XML file path.

@type  Name: str
@param Name: The name of the layer. Paths separated by / in the name will appear as nested menu groups.
@type  FilePath: str
@param FilePath: The XML file path that defines the procedural
@rtype: None
@raise ValueError: Raised if the given XML file does not contain a valid XML string
@raise RuntimeError: Raised if the given Name exists
@raise IOError: Raised if the given XML file does not exist
----------
GLRender.registerCustomSpecularShaderFromXMLFile
Registers a new specular shader type from the given XML file path.

@type  Name: str
@param Name: The name of the layer.
@type  FilePath: str
@param FilePath: The XML file path that defines the specular shader
@rtype: None
@raise ValueError: Raised if the given XML file does not contain a valid XML string
@raise RuntimeError: Raised if the given Name exists
@raise IOError: Raised if the given XML file does not exist
----------
GLRender.registerCustomStandaloneShaderFromXMLFile
Registers a new standalone shader type from the given XML file path.

@type  Name: str
@param Name: The name of the layer.
@type  FilePath: str
@param FilePath: The XML file path that defines the standlone shader
@rtype: None
@raise ValueError: Raised if the given XML file does not contain a valid XML string
@raise RuntimeError: Raised if the given Name exists
@raise IOError: Raised if the given XML file does not exist
----------
GLRender.reloadXMLDefinitions
Reloads layer and shader definition files.

Reloads layer and shader definition files. A custom shader and layer developer can reload and test the shader and layer definition files without relaunching Mari by executing this function.

@rtype: None
----------
GLRender.removeQuickApplyFilter
Deletes (removes) a filter.

@type  Filter: L{PostFilter}
@param Filter: The filter to delete
@rtype: None
@raise ValueError: Raised if the filter is not a quick apply filter.
----------
GLRender.runGLSLCode
Runs the given GLSL code and writes the result into the given L{ImageSet}.

The GLSL code must write the result into the "Output" variable as vec4.

When L{Source} is provided, the GLSL code can use the values from the texture values in L{Source} by using the token, "#Input". The result will be blended onto the L{Source} L{ImageSet} with L{Mask} applied using the L{BlendMode} and L{BlendAmount}

Examples :

This fills selected area in red and leave the rest black. C{mari.gl_render.runGLSLCode("Output = vec4(_State.Selected,0,0,1);",DestImageSet)}

This fills the selected area in red and blends it with L{Source} image set and writes the result into Dest C{mari.gl_render.runGLSLCode("Output = vec4(1,0,0,_State.Selected);",DestImageSet,SourceImageSet)}

This amplifies the red component of non-masked area of the L{Source} imageset and writes the result into Dest C{mari.gl_render.runGLSLCode("Output = vec4(#Input.r*2.0,#Input.gba",DestImageSet,SourceImageSet,MaskImageSet)}

This fills the selected area in transparency. Note that, in order to modify alpha component, you must use Comp_Copy blend mode C{mari.gl_render.runGLSLCode("Output = mix(#Input, vec4(0,0,0,0), float(_State.Selected));",DestImageSet,SourceImageSet,None,"Comp_Copy")}

@type  GLSLCode: str
@type  Destination: L{ImageSet}
@type  Source: L{ImageSet}
@type  Mask: L{ImageSet}
@type  BlendMode: str
@type  BlendAmount: float
@rtype: None
----------
GLRender.setCurrentPostFilterCollection
This is emitted just after the current post filter collection is changed.

@rtype: None
@see: L{currentPostFilterCollection()}
----------
GLRender.setCustomLut
Set a custom 1D display LUT to use while rendering.

The LUT (lookup table) is used to transform incoming color values to a new display value. This can be used to simulate different display devices, etc.

By default, an identity (no transform) LUT is used.

@type  Lut: list of  L{Color}
@param Lut: A vector of L{Colors}. This should contain 1024 entries.
@rtype: None
@deprecated: Please use the L{PostFilterCollection} functions in conjunction with the L{CustomLUTFilter} class instead of this function.
----------
GLRender.setLutEnabled
Enable and disable the display time LUT.

If the LUT is disabled, no color transforms will be applied to the rendered image or textures before display.

@type  Enabled: bool
@param Enabled: True will enable the application of a display time LUT; False will disable it.
@rtype: None
@deprecated: Please use L{setPostProcessingEnabled()} instead.
@see: L{lutEnabled()}
----------
GLRender.setPostFilterCollection
Sets a post process filter collection as the current.

Changes the current post process filter collection to another.

@type  Collection: L{PostFilterCollection}
@param Collection: The post filter collection to set.
@rtype: None
@see: L{createPostFilterCollection()}, L{findPostFilterCollection()}, L{deletePostFilterCollection()}, L{currentPostFilterCollection()}
----------
GLRender.setPostProcessingEnabled
Enables or disables post processing color management in the viewport.

@type  Enabled: bool
@param Enabled: True to enable post processing, or False to disable it
@rtype: None
@see: L{postProcessingEnabled()}
----------
GLRender.shaderCompileComplete
This is emitted whenever the current GL shader program is compiled and linked.

C{# Print out result when current GL shader program compiles.}

C{def printShaderCompileResult(result, error_message):}

C{print 'Shader Compile SUCCEEDED' if result == mari.gl_render.SHADER_LINK_SUCCESS else 'Shader Compile FAILED'}

C{if error_message:}

C{print 'Error Message:\\n', error_message}

C{mari.utils.connect(mari.gl_render.shaderCompileComplete, printShaderCompileResult)}

@type  Result: L{GLRender.ShaderCompileResult}
@param Result: Whether the current GL shader program is compiled and linked successfully.
@type  ErrorMessage: str
@param ErrorMessage: The associated error message if compilation or linking failed.
@rtype: None
----------
GLRender.upgradeExistingShadersAndLayers
Upgrades existing shaders and layers based on up-to-date XML definitions.

Upgrades existing shaders and layers based on up-to-date XML definitions. A custom shader and layer developer can call this function after L{reloadXMLDefinitions()} to update existing shaders and layers with the new updated definitions.

@rtype: None
----------
GLSLFilter
A post processing filter that runs custom GLSL code.

L{GLSLFilter} objects can be created by calling L{PostFilterCollection.createGLSL()}.

B{Example Code}

>>> # This examples creates a new GLSLFilter object through GLRender and PostFilterCollection
>>> import mari
>>> filter_collection = mari.gl_render.createPostFilterCollection("New Filter Collection")
>>> glsl_filter = filter_collection.createGLSL("New GLSL Filter")
>>> mari.gl_render.deletePostFilterCollection(filter_collection)
----------
GLSLFilter.bodySnippet
Returns the body GLSL snippet for the filter.

@rtype: str
@return: Body GLSL snippet.
@see: L{setBodySnippet()}
----------
GLSLFilter.definitionsSnippet
Returns the definition GLSL snippet for the filter.

@rtype: str
@return: The GLSL shader snippet that defines the functions and uniforms for this post process filter.
@see: L{setDefinitionsSnippet()}
----------
GLSLFilter.deleteTexture
Deletes the texture associated with the given sampler.

This deletes and frees the texture associated with the given sampler. You should do this when replacing the texture with a new one.

@type  SamplerName: str
@param SamplerName: The name of the sampler associated with the texture to delete
@rtype: None
----------
GLSLFilter.enabledChanged
This is emitted when the filter is enabled or disabled.

DEPRICATED (3.0v2): This function will be removed in a future version. Please use L{flagsChanged()} instead.

@type  Enabled: bool
@rtype: None
----------
GLSLFilter.setBodySnippet
Sets the body GLSL snippet for the filter.

@type  BodySnippet: str
@param BodySnippet: Body GLSL snippet.
@rtype: None
@see: L{bodySnippet()}
----------
GLSLFilter.setDefinitionsSnippet
Sets the definition GLSL snippet for the filter.

@type  DefinitionsSnippet: str
@param DefinitionsSnippet: The GLSL shader snippet that defines the functions and uniforms for this post process filter.
@rtype: None
@see: L{definitionsSnippet()}
----------
GLSLFilter.setTexture1D
Adds a 1D texture for this filter to use.

Post processing filters, such as look up tables (LUTs), need input data to work with. This method makes it possible to provide texture data for use in the filter.

This is not really intended for large images, as upload performance will not be great.

All texture data is assumed to be floating point, and is uploaded unclamped.

@type  SamplerName: str
@param SamplerName: The name of the sampler to bind this texture to
@type  Width: int
@param Width: The width of the texture in pixels.
@type  DataFormat: L{Format}
@param DataFormat: The format of the incoming texture data.
@type  Data: list of  float
@param Data: A list of floating point values that constitutes the data for the texture. This should contain (L{Width} * components per pixel) entries
@type  MinFilter: L{Filter}
@param MinFilter: The filter to use when minifying the texture
@type  MagFilter: L{Filter}
@param MagFilter: The filter to use when magnifying the texture
@type  ClampS: L{Clamp}
@param ClampS: The method for clamping the texture in the S Direction
@type  ClampT: L{Clamp}
@param ClampT: The method for clamping the texture in the T direction
@rtype: None
----------
GLSLFilter.setTexture2D
Adds a 2D texture for this filter to use.

Post processing filters, such as look up tables (LUTs), need input data to work with. This method makes it possible to provide texture data for use in the filter.

This is not really intended for large images, as upload performance will not be great.

All texture data is assumed to be floating point, and is uploaded unclamped.

@type  SamplerName: str
@param SamplerName: The name of the sampler to bind this texture to
@type  Width: int
@param Width: The width of the texture in pixels
@type  Height: int
@param Height: The height of the texture in pixels
@type  DataFormat: L{Format}
@param DataFormat: The format of the incoming texture data
@type  Data: list of  float
@param Data: A list of floating point values that constitutes the data for the texture. This should contain (L{Width} * L{Height} * components per pixel) entries
@type  MinFilter: L{Filter}
@param MinFilter: The filter to use when minifying the texture
@type  MagFilter: L{Filter}
@param MagFilter: The filter to use when magnifying the texture
@type  ClampS: L{Clamp}
@param ClampS: The method for clamping the texture in the S Direction
@type  ClampT: L{Clamp}
@param ClampT: The method for clamping the texture in the T direction
@rtype: None
----------
GLSLFilter.setTexture3D
Adds a 3D texture for this filter to use.

Post processing filters, such as look up tables (LUTs), need input data to work with. This method makes it possible to provide texture data for use in the filter.

This is not really intended for large images, as upload performance will not be great.

All texture data is assumed to be floating point, and is uploaded unclamped.

@type  SamplerName: str
@param SamplerName: The name of the sampler to bind this texture to
@type  Width: int
@param Width: The width of the texture in pixels
@type  Height: int
@param Height: The height of the texture in pixels
@type  Depth: int
@param Depth: The height of the texture in pixels
@type  DataFormat: L{Format}
@param DataFormat: The format of the incoming texture data.
@type  Data: list of  float
@param Data: A list of floating point values that constitutes the data for the texture. This should contain (L{Width} * L{Height} * L{Depth} * components per pixel) entries
@type  MinFilter: L{Filter}
@param MinFilter: The filter to use when minifying the texture
@type  MagFilter: L{Filter}
@param MagFilter: The filter to use when magnifying the texture
@type  ClampS: L{Clamp}
@param ClampS: The method for clamping the texture in the S Direction
@type  ClampT: L{Clamp}
@param ClampT: The method for clamping the texture in the T direction
@type  ClampR: L{Clamp}
@param ClampR: The method for clamping the texture in the R direction
@rtype: None
----------
GLSLFilter.updateTexture1D
Updates an existing 1D texture.

This is similar to a glTexSubImage1D call.

@type  SamplerName: str
@param SamplerName: The name of the sampler to bind this texture to. This must already have a texture bound using setTexture2D
@type  Data: list of  float
@param Data: A list of floating point values that constitutes the data for the texture. This should contain (width * components per pixel) entries
@rtype: None
@raise ValueError: Raised if Data does not contain the correct number of entries, or another parameter is incorrect.
@note: The width and format of the texture update must be the same as the texture set with setTexture1D. If Data does not contain the correct number of samples, this function will raise an exception.
----------
GLSLFilter.updateTexture2D
Updates an existing 2D texture.

This is similar to a glTexSubImage2D call.

@type  SamplerName: str
@param SamplerName: The name of the sampler to bind this texture to. This must already have a texture bound using setTexture2D
@type  Data: list of  float
@param Data: A list of floating point values that constitutes the data for the texture. This should contain (width * height * components per pixel) entries
@rtype: None
@raise ValueError: Raised if Data does not contain the correct number of entries, or another parameter is incorrect.
@note: The width, height, and format of the texture update must be the same as the texture set with setTexture2D. If Data does not contain the correct number of samples, this function will raise an exception.
----------
GLSLFilter.updateTexture3D
Updates an existing 3D texture.

This is similar to a glTexSubImage3D call.

@type  SamplerName: str
@param SamplerName: The name of the sampler to bind this texture to. This must already have a texture bound using setTexture3D
@type  Data: list of  float
@param Data: A list of floating point values that constitutes the data for the texture. This should contain (width * height * depth * components per pixel) entries
@rtype: None
@raise ValueError: Raised if Data does not contain the correct number of entries, or another parameter is incorrect.
@note: The width, height, depth, and format of the texture update must be the same as the texture set with setTexture3D. If Data does not contain the correct number of samples, this function will raise an exception.
----------
GeoEntity
These are the geometric meshes referred to as "Objects" in the GUI.

B{Example Code}

C{# This examples obtains the current geometry object}

C{import mari}

C{current_object = mari.geo.current()}
----------
GeoEntity.addLocator
Add a locator to this object.

@rtype: L{LocatorEntity}
@return: The newly-created locator.
----------
GeoEntity.addVersion
Adds a new version of the object from one or more files.

It is often useful to have multiple versions of a geometry available to test.

When adding versions, it is assumed that only the world space positions and normals of the objects have changed.

When dealing with geometry with updated UVs, no conversion occurs, and rendering artifacts may be seen.

As in L{GeoManager.load()}, the settings for the geometry load can be controlled by the function parameter L{Options}, and the format of the parameter is the same.

@type  Paths: variant
@param Paths: The path(s) to the file(s) containing the new version geometry. This must be either a single pathname, or a list of pathnames.
@type  Name: str
@param Name: The name for the new version. This must be unique for this item.
@type  Options: variant
@param Options: An optional dictionary (or list, for backwards compatibility) of settings to control the geometry load, as in L{GeoManager.load()}
@rtype: None
@raise ValueError: Raised if no paths were provided, any of the file paths were empty, the version name already exists, or the options string list was invalid.
@raise IOError: Raised if any of the files to load the version from was not found.
@raise TypeError: Raised if the paths parameter is not a string or list of strings.
@raise RuntimeError: Raised if the mesh types are invalid for adding version.
@note: The Options initially default to the settings from the current version of the Object. Any options provided are treated as overrides to the defaults.
@deprecated: Please pass the Options parameter in C{{'name': value}} dictionary format, instead of the old C{['name=value']} list format.
@see: L{versionList()}, L{removeVersion()}, L{renameVersion()}, L{versionNames()}
----------
GeoEntity.boundingBoxLowerBounds
Returns the lower bounds of the object bounding box.

@rtype: L{VectorN}
@return: Vector of the lower bounds.
----------
GeoEntity.boundingBoxUpperBounds
Returns the upper bounds of the object bounding box.

@rtype: L{VectorN}
@return: Vector of the upper bounds.
----------
GeoEntity.boundingSphereCenter
Return the centrum of the bounding sphere of the object.

@rtype: L{VectorN}
@return: The position of the sphere center.
----------
GeoEntity.boundingSphereRadius
Return the radius of the bounding sphere of the object.

@rtype: float
@return: The sphere radius.
----------
GeoEntity.channel
Returns the channel with the given name.

@type  ChannelName: str
@param ChannelName: The name of the channel to retrieve
@rtype: L{Channel}
@return: The requested channel.
@raise ValueError: Raised if the given channel name was not found on the object.
----------
GeoEntity.channelAdded
This is emitted when a new channel is added, by creation and loading.

This signal will be emitted multipl times during a channels creation. If you only want one signal use L{channelCreated()}

@type  NewChannel: L{Channel}
@param NewChannel: The newly-added channel
@rtype: None
----------
GeoEntity.channelCreated
This is emitted when a new channel is created on the entity.

@type  NewChannel: L{Channel}
@param NewChannel: The newly-created channel
@rtype: None
----------
GeoEntity.channelList
Returns a list of channels present on the object.

@rtype: list of  L{Channel}
@return: A list of the channels associated with this object
----------
GeoEntity.channelMadeCurrent
This is emitted when a different channel is made current.

@type  NewCurrentChannel: L{Channel}
@param NewCurrentChannel: The channel that is now current.
@rtype: None
----------
GeoEntity.channelRemoved
This is emitted when a channel is removed.

@type  OldChannel: L{Channel}
@param OldChannel: The removed channel
@rtype: None
----------
GeoEntity.completePatchList
Returns a list of all the different UV patches that make up this object.

This function behaves the same as L{patchList()} except that invalid patches are appeneded to the end of the returned list.

@rtype: list of  L{GeoPatch}
@return: A list of the UV patch objects associated with this geometry
@see: L{patchList()}
----------
GeoEntity.createChannel
Creates a new channel from the settings provided.

This function can be used to create either UV or L{Ptex} channels, depending on whether or not the entity is using L{Ptex}. For L{Ptex} channels, the L{Width} and L{Height} parameters are ignored, so using the function L{createPtexChannel()} is more convenient.

@type  Name: str
@param Name: The name to call the new channel
@type  Width: int
@param Width: The default width of the channel (ignored for L{Ptex})
@type  Height: int
@param Height: The default height of the channel (ignored for L{Ptex})
@type  Depth: int
@param Depth: The default bit depth of the channel
@type  IsShaderStack: bool
@param IsShaderStack: If True create the channel as a ShaderStack. If none is passed a nonShaderStack is created.
@rtype: L{Channel}
@return: The newly-created channel
@raise ValueError: Raised if the channel name is already in use, depth is not supported or width and height are not supported
@raise RuntimeError: Raised if the channel could not be created
@see: L{createDuplicateChannel()}, L{createPtexChannel()}
----------
GeoEntity.createDiffuseSpecularShader
Creates a new shader from the combination of diffuse and specular.

@type  Name: str
@param Name: The name of the shader to create.
@type  DiffuseType: str
@param DiffuseType: The diffuse type of the shader to create.
@type  SpecularType: str
@param SpecularType: The specular type of the shader to create.
@rtype: L{Shader}
@return: The new shader.
@raise RuntimeError: Raised if the shader could not be created.
----------
GeoEntity.createDuplicateChannel
Creates a new channel as a duplicate of the passed channel.

@type  ChannelToDuplicate: L{Channel}
@param ChannelToDuplicate: The channel to duplicate. It must be a channel that is part of this L{GeoEntity}.
@type  NewChannelName: str
@param NewChannelName: The name to call the new channel. If none is passed, a name will be generated.
@rtype: L{Channel}
@return: The newly created channel.
@raise RuntimeError: Raised if the channel could not be created, or if ChannelToDuplicate is not part of this L{GeoEntity}.
@see: L{createChannel()}, L{createPtexChannel()}
----------
GeoEntity.createLayeredShader
Creates a new layered shader.

@type  Name: str
@param Name: The name of the shader to create.
@type  LayeredType: str
@param LayeredType: The layered type of the shader to create.
@rtype: L{Shader}
@return: The new shader.
@raise RuntimeError: Raised if the shader could not be created.
----------
GeoEntity.createPtexChannel
Creates a new L{Ptex} channel from the settings provided.

For entities using L{Ptex}, this is the same as calling L{createChannel()}, but does not require the width and height parameters, which are not applicable.

For entities not using L{Ptex}, this function will raise an exception.

@type  Name: str
@param Name: The name to call the new channel
@type  Depth: int
@param Depth: The default bit depth of the channel
@rtype: L{Channel}
@return: The newly-created channel
@raise ValueError: Raised if the channel name is already in use, depth is not supported or width and height are not supported
@raise RuntimeError: Raised if the channel could not be created, or if the entity is not using L{Ptex}
@see: L{createChannel()}, L{createDuplicateChannel()}
----------
GeoEntity.createShader
Creates a standalone shader or diffuse and specular shader.

Creates a standalone shader or diffuse and specular shader.

This method is provided for compatibility only and will be removed in a future version.

Please use L{createStandaloneShader()} or L{createDiffuseSpecularShader()} instead.

This creates a standalone shader or a shader consisting of diffuse and specular. For example,

To create a standalone shader of type Flat:

C{GeoEntity.createShader("Flat","Lighting/Standalone/Flat");}

To create a diffuse and specular shader of type Lambertian and Phong:

C{GeoEntity.createShader("Phong","Lighting/Diffuse/Lambertian","Lighting/Specular/Phong");}

@type  Name: str
@param Name: The name of the shader to create.
@type  Type: str
@param Type: The standalone type of the shader to create if L{SpecularType} is empty. The diffuse type of the shader to create if L{SpecularType} is provided.
@type  SpecularType: str
@param SpecularType: The specular type of the shader to create.
@rtype: L{Shader}
@return: The new shader.
@raise RuntimeError: Raised if the shader could not be created.
@deprecated: This method will be removed in a future version. Please use L{createStandaloneShader()} or L{createDiffuseSpecularShader()} instead.
@see: L{createStandaloneShader()}
----------
GeoEntity.createStandaloneShader
Creates a new standalone shader.

@type  Name: str
@param Name: The name of the shader to create.
@type  StandaloneType: str
@param StandaloneType: The standalone type of the shader to create.
@rtype: L{Shader}
@return: The new shader.
@raise RuntimeError: Raised if the shader could not be created.
----------
GeoEntity.currentChannel
Returns the channel currently selected on the entity.

@rtype: L{Channel}
@return: The currently selected channel, or None if none.
@see: L{setCurrentChannel()}
----------
GeoEntity.currentImageSet
Returns the image set currently selected for painting into on the entity.

@rtype: L{ImageSet}
@return: The currently-selected image set, or None if none.
@see: L{setCurrentImageSet()}
----------
GeoEntity.currentShader
Returns the currently active shader.

@rtype: L{Shader}
@return: The active shader for this object
@see: L{setCurrentShader()}
----------
GeoEntity.currentVersion
Returns the currently active version of the object.

@rtype: L{GeoEntityVersion}
@return: The currently active version.
@see: L{currentVersionName()}, L{setCurrentVersion()}
----------
GeoEntity.currentVersionName
Returns the name of the currently active version of the object.

@rtype: str
@return: The name of the currently active version
@see: L{currentVersion()}
----------
GeoEntity.exportAsArchive
Export this L{GeoEntity} as a light weight geometry archive.

@type  DirPath: str
@param DirPath: The directory path to save the L{GeoEntity} archive to.
@rtype: None
----------
GeoEntity.findChannel
Returns the channel with the given name.

@type  ChannelName: str
@rtype: L{Channel}
@return: The requested channel. Return None is not found.
----------
GeoEntity.findImageSet
Returns the image set with the given name if found, or None.

The string matching is case insensitive.

@type  rName: str
@rtype: L{ImageSet}
@return: The given image set if found, or None otherwise
----------
GeoEntity.findShader
Finds and returns any shader with the given name.

@type  Name: str
@param Name: The name of the shader to look for.
@rtype: L{Shader}
@return: The matching shader if found, or None otherwise.
@see: L{shader()}
----------
GeoEntity.generateSubdivision
Generates subdivision surfaces.

This calls OpenSubdiv library to generate subdivision surfaces. L{Options} can be specified to set the following:
  - Level (int) : Subdivision Level
  - Force (bool) : True to force subdivision of geometry pieces marked as "Don't subdivide"
  - Use Source (bool) : True, to automatically use subdivision settings (scheme and rules) from the source geometry file, or False, to use user-supplied settings.
  - Scheme (L{GeoManager.OpenSubdivisionSchemeType}) : Subdivision scheme
  - Boundary Interpolation (L{GeoManager.OpenSubdivisionBoundaryInterpolation}) : Boundary interpolation rule
  - Face Varying Interpolation (L{GeoManager.OpenSubdivisionFaceVaryingInterpolation}) : Face-varying data interpolation rule
  - Creasing (L{GeoManager.OpenSubdivisionCreasingMethod}) : Creasing method
  - Triangle Subdivision (L{GeoManager.OpenSubdivisionTriangleSubdivision}) : Triangle subdivision rule

The following options are DEPRECATED:
  - Scheme (string) : One of "Catmull Clark", "Loop" or "Bilinear"
  - Boundary Interpolation (string) : One of "None", "Edge Only", "Edge And Corner (No Corner Progation)" or "Edge And Corner (Corner Propagation)" or "Always Sharp"

Examples:

>>> import mari
>>> # Subdivide using default settings from source file
>>> options = {}
>>> mari.geo.current().generateSubdivision(options)
>>>
>>> # Subdivide using overriden settings, Catmull clark subdivision at level 2
>>> options = {}
>>> options["Level"] = 2
>>> options["Scheme"] = mari.geo.SCHEME_CATMARK
>>> mari.geo.current().generateSubdivision(options)
>>>
>>> # Subdivide using overriden settings, Loop clark subdivision at level 3, boundary interpolation set to edge only, uv face varying interpolation set to boundaries
>>> options = {}
>>> options["Level"] = 3
>>> options["Scheme"] = mari.geo.SCHEME_LOOP
>>> options["Boundary Interpolation"] = mari.geo.VTX_BOUNDARY_EDGE_ONLY
>>> options["Face Varying Interpolation"] = mari.geo.FVAR_LINEAR_BOUNDARIES
>>> mari.geo.current().generateSubdivision(options)
>>>
>>> # Subdivide using overriden settings, Catmull clark subdivision at level 1, creasing set to chaikin and triangle subdivision set to smooth
>>> options = {}
>>> options["Level"] = 1
>>> options["Scheme"] = mari.geo.SCHEME_CATMARK
>>> options["Creasing"] = mari.geo.CREASE_CHAIKIN
>>> options["Triangle Subdivision"] = mari.geo.TRI_SUB_SMOOTH
>>> mari.geo.current().generateSubdivision(options)

@type  Options: QMap of  str, variant
@param Options: L{Options} for generating subdivision surfaces up to.
@rtype: bool
@return: Returns whether subdivision succeeded.
@raise ValueError: Raised if the operation fails, with warnings.
@deprecated: Some of the key-values, passed in the Options map will be removed in future versions.
----------
GeoEntity.geometryVersionAdded
This is emitted when a new geometry version is added.

@type  Name: str
@param Name: The name of the new version
@rtype: None
----------
GeoEntity.geometryVersionMadeCurrent
This is emitted when a new geometry version becomes current.

@type  Name: str
@param Name: The name of the newly current version
@rtype: None
----------
GeoEntity.geometryVersionRemoved
This is emitted when a geometry version is removed.

@type  Name: str
@param Name: The name of the version removed
@rtype: None
----------
GeoEntity.hideLocator
Hide the locator UI object.

@rtype: None
----------
GeoEntity.imageSet
Returns the image set with the given name.

The string matching is case insensitive.

@type  rImageSetName: str
@rtype: L{ImageSet}
@return: The requested image set.
@raise ValueError: Raised if the given image set name was not found on the object.
----------
GeoEntity.imageSetAdded
This is emitted when a image set is added to the object.

@type  NewImageSet: L{ImageSet}
@param NewImageSet: The newly-created image set
@rtype: None
----------
GeoEntity.imageSetList
Returns a list of the image sets that are present on the entity.

@rtype: list of  L{ImageSet}
@return: A list of the image sets associated with this object
----------
GeoEntity.imageSetMadeCurrent
This is emitted when an image set becomes current.

@type  CurrentImageSet: L{ImageSet}
@param CurrentImageSet: The new current image set
@rtype: None
----------
GeoEntity.imageSetNames
Returns a string list of the names of all of the image sets that are present on the object.

@rtype: list of str
@return: A list of the names of the image sets associated with this object
----------
GeoEntity.imageSetRemoved
This is emitted when a image set is removed from the object.

@type  OldImageSet: L{ImageSet}
@param OldImageSet: The removed image set
@rtype: None
----------
GeoEntity.isPtex
Returns True if the object is L{Ptex} based.

@rtype: bool
----------
GeoEntity.isSelected
Indicates whether the object is currently selected.

@rtype: bool
@return: True if the object is selected, or False if not
----------
GeoEntity.maximumSubdivisionLevel
Returns the maximum subdivision level calculated already for this L{GeoEntity}.

@rtype: int
----------
GeoEntity.name
Returns the name of the object.

@rtype: str
@return: The name of this object
@see: L{setName()}
----------
GeoEntity.nameChanged
This is emitted after the entity has been renamed.

@type  NewName: str
@param NewName: The new name of the entity
@rtype: None
----------
GeoEntity.nodeGraph
Returns the root shader node graph this L{GeoEntity} holds.

@rtype: L{NodeGraph}
@return: The shader node graph
----------
GeoEntity.patch
Returns the patch that corresponds to the given UV index.

@type  UvIndex: int
@param UvIndex: The index of the patch to return
@rtype: L{GeoPatch}
@return: The requested patch
@raise ValueError: If index is out of range
----------
GeoEntity.patchImage
Convenience method to lookup the image for the specified patch.

on the specified channel.

@type  Patch: L{GeoPatch}
@param Patch: L{GeoPatch} object for which to do the lookup.
@type  pImageSet: L{ImageSet}
@param pImageSet: L{ImageSet} object for which to do the lookup.
@rtype: L{Image}
@return: L{Image} object associated with the patch.
@raise ValueError: Raised if Patch isn't a valid L{GeoPatch} object, or if Chan isn't a valid L{ImageSet} object.
----------
GeoEntity.patchList
Returns a list of the different valid UV patches that make up this object.

Geometry may be broken into multiple UV patches. Each UV patch occupies a single integer square in UV space. Each patch may have a name, associated metadata, and locked or hidden or valid status.

As of version 1.4v3, these patches are returned in UV index order - the same order as L{ImageSet.imageList()}. Note however that these indices do not necessarily map directly to UDIMs, as some UDIMs may be unused, and there will not be any corresponding spaces left empty in the array. To be sure of the UDIM of a patch, call the L{GeoPatch.udim()} method.

@rtype: list of  L{GeoPatch}
@return: A list of the UV patch objects associated with this geometry
@note: In versions older than 1.4v3, this function does not necessarily return the images in any particular order, or in the same order as L{ImageSet.imageList()}.
@note: Only valid patches are returned. To retreive all patches use L{completePatchList()}.
@note: This method returns the combined list of all patches from the L{GeoEntityVersion} objects belonging to this L{GeoEntity}. See L{GeoEntityVersion.patchList()}
@see: L{completePatchList()}
----------
GeoEntity.removeChannel
Removes the given channel.

This is added as an undo record, and so can be undone if required.

@type  ChannelToRemove: L{Channel}
@param ChannelToRemove: The channel to remove. This must be a channel owned by the L{GeoEntity}.
@type  Strategy: L{ChannelDestroyStrategy}
@param Strategy: The logic used to remove shared items with the channel
@rtype: None
@raise ValueError: Raised if the channel provided is invalid, locked or does not belong to the object.
----------
GeoEntity.removeShader
Removes the given shader.

This is added as an undo record, and so can be undone if required.

@type  ShaderToRemove: L{Shader}
@param ShaderToRemove: The shader to remove. This must be a shader owned by the L{GeoEntity}.
@rtype: None
@raise ValueError: Raised if the shader provided is invalid, locked or does not belong to the object.
----------
GeoEntity.removeVersion
Removes the named version of this object.

An object must have at least one version. Attempting to remove the last version of an object will fail.

@type  VersionName: str
@param VersionName: The name of the version to remove
@rtype: None
@raise ValueError: Raised if the given version name was not found.
@raise RuntimeError: Raised if the given version could not be removed because it was the last one on the object.
@see: L{addVersion()}, L{renameVersion()}
----------
GeoEntity.renameVersion
Renames a geometry version.

The new name must be unique for this object.

@type  OldName: str
@param OldName: The name of the version you wish to change
@type  NewName: str
@param NewName: The new name for the version. This must be unique for the object.
@rtype: None
@return: True if the name was performed, False otherwise
@raise ValueError: Raised if the provided old name did not match any available version to change, or the new name was a duplicate of an existing version name.
@see: L{versionList()}, L{removeVersion()}, L{versionNames()}, L{addVersion()}
----------
GeoEntity.save
Saves the geometry into a file.

The current version at the current subdivision level is saved.

@type  FileName: str
@param FileName: The file name to save as
@type  Format: str
@param Format: The geometry format. If not provided, the format is guessed from the extension
@rtype: None
@raise RuntimeError: Raised if the geometry cannot be saved .
----------
GeoEntity.selectedPatches
Returns a list of the different selected UV patches that make up this object.

@rtype: list of  L{GeoPatch}
@return: A list of the currently selected UV patch objects associated with this geometry
----------
GeoEntity.setCurrentChannel
Makes the given channel current on this object.

@type  NewCurrentChannel: L{Channel}
@param NewCurrentChannel: The channel to make current
@rtype: None
@raise ValueError: Raised if the channel provided is invalid, locked or does not belong to the object.
@see: L{currentChannel()}
----------
GeoEntity.setCurrentImageSet
Sets the image set to be 'current', or active for painting into.

@type  NewCurrentImageSet: variant
@param NewCurrentImageSet: The image set to make current. This must be either an L{ImageSet} object owned by the L{GeoEntity}, or the name of one.
@rtype: None
@raise ValueError: Raised if the image set is invalid, or not owned by the object.
@raise TypeError: Raised if the image set parameter is not a string or L{ImageSet} object.
@see: L{currentImageSet()}
----------
GeoEntity.setCurrentShader
Makes the given shader current on this object.

@type  NewCurrentShader: L{Shader}
@param NewCurrentShader: The shader to make current.
@rtype: None
@raise ValueError: Raised if the shader provided is invalid, locked or does not belong to the object.
@see: L{currentShader()}
----------
GeoEntity.setCurrentVersion
Sets the current active version of the object.

@type  VersionName: str
@param VersionName: The name of the version to set as current.
@rtype: None
@see: L{versionList()}, L{versionNames()}, L{currentVersion()}
----------
GeoEntity.setName
Changes the name of the object.

@type  NewName: str
@param NewName: The new name of the object
@rtype: None
@see: L{name()}
----------
GeoEntity.setSelected
Changes the selection state of the object.

@type  Selected: bool
@param Selected: True to select the object, or False to deselect it
@rtype: None
@note: Exactly one object can be selected at a time. If only one object is available, it cannot be deselected.
----------
GeoEntity.setSubdivisionLevel
Sets the subdivision level to render this L{GeoEntity} at.

@type  Level: int
@param Level: Sudivision level to render this L{GeoEntity} at.
@rtype: None
@raise ValueError: Throws a value error if the given Level is below 0 or exceeds the maximum subdivision level calculated for the current version.
----------
GeoEntity.setTransform
Sets the transform of the geo entity for a frame.

@type  pTransform: L{Matrix}
@param pTransform: Translation vector
@type  Frame: int
@param Frame: L{Frame}
@rtype: None
@raise ValueError: Throws a value error if the input if not a valid matrix
@see: L{transform()}
----------
GeoEntity.shader
Returns the shader with the given name.

@type  Name: str
@param Name: The name of the shader to look for.
@rtype: L{Shader}
@return: The matching shader.
@raise ValueError: Raised if the given shader name was not found on the object.
@see: L{findShader()}
----------
GeoEntity.shaderAdded
This is emitted when a new shader is added.

@type  NewShader: L{Shader}
@param NewShader: The newly-added shader.
@rtype: None
@deprecated: This signal will be removed or repurposed in a future version. Please use L{shaderCreated()} instead.
----------
GeoEntity.shaderCreated
This is emitted when a new shader is created.

@type  NewShader: L{Shader}
@param NewShader: The newly-created shader.
@rtype: None
----------
GeoEntity.shaderDiffuseTypeList
Returns a list of diffuse shader types.

@rtype: list of str
@return: A list of diffuse shader types.
----------
GeoEntity.shaderLayeredTypeList
Returns a list of layered shader types that can be created.

@rtype: list of str
@return: A list of layered shader types.
----------
GeoEntity.shaderList
Returns a list of shaders present on the object.

@rtype: list of  L{Shader}
@return: A list of the shaders associated with this object
----------
GeoEntity.shaderMadeCurrent
This is emitted when a different shader is made current.

@type  CurrentShader: L{Shader}
@param CurrentShader: The shader that became current.
@rtype: None
----------
GeoEntity.shaderRemoved
This is emitted when a shader is removed.

@type  OldShader: L{Shader}
@param OldShader: The removed shader.
@rtype: None
----------
GeoEntity.shaderSpecularTypeList
Returns a list of specular shader types.

@rtype: list of str
@return: A list of specular shader types.
----------
GeoEntity.shaderStandaloneTypeList
Returns a list of standalone shader types that can be created.

@rtype: list of str
@return: A list of standalone shader types.
----------
GeoEntity.showLocator
Show the locator UI object.

@rtype: None
----------
GeoEntity.subdivisionBoundaryInterpolateMethod
Returns the collated subdivision boundary interpolation rule for this L{GeoEntity}.

@rtype: str
----------
GeoEntity.subdivisionCreasing
Returns the collated subdivision creasing for this L{GeoEntity}.

@rtype: str
----------
GeoEntity.subdivisionFaceVaryingBoundaryInterpolateMethod
Returns the collated subdivision face varying interpolation rule for this L{GeoEntity}.

@rtype: str
----------
GeoEntity.subdivisionScheme
Returns the collated subdivision scheme for this L{GeoEntity}.

@rtype: str
----------
GeoEntity.subdivisionSkippedMeshList
Returns the list of skipped meshes during subdivision.

@rtype: list of str
----------
GeoEntity.subdivisionTriangleSubdivisionRule
Returns the collated subdivision triangle rule for this L{GeoEntity}.

@rtype: str
----------
GeoEntity.systemShader
Returns the system shader of the specified type.

@type  Type: L{SystemShaderType}
@param Type: The type of the desired system shader
@rtype: L{Shader}
@return: The system shader of the specified type
@raise RuntimeError: Raised if the system shader could not be found.
@raise ValueError: Raised if invalid type is specified by Type.
----------
GeoEntity.transform
Returns the transform matrix at a given frame.

@type  Frame: int
@param Frame: L{Frame}
@rtype: L{Matrix}
@return: L{Matrix} of the transform.
@see: L{setTransform()}
----------
GeoEntity.translation
Returns the translation vector at a given frame.

@type  Frame: int
@param Frame: L{Frame}
@rtype: L{VectorN}
@return: Vector of the translation.
----------
GeoEntity.version
Returns a geometry version object.

@type  VersionName: str
@param VersionName: The name of the version to return. This should be one of the names returned by L{versionNames()}.
@rtype: L{GeoEntityVersion}
@return: The requested version object.
@raise ValueError: Raised if the version name was not found.
@see: L{versionNames()}
----------
GeoEntity.versionList
Returns a list of the available versions of this geometry.

@rtype: list of  L{GeoEntityVersion}
@return: A list of the available geometry versions
@see: L{addVersion()}, L{removeVersion()}, L{versionNames()}
----------
GeoEntity.versionNames
Returns a list of names of the available versions of this geometry.

@rtype: list of str
@return: A list of the names of the geometry versions
@see: L{versionList()}
----------
GeoEntityVersion
Provides access to an individual version of a geometry entity.

Mari allows objects to have multiple versions. These versions should be uniquely named.

You can access a geometry entity version through a L{GeoEntity} - for example: C{mari.geo.current().versionList()}

B{Example Code}

C{# This examples obtains the current version of current geometry object}

C{import mari}

C{currentObjectVersion = mari.geo.current().currentVersion()}
----------
GeoEntityVersion.aboutToLoad
This is emitted just before the data for the version is loaded.

@rtype: None
----------
GeoEntityVersion.created
Returns the date and time that the source file for the version was created.

@rtype: QDateTime
@return: The date and time that the source file for this version was created
@see: L{setCreated()}
----------
GeoEntityVersion.createdChanged
This is emitted when the created date details change for the version.

@type  NewCreated: QDateTime
@param NewCreated: The new date for the created field
@rtype: None
----------
GeoEntityVersion.creator
Returns information about the creator of the version.

This can be the creator's name, or any other desired information.

@rtype: str
@return: Information about the creator of the version
@see: L{setCreator()}
----------
GeoEntityVersion.creatorChanged
This is emitted when the creator details change for the version.

@type  NewCreator: str
@param NewCreator: The new creator details
@rtype: None
----------
GeoEntityVersion.geometryCount
Returns the count of geometries that are contained within a version.

When geometries are merged together, they could either exist as a single geometry (if the merge type is set to be SINGLE_MESH) or still as several ones (in the case of JUST_MERGE_NODES). In any case, this is managed internally by Mari and the user doens't have access to that information; this funciton returns the count of geometries that were merged together.

@rtype: int
@return: Count of geometries contained in a version
----------
GeoEntityVersion.load
Loads the version from file.

The file path should be set using L{setPath()} before calling this method. Any settings required for loading should also be provided beforehand using L{setSettingsString()}.

If the version is already loaded, this will clear it and reload from the file.

@rtype: bool
@return: True if the version was loaded correctly, or False otherwise.
----------
GeoEntityVersion.loaded
This is emitted after the data for the version has been loaded.

@rtype: None
----------
GeoEntityVersion.meshPaths
Returns the paths used to create the version, when there are multiple mesh source files.

@rtype: list of str
@return: The file paths that the version was loaded from
@see: L{setMeshPaths()}
----------
GeoEntityVersion.modified
Returns the last modified date and time of the source file for the version.

@rtype: QDateTime
@return: The date and time that the source file for this version was last modified
@see: L{setModified()}
----------
GeoEntityVersion.modifiedChanged
This is emitted when the modified date changes for the version.

@type  NewModified: QDateTime
@rtype: None
----------
GeoEntityVersion.name
Returns the name of the version.

@rtype: str
@return: The name of the version
@see: L{setName()}
----------
GeoEntityVersion.nameChanged
This is emitted when the name of the version is changed.

@type  NewName: str
@param NewName: The new name of the version
@rtype: None
----------
GeoEntityVersion.patchList
Returns a list of the different valid UV patches that make up this GeoEntityVesion.

Geometry may be broken into GeoVersions with multiple UV patches. Each UV patch occupies a single integer square in UV space. Each patch may have a name, associated metadata, and locked or hidden or valid status.

Note however that these indices do not necessarily map directly to UDIMs, as some UDIMs may be unused, and there will not be any corresponding spaces left empty in the array. To be sure of the UDIM of a patch, call the L{GeoPatch.udim()} method.

@rtype: list of  L{GeoPatch}
@return: A list of the UV patch objects associated with this geometry version
@note: This method returns the list of patches from this L{GeoEntityVersion}. See L{GeoEntity.patchList()}
----------
GeoEntityVersion.path
Returns the path used to create the version.

@rtype: str
@return: The file path that the version was loaded from
@see: L{setPath()}
----------
GeoEntityVersion.pathChanged
This is emitted when the path changes for the version.

@type  NewPath: str
@param NewPath: The new path for the version
@rtype: None
----------
GeoEntityVersion.setCreated
Sets the file creation date and time for this version.

@type  CreatedDate: QDateTime
@param CreatedDate: The date and time that the source file for the version was created
@rtype: None
@see: L{created()}
----------
GeoEntityVersion.setCreator
Sets the name of the creator of the version.

This can be the creator's name, or any other desired information.

@type  Creator: str
@param Creator: Information about the creator of the version
@rtype: None
@see: L{creator()}
----------
GeoEntityVersion.setMeshPaths
Sets the file paths for this version, when there are multiple mesh source files.

@type  Paths: list of str
@param Paths: The paths that this version should be loaded from
@rtype: None
@see: L{meshPaths()}
----------
GeoEntityVersion.setModified
Sets the last modified date and time for the source file for the version.

@type  ModifiedDate: QDateTime
@param ModifiedDate: The date and time that the source file for this version was last modified
@rtype: None
@see: L{modified()}
----------
GeoEntityVersion.setName
Sets the name for the version.

@type  NewName: str
@param NewName: The new name for the version
@rtype: None
@raise ValueError: Raised if the version name is not unique (i.e. if the parent L{GeoEntity} already has a version with the specified name)
@see: L{name()}
----------
GeoEntityVersion.setPath
Sets the file path for this version.

@type  Path: str
@param Path: The path that this version should be loaded from
@rtype: None
@see: L{path()}
----------
GeoEntityVersion.setSettings
Sets the settings used to load the version.

These are passed into the geometry loader.

@type  NewSettings: variant
@param NewSettings: A dictionary that maps string setting names to string setting values
@rtype: None
@see: L{settings()}
----------
GeoEntityVersion.setSettingsString
Sets the settings used to load the version.

These are passed into the geometry loader.

The string should be a list of name-value pairs collapsed into a single string. The pairs should be of the form "name=value", with each pair separated by "|" - for example: "setting1=5|setting2=8"

This format can be produced from a Python dictionary using code such as the following:

C{"|".join([str(key) + "=" + str(value) for (key, value) in settings_dict.iteritems()])}

@type  SettingsString: str
@param SettingsString: A list of name-value pairs collapsed into a single string.
@rtype: None
@see: L{settingsString()}, L{settings()}
----------
GeoEntityVersion.settings
Returns the settings used to create the version.

These settings can control things like SUB-D level, proxy creation, etc. The values accepted by geometry loaders are different for each loader.

@rtype: variant
@return: A map of name-value pairs that are passed into the geometry loader when loading the version.
@see: L{setSettings()}
----------
GeoEntityVersion.settingsString
Returns the settings used to create the version as a string.

@rtype: str
@return: The settings for this version as a string. This is a list of name-value pairs collapsed into a single string, as described in L{setSettingsString()}.
@see: L{settings()}, L{setSettingsString()}
----------
GeoManager
Manages geometry objects in the project.

Mari can handle many 3D objects at once. Each 3D object or entity can have multiple geometric representations.

This interface allows the user to query the internal object lists, add objects, remove objects, and generally build up a scene. 
B{Example Code}

C{# This examples obtains the current geometry object}

C{import mari}

C{current_object = mari.geo.current()}
----------
GeoManager.addLocator
Add a locator to the project.

C{# Add root level locator}

C{>>> import mari}

C{>>> mari.geo.addLocator()}

C{# Add another locator, parented to the locator created previously}

C{>>> mari.geo.addLocator(True)}

@type  AddAsChildToSelectedObject: bool
@param AddAsChildToSelectedObject: Flag to speficy whether the locator is to be created at the root level or parented to the currently selected object in the objects palette.
@rtype: L{LocatorEntity}
@return: The newly-created locator.
----------
GeoManager.current
Returns the currently selected geoentity object.

@rtype: L{GeoEntity}
@return: The currently selected geoentity object.
@see: L{setCurrent()}
----------
GeoManager.currentLocator
Returns the currently selected locator object.

@rtype: L{LocatorEntity}
@return: The currently selected locator object.
----------
GeoManager.duplicateCurrentGeoEntity
Duplicates the current selected L{GeoEntity} in the project.

@type  DuplicateShaderNetwork: bool
@param DuplicateShaderNetwork: Toggles whether to duplicate the shader network of the selected object as well.
@rtype: None
@raise RuntimeError: Raised if no project is opened.
----------
GeoManager.duplicateGeoEntity
Duplicates an input L{GeoEntity} in the project.

@type  Object: L{GeoEntity}
@param Object: The object to duplicate.
@type  DuplicateShaderNetwork: bool
@param DuplicateShaderNetwork: Toggles whether to duplicate the shader network of the selected object as well.
@rtype: None
@raise RuntimeError: Raised if no project is opened.
----------
GeoManager.entityAdded
This is emitted after a new geometry object has been added to the project.

This only includes manual addition (by menu or by script), however. It will not be emitted when a project is loaded.

@type  pNewEntity: L{GeoEntity}
@param pNewEntity: The newly-added geometry object
@rtype: None
----------
GeoManager.entityMadeCurrent
This is emitted after a new geometry object becomes current.

@type  pNewCurrent: L{GeoEntity}
@param pNewCurrent: The new current geometry object
@rtype: None
----------
GeoManager.entityRemoved
This is emitted after a new geometry object has been removed from the project.

This only includes manual removal (by menu or by script), however. It will not be emitted when a project is closed.

@type  pOldEntity: L{GeoEntity}
@param pOldEntity: The geometry object that was just removed
@rtype: None
----------
GeoManager.find
Finds a geometry object from the scene, given the name of the entity.

@type  Name: str
@param Name: The name of the entity to look for
@rtype: L{GeoEntity}
@return: The requested geometry object if found, or None otherwise
@see: L{get()}
----------
GeoManager.geometryOperationList
Get a list of the geometry operations, registered by entity image manager.

@rtype: list of  L{GeometryOperation}
@return: A list of geometry operations.
----------
GeoManager.get
Gets a geometry object from the scene, given the name of the entity.

@type  Name: str
@param Name: The name of the entity to look for
@rtype: L{GeoEntity}
@return: The requested geometry object
@raise ValueError: Raised if no entity with the given name was found.
@see: L{find()}
----------
GeoManager.getAnimationTakes
Returns the names of animation takes from a file.

@type  Path: str
@param Path: The file path to query
@rtype: list of str
@return: a list of takes
@raise RuntimeError: Raised if the file cannot be loaded by Mari or we cannot have any take information
----------
GeoManager.getDefaultAnimationTake
Returns the name of the default take.

@type  Path: str
@param Path: The file path to query
@rtype: str
@return: name of default take
@raise RuntimeError: Raised if the file cannot be loaded by Mari or we cannot have any take information
----------
GeoManager.getFileContents
Returns a list of objects, name and type, that can be loaded from a file.

@type  Path: str
@param Path: The file path to query
@rtype: variant
@return: A list of objects that can be loaded, their names and types
@raise RuntimeError: Raised if file cannot be loaded by Mari or we cannot get the contents of the file
----------
GeoManager.getFileFrameRange
Returns the start and end frames of a file.

@type  Path: str
@param Path: The file path to query
@type  Take: str
@param Take: Optional take used to query specific animation range if the file supports the concept of takes
@rtype: list of  int
@return: a list of two items, which are the start and end frames
@raise RuntimeError: Raised if the file cannot be loaded by Mari or the take is invalid or we cannot get a frame range from the file
----------
GeoManager.importFromArchive
Import the L{GeoEntity} from the geometry archive given in L{DirPath}.

@type  DirPath: str
@param DirPath: The directory path from which the L{GeoEntity} is loaded.
@rtype: L{GeoEntity}
----------
GeoManager.list
Returns a list of all objects in the project.

@rtype: list of  L{GeoEntity}
@return: All objects in the project.
----------
GeoManager.listLocators
Returns a list of all locators in the project.

@rtype: list of  L{LocatorEntity}
@return: All locators in the project.
----------
GeoManager.load
Loads the given file as new geometry.

Requests for object loading are routed to the correct plugin based on file extension.

The settings for the geometry load can be controlled by the function parameter L{Options}. This parameter should be a dictionary, with strings for keys, and values. The geometry loader plug-in that interprets the mesh to be loaded will receive the options passed in here that it recognises, and the others will be ignored. A list of the commonly used settings is as follows: 
  - "MappingScheme" - geometry mapping scheme (type MeshOptions).
  - "MultipleGeometries" - how to handle multiple geometries in a single object (type MultipleGeometryOptions).
  - "PtexFaceSizeScheme" - L{Ptex} specific: scheme to use for face texture size calculations (type PtexFaceSizeScheme).
  - "PtexFaceSize" - L{Ptex} specific: size to use with the scheme above (type int).
  - "PtexImageFormat" - L{Ptex} specific: image data format (type PtexFormat).
  - "PtexFaceColor" - L{Ptex} specific: color to clear faces to (type L{Color}).
  - "PtexImportFilename" - L{Ptex} specific: import an existing L{Ptex} file onto the .obj geoemtry (type string).
  - "PtexShowCreationDialog" - L{Ptex} specific: show the L{Ptex} creation dialog after mesh loading (type Bool; default is False from Python).
  - "EachMeshCreatesObject" - each mesh can either create an Object or each be a geometry within a single Object. This is currently L{Ptex} specific. (type Bool; default is True).
  - "MergeType" - merging of geometries can be either single-mesh or just-merge-nodes (type mari.GeoManager.MergeType).
  - "MergeSelectionGroupWithSameNameType" - merging of face selection groups that have the same name (type mari.GeoManager.MergeSelectionGroupWithSameNameType) - default is mari.GeoManager.MERGESELECTIONGROUP_DO_NOT_MERGE
  - "CreateSelectionSets" - specify whether to create selection sets from face groups (type L{CreateSelectionSetOptions}) - default value is mari.GeoManager.CREATE_FROM_FACE_GROUPS
  - "FrameOffset" - specify the start frame in Mari's timeline to import the geometry (default value is zero).
There are two special options ('CreateChannels' and 'ImportChannels', with a list of L{ChannelInfo} as values) that can optionally be passed in to allow the user to create/import channels when loading geometry; not passing these options results in default channels (diffuse) being created. Example usage of these would be as follows:

>>> import mari
>>> # Example code on loading geometry and creating a channel
>>> mari.geo.load('/tmp/test.abc', {'name':'test', 'CreateChannels':[mari.ChannelInfo('exampleChan', 2048, 2048, 16),]})
>>>
>>> # Example code to load a geometry and import a channel
>>> importChannel = mari.ChannelInfo('test1', 2048, 2048, 16)
>>> importChannel.setPath('/tmp')
>>> importChannel.setFileTemplate('/$PATH/test.tif')
>>> mari.geo.load('/tmp/test.abc', {'name':'test', 'ImportChannels':[importChannel,]})

When used in combination with the C API, this allows users to pass in parameters with specified names to a custom geometry loader. See the C API documentation for further details.

The L{Options} parameter can also be provided as a list of strings in I{"name=value"} format. This usage is deprecated, but is provided for backwards compatibility.

>>> # Assuming the geometry loader for the 'abc' format understands the parameters 'size' and 'name'
>>> import mari
>>> try:
...     mari.geo.load('/tmp/test.abc', {'size': 5, 'name': 'test'})
... except:
...     pass

@type  Path: str
@param Path: The path to the file to be loaded. A file may contain multiple entities.
@type  Options: variant
@param Options: This is an optional parameter which can be used to pass options to the file loader. L{Options} should ideally be provided in dictionary format, as described above.
@type  ObjectsToLoad: variant
@param ObjectsToLoad: This is a list of objects to load from the file. Each item of the list is a dictionary that contains the name of the objects to load and various geometry import flags to specify whether the children of the current object are to be selected and whether they are to be merged as well. children underneath the current node onto 1 entity.
@type  LoadAsChild: bool
@param LoadAsChild: A flag to indicate whether the newly added geometry will be parented to the currently selected object in the project or not.
@rtype: list of  L{GeoEntity}
@return: A list of the entities loaded from the given file. This list may be empty if the load failed.
@raise RuntimeError: Raised if no project is currently open, or if there was a general error with loading such as missing importers or channel creation failure.
@raise ValueError: Raised if the input file path is invalid.
@raise ValueError: Raised if there was a problem interpreting the options.
@deprecated: Please pass the Options parameter in C{{'name': value}} dictionary format, instead of the old C{['name=value']} list format.
----------
GeoManager.names
Returns a list of the names of the geometry objects in the current project.

@rtype: list of str
@return: A list of the names of the geometry objects in the current project
----------
GeoManager.remove
Removes a given entity from the project.

The given entity and all child entities will be removed and placed onto the undo stack.

You cannot remove the last entity from a project.

@type  Name: str
@param Name: The name of the entity to be removed
@rtype: bool
@return: Always True. On failure, it raises an exception. I{(See below - please do not use this return value)}
@raise RuntimeError: Raised if no project was open, or if only one object remains in the project.
@raise ValueError: Raised if no object with the given name was found.
@deprecated: Please do not use the return value of this function. It will be removed in a future version, because it is unnecessary.
----------
GeoManager.setCurrent
Sets the currently selected object.

@type  Object: L{GeoEntity}
@param Object: The object to make current
@rtype: None
@raise ValueError: Raised if an invalid object was provided.
@raise RuntimeError: Raised if no project was open.
@see: L{current()}
----------
GeoManager.supportedReadFormats
Returns a string list of all object formats supported for reading.

The list returned will be all unique lower case strings in ascending alphabetic order.

@rtype: list of str
@return: A string list of all object formats supported for reading - e.g. ['obj, 'abc']
----------
GeoPatch
A geometry patch is section of a L{GeoEntity} that occupies a single UV square.

Geometry can be broken into multiple patches. Each patch may have multiple textures associated with it.

An L{ImageSet} contains one texture for each L{GeoPatch} in a L{GeoEntity}.

Patches may be named, and can have associated metadata. They may also be locked or hidden.

You can access geometry patches through a L{GeoEntity} - for example: C{mari.geo.current().patchList()} B{Example Code}

>>> # This examples obtains the patch with UDIM 1001 of current geometry object
>>> import mari
>>> patch_1001 = mari.geo.current().patch(0)
----------
GeoPatch.isLocked
Returns the locked status of the patch.

@rtype: bool
@return: True if the patch is locked, or False (the default) otherwise
@see: L{setLocked()}
----------
GeoPatch.isSelected
Indicates whether the patch is currently selected.

@rtype: bool
@return: True if the patch is selected, or False if not
----------
GeoPatch.isValid
Indicates whether the patch is valid.

For a patch to be valid, its U and V location must be greater than zero. Mari does not support negative UVs which lead to invalid patches. If a patch is invalid, L{uvIndex()} may not return a useful index and L{udim()} will return a value less than 1001. Invalid patches may not have images associated with them.

@rtype: bool
@return: True if the patch is valid, or False if not.
@see: L{uvIndex()}, L{udim()}
----------
GeoPatch.isVisible
Returns the visible status of the patch.

@rtype: bool
@return: True if the patch is visible; False if hidden
----------
GeoPatch.name
Returns the name of the patch.

@rtype: str
@return: The name of this patch
@see: L{setName()}
----------
GeoPatch.setLocked
Changes the locked state of the patch.

Patches may be locked to prevent painting on or applying filters to them. They may still be exported when locked.

@type  Locked: bool
@param Locked: The new locked status of the Patch. If True, the patch will be locked and cannot be edited
@rtype: None
----------
GeoPatch.setName
Sets the name of the patch.

The name is used in the UV view and the patch view.

The default name for a patch is its UDIM.

@type  Name: str
@param Name: The new name for the patch
@rtype: None
@see: L{name()}
----------
GeoPatch.setSelected
Changes the selection state of the patch.

@type  Selected: bool
@param Selected: True to select the patch, or False to deselect it
@rtype: None
----------
GeoPatch.setVisibility
Shows or hides the patch.

@type  Visible: bool
@param Visible: True to show the patch, or False to hide it
@rtype: None
----------
GeoPatch.u
Returns the U location of the patch.

@rtype: int
@return: The integer U coordinate of the lower left corner of the patch in UV space
----------
GeoPatch.udim
Returns the UDIM of the patch.

UDIM values identify the integer position of a patch in a channel. Each patch represents a square of dimensions 1x1 in U-V space with integer boundaries. There may be up to ten patches across, and any number of patches upwards - so the U index of a patch must be in the range [0, 9], and the V index can be zero or any positive integer.

The UDIM value for a patch can be calculated using the following formula:

C{udim = 1001 + u + (10 * v)}

For example, the UDIM of the bottom left patch, which represents the U-V space region (0, 0) to (1, 1), will be 1001. The next patch to the right of that will have UDIM 1002, and the patch directly above the bottom left will be 1011. If there are ten patches across, the one on the bottom row at the far right, representing the region (9, 0) to (10, 1), will have UDIM 1010.

The U index limit of ten is currently hard-wired.

@rtype: int
@return: The UDIM of the patch, as specified above
----------
GeoPatch.uv
Returns the UV location of the patch.

@rtype: QPoint
@return: The integer U and V coordinates of the lower left corner of the patch in UV space
----------
GeoPatch.uvIndex
Returns the UV index of the patch.

This provides a 0-based index of the patch, which can be used with L{ImageSet.image()} to find the image in a channel that will be applied to the patch.

The UDIM of the patch will be this value plus 1001.

@rtype: int
@return: The integer UV index of the patch.
----------
GeoPatch.v
Returns the V location of the patch.

@rtype: int
@return: The integer V coordinate of the lower left corner of the patch in UV space
----------
GeometryOperation
This encapsulates a geometry operation that can be performed on a Geo Entity.

You can access the registered geometry operations through the EntityManager - for example:

C{mari.geo.geometryOperationList()}
----------
GeometryOperation.execute
Executes the geometry operation for the current frame.

@type  Operation: str
@param Operation: The sub-operation to execute.
@type  GeometryEntity: L{GeoEntity}
@param GeometryEntity: The L{GeoEntity} that we want to query info for.
@type  GeoVersion: L{GeoEntityVersion}
@param GeoVersion: The Version,within the Geo Entity, that we want to query.
@type  QuerySubdivisionMesh: bool
@param QuerySubdivisionMesh: Flag to toggle querying subdivision meshes or original meshes.
@type  SubdivisionLevel: int
@param SubdivisionLevel: Subdivision level to query for subdivision meshes.
@type  ExtraParams: variant
@param ExtraParams: Extra parameters for the image operation.
@rtype: bool
@return: The result of the operation.
----------
GeometryOperation.name
Returns the name of the operation.

@rtype: str
@return: The name of the operation.
----------
GeometryOperation.operationDescription
Returns the description of one of the operations.

@type  Name: str
@param Name: The sub-operation whose description we require.
@rtype: str
@return: The description corresponding to the operation.
----------
GeometryOperation.supportedOperations
Returns the supported operations by this object.

@rtype: list of str
@return: The supported operations.
----------
GraphLayer
Graph layers contain an image for each patch that can be painted directly.

You can access all types of layers from their containing L{Channel} objects - for example: C{channel.layerList()}

You can check for L{GraphLayer} objects by calling L{Layer.isGraphLayer()}:

This examples shows how to create a graph layer and checks if it's a graph layer

>>> import mari
>>> channel = mari.geo.current().currentChannel()
>>> graphLayer = channel.createGraphLayer("Test")
>>> graphLayer.isGraphLayer()
True

This examples shows how to create a Perlin node in the graph layer

>>> childNodeGraph = graphLayer.nodeGraph()
>>> perlin = childNodeGraph.createNode("Procedural/Noise/Perlin")
----------
GraphLayer.nodeGraph
Returns the L{NodeGraph} object contained in this layer.

@rtype: L{NodeGraph}
@return: Return the L{NodeGraph} object contained in this layer.
@raise SystemError: Raised if the layers node graph cannot be found.
----------
GroupLayer
Group layers contain a stack of other layers to be processed as a separate unit.

You can access all types of layers from their containing L{Channel} objects - for example: C{channel.layerList()}

You can check for L{GroupLayer} objects by calling L{Layer.isGroupLayer()}:

B{Example Code}

>>> #This example finds group layers in the current channel.
>>> import mari
>>> group_layers = []
>>> channel = mari.geo.current().currentChannel()
>>> for layer in channel.layerList():
...     if layer.isGroupLayer():
...         group_layers.append(layer)
----------
GroupLayer.flattenLayerGroup
Flattens the layer group to a single layer.

@rtype: None
----------
GroupLayer.layerStack
Returns the layer stack that is grouped within this layer.

@rtype: L{LayerStack}
@return: Returns a layer stack
----------
GroupNode
Represents an group node.

A L{GroupNode} is a node that contains its own sub L{NodeGraph}. It can be used to organize nodes.

It is possible to promote parameters of the member nodes as parameters of L{GroupNode} itself. The promoted parameters are called knobs.

B{Example Code}

This example shows how to obtain a group node from the node graph of the current geo entity and print the names of the member nodes.

>>> import mari
>>> nodeGraph = mari.geo.current().nodeGraph()
>>> for node in nodeGraph.nodeList():
...  if isinstance(node, mari.GroupNode) and not node.hasTag('_shader'):
...    childNodeGraph = node.childNodeGraph()
...    for memberNode in childNodeGraph.nodeList():
...      nodeName = memberNode.nodeName()

This example shows how to create a group node and create a new node inside the group node.

>>> group = nodeGraph.createNode("Misc/Group")
>>> subNodeGraph = group.childNodeGraph()
>>> merge = subNodeGraph.createNode("Layer/Merge")

This example shows how to create a group node by passing in what nodes to group.

>>> mergeA = nodeGraph.createNode("Layer/Merge")
>>> mergeB = nodeGraph.createNode("Layer/Merge")
>>> group = nodeGraph.groupNodes([mergeA,mergeB]);

This example shows how create a knob in the group node

>>> group.createKnob("BAmount",mergeB,"Amount","B Amount")

This example shows how to create a gizmo and register it for reusing in a node graph.

>>> # Get the node graph of the current object
>>> ng = mari.geo.current().nodeGraph()
>>>
>>> # Create UV node that outputs UV coordinates
>>> uv = ng.createNode("Geometry/UV")
>>>
>>> # Create a cloud fractal noise node
>>> cloud = ng.createNode("Procedural/Fractal/Cloud")
>>>
>>> # Connect UV to the position of cloud so that the cloud pattern is generated over UV space
>>> cloud.setInputNode("Position",uv)
>>>
>>> # Group UV and cloud into a group node
>>> group = ng.groupNodes([uv,cloud])
>>>
>>> # Create gizmo knobs, Size and Roughness
>>> group.createKnob("CloudSize",cloud,"Size","Cloud Size")
>>> group.createKnob("CloudRoughness",cloud,"Roughness","Cloud Roughness")
>>>
>>> # Save the group node out as an .mng file
>>> ng.save("/tmp/UvCloud.mng",[group])

The saved group node can be automatically registered to appear in Mari by placing the file under Mari/Gizmos directory:

~/Mari/Gizmos/Procedural/UVCloud.mng (On Mac and Linux)

C:\Users\<user_name>\My Documents\Mari\Gizmos\Procedural\UVCloud.mng (On Windows)
----------
GroupNode.childNodeGraph
Returns the node graph this group node contains.

@rtype: L{NodeGraph}
@return: The L{GroupNode} object this node contains.
@raise RuntimeError: Raised if the child node graph cannot be found.
----------
GroupNode.createKnob
Creates a knob linked to a node attribute.

@type  KnobName: str
@param KnobName: name of the knob to create. It must contain only alphabets, numbers and underscores.
@type  TargetNode: L{Node}
@param TargetNode: L{Node} object to link the new knob to
@type  TargetAttributeName: str
@param TargetAttributeName: The attribute name of the L{TargetNode} to link the new knob to
@type  PrettyKnobName: str
@param PrettyKnobName: The pretty name of the knob to be created
@rtype: None
@raise RuntimeError: Raised if the knob cannot be created.
----------
GroupNode.deleteKnob
Deletes a knob linked to the node attribute.

@type  KnobName: str
@param KnobName: name of the knob
@type  TargetNode: L{Node}
@param TargetNode: L{Node} object of the link to be deleted
@type  TargetAttributeName: str
@param TargetAttributeName: The attribute name of the L{TargetNode} of the link to to be deleted
@rtype: None
@raise RuntimeError: Raised if the knob cannot be created.
----------
GroupNode.isGroupNode
Returns whether this node is an L{GroupNode}.

@rtype: bool
@return: Whether this node is an L{GroupNode}
----------
GroupNode.renameKnob
Renames a knob.

@type  OldName: str
@param OldName: the name of the knob to change
@type  NewName: str
@param NewName: the new name of the knob
@rtype: None
----------
History
Provides access to the Mari editing history, or undo stack.

The history is only available for the currently open project, and will be lost when the project is closed. Operations cannot be performed when there is no project open. 
B{Example Code}

>>> # This example calls undo() to undo the last change in the undo history
>>> import mari
>>> mari.history.undo()
True
----------
History.clear
Clears the undo history, without undoing any operations.

This permanently clears the undo history, without undoing any of the operations. Effectively there will be no change to the current state of the project other than that none of the previous operations can be undone (or redone) afterwards.

However, clearing the undo history will remove references to previous data that are no longer needed, and hence free space in memory and on disk when garbage collection is performed.

As undo data will be destroyed, this method optionally displays a confirmation dialog.

This function raises an exception if it is called when the current project requires saving. This is because clearing history on an unsaved project would invalidate any old data from the saved state that has since been changed. If the user then closed the project without saving, some of the data from that saved state might no longer be valid. This could appear as project corruption, so the exception avoids that risk.

@type  ShowDialog: bool
@param ShowDialog: If set to True, Mari will display a confirmation dialog
@rtype: None
@raise RuntimeError: Raised if there is no project open, or if the current project requires saving.
@warning: Older versions of Mari did not raise an exception when the function was called on a project that required saving. Please ensure that any relevant scripts are up to date.
----------
History.isMacroActive
Indicates whether history items are currently being grouped into a macro.

This method will return True if L{startMacro()} has been called without a corresponding L{stopMacro()}.

Many internal functions also start and stop macros, and this function will also return True if called while one of those macros is active. This can happen when running custom code in response to a signal, for example.

@rtype: bool
@return: True if history items are being grouped into a macro, or False otherwise
@raise ValueError: Raised if there is no project open.
----------
History.redo
Redoes the most recently undone action in the history.

@rtype: bool
@return: True if the redo was performed, or False when there are no more items to redo
@raise RuntimeError: Raised if there is no project open.
@see: L{undo()}
----------
History.startMacro
Starts grouping history items into a new macro.

Mari allows grouping of history items into macros. A macro is a block of actions that appears as one item in the history and can be done or redone as a single unit. L{startMacro()} I{must} be followed by L{stopMacro()}; if not, the behavior is undefined.

@type  MacroName: str
@param MacroName: The name of the new macro block. This name will appear in the history view.
@rtype: None
@raise RuntimeError: Raised if there is no project open.
@raise ValueError: Raised if the macro name is empty.
@see: L{isMacroActive()}
----------
History.stopMacro
Stops the current macro grouping.

This ends the group of history items begun by L{startMacro()}.

@rtype: None
@raise RuntimeError: Raised if there is no project open, or if no macro is currently active.
@see: L{isMacroActive()}
----------
History.undo
Undoes the last action in the history.

@rtype: bool
@return: True if the undo was performed, or False when there are no more items to undo
@raise RuntimeError: Raised if there is no project open.
@see: L{redo()}
----------
Image
These objects contain individual 2D images.

You can access images either from an L{ImageSet} or through the L{ImageManager} - for example:

C{mari.images.list()}

B{Example Code}

>>> # This example obtains the image of UDIM 1001 from the current layer of the current channel
>>> import mari
>>> layer = mari.geo.current().currentChannel().currentLayer()
>>> if layer.isPaintableLayer():
...     image_set = layer.imageSet()
...     image = image_set.image(0)

>>> # This examples opens an image through ImageManager and obtains the Image object
>>> import mari
>>> import os
>>> imagePath = os.path.join(mari.resources.path(mari.resources.IMAGES),"NoThumb.png")
>>> image = mari.images.load(imagePath)
----------
Image.aboutToClose
This is emitted just before the image is closed.

@rtype: None
----------
Image.aboutToExport
This is emitted when the user is about to export the image.

@type  Path: str
@param Path: The path the image will be exported to
@rtype: None
----------
Image.aboutToImport
This is emitted when the user is about to import into the image.

@type  Path: str
@param Path: The path the image will be imported from
@rtype: None
----------
Image.close
Closes the image, removing it from the image manager.

If the image is open in the image manager, it will be closed and removed. Not all images can be closed in this way. If the image is a member of an image set, the image set "owns" the image and will not allow it to be closed. To remove such an image, remove the image set that owns it.

This method can be called on all images, but images that are not in the image manager will not be closed, and an exception will be raised.

@rtype: None
@raise RuntimeError: Raised if the image is not owned by the image manager and cannot be closed.
@note: If this function successfully closes the image, the image object will become invalid.
----------
Image.colorspaceConfig
Returns the colorspace configuration of the image.

@rtype: L{ColorspaceConfig}
@return: The colorspace configuration.
@see: L{setColorspaceConfig()}
----------
Image.colorspaceConfigChanged
This is emitted after the colorspace config is modified for this object.

@type  Config: L{ColorspaceConfig}
@rtype: None
----------
Image.convertDepth
Converts the depth of the image.

@type  Depth: L{Image.Depth}
@param Depth: The new bit depth for the image.
@rtype: None
----------
Image.copyFrom
Copies the contents of another image into this one.

Mari allows very quick copying and duplication of image data. This method allows the contents of another image to be copied into this one. The image must have the same dimensions (width and height) and format as the source image, otherwise an exception will be raised. As the API does not yet allow you to alter the format of an image directly, this method is useful only when the images already have the same format (e.g. images from the same L{ImageSet}). This operation is effectively free in terms of memory usage and the user should not worry about copying large amounts of data using this method.

@type  SourceImage: L{Image}
@param SourceImage: The image to copy from
@rtype: None
@raise ValueError: Raised if the source or destination image is invalid, or if they are both the same image object, or if the destination image does not have the same dimensions and format as the source image.
----------
Image.depth
Returns the bit depth of the image.

@rtype: L{Image.Depth}
----------
Image.depthAsInternalFormat
Returns the OpenGL integer representation of Internal Format of the given L{Depth}.

@type  Depth: L{Image.Depth}
@param Depth: The L{Depth} that corresponds to the returned Internal Format.
@rtype: int
@return: The Internal Format as the OpenGL integer
----------
Image.exported
This is emitted after the image is exported.

@type  Path: str
@param Path: The path the image was exported to
@rtype: None
----------
Image.filePath
Returns the path to the file that the image was loaded from.

This path will be valid for images loaded from disk into the image manager. Images that are contained in channels will have a blank file path.

@rtype: str
@return: The path that the image was loaded from, or a blank string if not available
@see: L{lastImportPath()}, L{lastExportPath()}
----------
Image.fileSpace
Returns the file space the image will import and export data as.

@rtype: L{Image.FileSpace}
@see: L{setFileSpace()}
----------
Image.fill
Fills the image entirely with a given color.

This function is the same as L{setUniformColor()}.

@type  FillColor: L{Color}
@param FillColor: The color to fill the patch with. RGB images will ignore the alpha component.
@rtype: None
@raise ValueError: Raised if the color provided was invalid.
@see: L{uniformColor()}, L{setUniformColor()}, L{isUniform()}
----------
Image.hash
Returns a unique identifier for this image.

Mari maintains hashes of images for internal book-keeping. These hashes are assumed to be universally unique (256bit skein hash). These hashes can be used to determine if an image has changed since some given checkpoint. A different hash means a different image.

The hash of an image is calculated from its resolution (which determines the number of tiles it uses), bit depth, and tile data. Any metadata for the image is not included. Multiple images that store the same data will have the same hash and reference the same underlying data block, which means that the L{DDI} can save memory and disk space by storing the same block of data only once.

@rtype: str
@return: A hash string that uniquely identifies this version of this image, or an empty string on failure.
----------
Image.height
Returns the height of a mip-map level in the image.

@type  MipMapLevel: int
@param MipMapLevel: Mip-map level, in the range [0 to Count - 1], where 0 is the original size
@rtype: int
@return: The height of the mip-map level in pixels
@raise ValueError: Raised if the mip-map level was out of range.
----------
Image.imported
This is emitted after the image is imported.

L{Path} The path the image was imported from

@type  Path: str
@rtype: None
----------
Image.isUniform
Returns whether the given image is all a single color.

Mari makes storing large uniform color images very efficent internally. It is often useful to know if an image is all a single color on export.

This method indicates whether the image is uniform - i.e. all a single color. This can help to decide whether an image should be exported.

@rtype: bool
@return: True if this image is a uniform color, or False if it contains any pixels that are different colors.
@see: L{uniformColor()}, L{setUniformColor()}, L{fill()}
----------
Image.lastExportPath
Returns the last path the image was saved to.

@rtype: str
@return: The path that the image was last saved to. This will be an empty string if the image has not been saved yet
@see: L{lastImportPath()}, L{filePath()}, L{lastExportTime()}
----------
Image.lastExportTime
Returns the date and time at which the image was last exported.

@rtype: QDateTime
@return: The date and time of the last export, or an empty DateTime object if never exported
@see: L{lastExportPath()}
----------
Image.lastImportPath
Returns the path to the last file that was imported into the image.

@rtype: str
@return: The path of the last file imported into the image. This will be an empty string if nothing has been imported into the image
@see: L{lastImportTime()}, L{lastExportPath()}, L{filePath()}
----------
Image.lastImportTime
Returns the date and time at which the image was last imported.

@rtype: QDateTime
@return: The date and time of the last import, or an empty DateTime object if never imported
@see: L{lastImportPath()}
----------
Image.makeThumbnail
Makes a thumbnail image from the current image contents for use by the GUI.

@rtype: None
----------
Image.mipMapCount
Returns the number of mip-maps in the image.

@rtype: int
@return: The number mip-maps in the image
----------
Image.mostRelevantPath
Returns a best guess as to which file on disk represents this texture.

Mari keeps track of when files are imported and exported. It uses a basic heuristic to guess which file on disk represents a given Mari L{Image}.

The time and date of each import and export is recorded. If an image was imported more recently than Mari exported, the import image is presumed to be most relevant. If Mari exported more recently than importing, the exported version is presumed to be more relevant.

A couple of quick examples: 
  - Mari import from a.png
  - User paints some more detail
  - Mari exports to b.png
In this case, b.png is presumed to be most relevant and will be returned by this method. 
  - Mari exports to a.png
  - User paints some more detail
  - User decides they don't like the changes
  - Mari imports from a-version2.png
In this case, a-version2.png will be returned.

@rtype: str
@return: The most relevant path or and empty string if neither importing or exporting has occured
----------
Image.resize
Resizes the image.

@type  NewSize: QSize
@param NewSize: the desired size for the image.
@rtype: None
@raise ValueError: Raised if the size provided was invalid.
----------
Image.saveAs
Saves the image to the given file name.

The I{options} parameter can be used to pass options to the file writer, in dictionary format. For example:

C{img.saveAs('/tmp/test.jpg', {'IntegerSetting': 1, 'StringSetting': 'Hello'})}

These options are currently only used by custom image writers. Please refer to the C API documentation - specifically, the MriImageReaderPlugin type and the attribute system - for details of how to develop a plug-in and read the values passed into it from this function.

Saving may occur in the background. If this is enabled (via the BACKGROUND_EXPORT enum from L{SaveOptions}) then saveAs will return instantly and the image will be exported on a background thread.By default background exporting is disabled and saveAs will only return when the image has been exported. When exporting in the background, errors and exceptions may not be raised on failure to save. An example of using background export would be:

C{img.saveAs('/tmp/test.jpg', {}, mari.Image.BACKGROUND_EXPORT)}

When background exporting the source image is copied internally and can be closed or modified without disrupting the background job.

@type  FileName: str
@param FileName: The absolute path, file name, and extension to save the image to.
@type  Options: variant
@param Options: This is an optional parameter which can be used to pass options to the file writer. See above for details.
@type  SaveOpts: int
@param SaveOpts: Pass in a value other than the default to turn on an option, such as disabling "small uniforms". See L{SaveOptions}.
@rtype: None
@raise IOError: Raised if there is a problem saving the file.
@raise TypeError: Raised if the options parameter is not a dict.
----------
Image.setColorspaceConfig
Sets the colorspace configuration of the image.

@type  Config: L{ColorspaceConfig}
@param Config: The colorspace configuration.
@rtype: None
@raise ValueError: Raised if the colorspace configuration is invalid.
@see: L{colorspaceConfig()}
----------
Image.setFileSpace
Set the file space the image will import and export data as.

@type  FileSpace: L{Image.FileSpace}
@rtype: None
@see: L{fileSpace()}
----------
Image.setUniformColor
Fills the image entirely with the given color.

This function is the same as L{fill()}.

@type  pUniformColor: L{Color}
@param pUniformColor: The color to fill this patch with. RGB images will ignore the alpha component.
@rtype: None
@raise ValueError: Raised if the color provided was invalid.
@see: L{uniformColor()}, L{isUniform()}, L{fill()}
----------
Image.size
Returns the size of a mip-map level in the image.

@type  MipMapLevel: int
@param MipMapLevel: Mip-map level, in the range [0 to Count - 1], where 0 is the original size
@rtype: list of  int
@return: The size of the image in pixels, in the format: (width, height)
@raise ValueError: Raised if the mip-map level was out of range.
----------
Image.thumbnail
Get thumbnail.

@rtype: QImage
----------
Image.transform
Transform the image entirely with a given filter.

This function allows an image to be quickly tranformed with the given L{PostFilterCollection} object.

@type  Collection: L{PostFilterCollection}
@param Collection: A filter collection object.
@rtype: bool
@return: True on success
@raise ValueError: Raised if the input filter is invalid.
----------
Image.uniformColor
Returns the single color that fills the entire image, if applicable.

Storing large images that are uniform - i.e., consist entirely of a single color - is very efficient. This function returns that single color, for an image that is uniform.

@rtype: L{Color}
@return: The uniform color of the image
@raise RuntimeError: Raised if the image was not all of a single color.
@see: L{setUniformColor()}, L{isUniform()}, L{fill()}
----------
Image.width
Returns the width of a mip-map level in the image.

@type  MipMapLevel: int
@param MipMapLevel: Mip-map level, in the range [0 to Count - 1], where 0 is the original size
@rtype: int
@return: The width of the mip-map level in pixels
@raise ValueError: Raised if the mip-map level was out of range.
----------
ImageManager
Handles the images available in the application.

B{Example Code}

>>> # This examples opens an image through ImageManager and obtains the Image object
>>> import mari
>>> import os
>>> image_path = os.path.join(mari.resources.path(mari.resources.IMAGES),"NoThumb.png")
>>> image = mari.images.load(image_path)
----------
ImageManager.add
Adds the given image to the image manager view.

Mari maintains a set of reference images that the user can access. This method adds the given image to the set of reference images

@type  ImageToAdd: L{Image}
@param ImageToAdd: The image object to add
@type  Name: str
@param Name: The name of the image to be set to
@rtype: None
----------
ImageManager.addCategory
Add a new images' category to L{Image} Manager palette.

Categories are shown as tabs.

@type  CategoryName: str
@param CategoryName: Name of an added category.
@rtype: None
----------
ImageManager.addImage
Adds the given QImage to the image manager view.

Mari maintains a set of reference images that the user can access. This method adds the given QImage to the set of reference images

@type  ImageToAdd: QImage
@param ImageToAdd: The QImage object to add
@type  Name: str
@param Name: The name of the image to be set to
@rtype: L{Image}
@return: The new reference image stored in the image manager.
----------
ImageManager.beginImageLoading
This is emitted before image loading.

This signal can be used to detect when Mari is about to load one or more images.

@rtype: None
----------
ImageManager.categories
Get a list of all categories currently existing in L{Image} Manager palette.

@rtype: list of str
@return: List of all categories in L{Image} Manager palette.
----------
ImageManager.compressionList
Query the supported list of export compression methods, for a given image extension.

B{Example Code}

>>> # This examples queries the compression methods for exporting an exr image
>>> mari.images.compressionList("exr")

@type  Extension: str
@param Extension: The file extension, whose plugin to query for compression methods.
@rtype: list of str
@return: List of compression methods for the image export plugin.
----------
ImageManager.currentCategory
Get the current images' category in L{Image} Manager palette.

Categories are shown as tabs.

@rtype: str
@return: Name of the current images' category.
----------
ImageManager.defaultCompressionMethod
Query the default export compression method, for a given image extension.

B{Example Code}

>>> # This examples queries the default compression method for exporting an exr image
>>> mari.images.defaultCompressionMethod("exr")

@type  Extension: str
@param Extension: The file extension, whose plugin to query for the compression method.
@rtype: str
@return: The default compression method for the image export plugin.
----------
ImageManager.defaultImageFormat
Gets the default file format for given texture bit depth.

@type  BitDepth: L{Image.Depth}
@param BitDepth: The bit depth of an image.
@rtype: str
@return: A file format.
@raise RuntimeError: Raised if the bit depth is invalid.
@see: L{setDefaultImageFormat()}
----------
ImageManager.endImageLoading
This is emitted after image loading.

This signal can be used to detect when Mari has completed loading one or more images.

@rtype: None
----------
ImageManager.getImage
Finds an image in the image manager view.

Mari maintains a set of reference images that the user can access. This method opens an image from this set of reference images.

@type  Hash: str
@param Hash: The hash of the image to retrieve.
@rtype: L{Image}
@return: The image object if found. If not found, it returns None.
@raise ValueError: Raised if the specified hash was empty.
----------
ImageManager.handleProtocol
This is emitted when attempting to open image with unknown protocol.

@type  url: str
@rtype: bool
----------
ImageManager.imageLoaded
This is emitted when images are loaded.

@type  Img: L{Image}
@param Img: Newly loaded image.
@rtype: None
----------
ImageManager.imageOperationList
Get a list of the image operations, registered by the image manager.

@rtype: list of  L{ImageOperation}
@return: A list of image operations.
----------
ImageManager.list
Returns all of the currently open reference images.

@rtype: list of  L{Image}
@return: A list of all the currently open reference images
----------
ImageManager.load
Loads images from an image file into the image manager view.

Mari maintains a set of reference images that the user can access. This method opens an image into this set of reference images.

@type  Path: str
@param Path: The path to the image file to open.
@type  Name: str
@param Name: By default the name of the loaded image will be derived from the L{Path}. This optional parameter specifies a different name for the loaded image
@type  ConversionType: L{ImageColorSpaceConversionType}
@param ConversionType: This specifies the conversion for the loaded image; it's no conversion by default.
@type  AlphaProcessing: L{ImageAlphaProcessing}
@param AlphaProcessing: This specifies if the pixels are converted into a premultiplied alpha format; conversion is the default.
@rtype: list of  L{Image}
@return: A list of all the images from the file. There will be more than one image for layered image files.
@raise ValueError: Raised if the specified path was empty.
@raise IOError: Raised if there was an error loading the image.
@deprecated: This method will be removed in a future version. Please use L{open()} instead.
----------
ImageManager.open
Loads images from an image file into the image manager view.

Mari maintains a set of reference images that the user can access. This method opens an image into this set of reference images.

@type  Path: str
@param Path: The path to the image file to open.
@type  Config: L{ColorspaceConfig}
@param Config: The colorspace configuration to use. If none is given then a default configuration will be used.
@type  AlphaProcessing: L{ImageAlphaProcessing}
@param AlphaProcessing: This specifies if the pixels are converted into a premultiplied alpha format; conversion is the default.
@type  Name: str
@param Name: By default the name of the loaded image will be derived from the L{Path}. This optional parameter specifies a different name for the loaded image
@rtype: list of  L{Image}
@return: A list of all the images from the file. There will be more than one image for layered image files.
@raise ValueError: Raised if the specified path was empty, the colorspace configuration file is invalid, or the colorspaces are invalid.
@raise IOError: Raised if there was an error loading the image.
----------
ImageManager.registerProtocolHandler
Registers the given L{ImageProtocolHandler} object with associated protocol.

@type  Protocol: str
@param Protocol: the protocol name for the handler to handle
@type  Handler: L{ImageProtocolHandler}
@param Handler: the L{ImageProtocolHandler} object to handle the protocol
@rtype: bool
@return: ean indicating whether it was successful to register the handler
@note: L{ImageProtocolHandler}
----------
ImageManager.remove
Removes the given image from the image manager view.

Mari maintains a set of reference images that the user can access. This method removes the given image from the set of reference images

@type  ImageToRemove: L{Image}
@param ImageToRemove: The image object to remove
@rtype: None
@raise ValueError: Raised if the given image isn't in the image manager.
----------
ImageManager.removeCategory
Remove images of a chosen category and the category itself from L{Image} Manager palette.

Categories are shown as tabs.

@type  CategoryName: str
@param CategoryName: Name of the removed category.
@rtype: bool
@return: True, if the chosen category was successfully removed. False otherwise.
----------
ImageManager.saveImages
Saves a list of images to a file.

Mari supports saving images to a variety of formats. Some formats support saving multiple images as layers. Others only support single images. This function will save a list of images to a specified path.

If a non-layered format is chosen, the list must contain just one image.

If a layered format is chosen, the names of the layers are of the form 'Layer N' where N is the zero-based index of the image in the provided list. There may be other restrictions on each image forming a layer, depending on the file format.

@type  Images: list of  L{Image}
@param Images: A list containing the image(s) to save.
@type  Path: str
@param Path: The path to save the image file(s) to.
@rtype: bool
@return: Always True. On failure, it raises an exception.
@raise ValueError: Raised if the specified path was empty, or no Images were provided.
@raise IOError: Raised if there was an error saving the image.
----------
ImageManager.selectCategory
Select a current images' category in L{Image} Manager palette.

Categories are shown as tabs.

@type  CategoryName: str
@param CategoryName: Name of a selected category.
@rtype: bool
@return: True, if the chosen category exists and became selected. False otherwise.
----------
ImageManager.selected
Returns all of the currently open and selected reference images.

@rtype: list of  L{Image}
@return: A list of all the currently open and selected reference images
----------
ImageManager.setDefaultImageFormat
Set the default file format for given texture bit depth.

@type  Format: str
@param Format: The file format to set to.
@type  BitDepth: L{Image.Depth}
@param BitDepth: The bit depth of an image.
@rtype: None
@raise RuntimeError: Raised if the bit depth is invalid.
@see: L{defaultImageFormat()}
----------
ImageManager.setMetadata
Adds or modifies an item of metadata on the object.

If a metadata item with the given name exists already, its value will be updated. If not, a new one will be created.

@type  Name: str
@param Name: The name of the item
@type  Value: variant
@param Value: The value of the item
@rtype: None
@raise ValueError: Raised if the type of the value is not supported by the metadata system.
----------
ImageManager.supportedReadFormats
Returns a string list of all image formats supported for reading.

The list returned will be all unique lower case strings in ascending alphabetic order.

@rtype: list of str
@return: A string list of all image formats supported for reading - e.g. ['jpg, 'tif']
----------
ImageManager.supportedTextureSizeList
Returns a list of the supported texture sizes.

Mari supports power of two sized textures, with the exact list provided by this function. Textures within channels may be created at any of these sizes.

Note that only square textures are supported.

@rtype: list of  variant
@return: The supported texture sizes in pixels, in the format: ((width1, height1), (width2, height2)...)
----------
ImageManager.supportedTextureSizes
Returns a list of the supported texture sizes.

Mari supports power of two sized textures, with the exact list provided by this function. Textures within channels may be created at any of these sizes.

Note that only square textures are supported.

@rtype: list of  QSize
@return: A list of QSize objects that specify valid texture sizes
@deprecated: Please use L{supportedTextureSizeList()} instead of this function.
----------
ImageManager.supportedWriteFormats
Returns a string list of image formats supported for writing.

Supply an internal format value to retrieve only the write formats that can deal with that given internal format, or leave it as zero to return all of them.

The list returned will be all unique lower case strings in ascending alphabetic order.

@type  InternalFormat: uint
@rtype: list of str
@return: A string list of all image formats supported for writing - e.g. ['jpg, 'tif']
----------
ImageOperation
These objects are image operations that can be performed on a layer list.

You can access the registered image operations through the L{ImageManager} - for example:

C{mari.images.imageOperationList()}
----------
ImageOperation.execute
Executes the operation.

@type  Operation: str
@param Operation: The sub-operation to execute.
@type  Source: L{Image}
@param Source: The image on which to execute the operation.
@type  ExtraParams: variant
@param ExtraParams: Extra parameters for the image operation.
@rtype: bool
@return: The result of the image operation.
----------
ImageOperation.name
Returns the name of the operation.

@rtype: str
@return: The name of the operation.
----------
ImageOperation.operationDescription
Returns the description of one of the operations.

@type  Name: str
@param Name: The sub-operation whose description we require.
@rtype: str
@return: The description corresponding to the operation.
----------
ImageOperation.supportedOperations
Returns the supported operations by this object.

@rtype: list of str
@return: The supported operations.
----------
ImageProtocolHandler
Abstract class for implementing a custom L{ImageProtocolHandler}.

An L{ImageProtocolHandler} subclass allows translating an URL with custom protocol into actual image path. Once a subclass of L{ImageProtocolHandler} is registered with its associated protocol, L{ImageManager} will start redirecting incoming URL to the protocol handler for the protocol. Then the handler translates URL into an actual image path so that L{ImageManager} can open the image. A typical use case is to integrate a in-house image library into MARI for straight drag&drop of image

B{Example Code}

>>> # This examples implements a new sample ImageProtocolHandler that removes the protocol scheme and adds .jpg as extension
>>> class MyImageProtocolHandler(mari.ImageProtocolHandler):
>>>     def load(self,location):
>>>         return PySide.QtCore.QUrl(location).toString(PySide.QtCore.QUrl.RemoveScheme)+".jpg"
>>> my_protocol_handler = MyImageProtocolHandler()
>>> mari.images.registerProtocolHandler("myjpgprotocol",my_protocol_handler)
----------
ImageProtocolHandler.load
The actual logic to handle translation of the given URL location to actual file path.

@type  Location: str
@param Location: the URL location passed for translation
@rtype: str
@return: the string representing the actual file path after translating the URL
----------
ImageSet
A collection of one or more images or L{Ptex} face textures to be manipulated as a group.

There are two types of image set: traditional UV image sets and L{Ptex} image sets.

In the case of UV image sets, each UV patch on a model will have one associated image per image set. A 4 patch model will have 4 images in each image set.

In the case of L{Ptex} image sets, the image set serves as container for the L{Ptex} pixel data. For L{Ptex} image sets, the concept of UV patches does not apply. Calling any patch-related methods on a L{Ptex} image set will result in exceptions being raised. Also note that any L{Snapshotable} methods aren't currently supported on L{Ptex} image sets, although this may change in future.

L{Image} sets can be manipulated as a whole, allowing the same operations to be performed on multiple images at once.

One image set at a time is nominated as the "current" image set. This is the image set that the user will interact with when painting.

You can access image sets from a L{Layer} - for example: C{layer.imageSet()} (for L{PaintableLayer} objects)

B{Example Code}

>>> # This example obtains the image of UDIM 1001 from the current layer of the current channel
>>> import mari
>>> layer = mari.geo.current().currentChannel().currentLayer()
>>> if layer.isPaintableLayer():
...     image_set = layer.imageSet()
...     image = image_set.image(0)
----------
ImageSet.addKeyFrame
Adds a key frame.

@type  FrameNumber: int
@param FrameNumber: The frame number of the new key frame
@rtype: bool
@return: True if the new key frame was successfully created or already exists, or False otherwise.
----------
ImageSet.createSnapshot
Creates a new snapshot of the object.

@type  Name: str
@param Name: A descriptive name for this snapshot. There is no restriction on naming convention, so it is recommended to make this clear, such as "new test version".
@type  ID: str
@param ID: An optional identifier for this snapshot. This value can be used to group together sets of snapshots, as described in L{Snapshot.setID()}.
@rtype: L{Snapshot}
@return: The newly created snapshot.
@raise NotImplementedError: Raised if the function is called on a L{Ptex} image set.
----------
ImageSet.deleteSnapshot
Deletes the given snapshot.

@type  ShotToDelete: L{Snapshot}
@param ShotToDelete: The snapshot to delete
@rtype: None
@raise ValueError: The snapshot provided was invalid, or not owned by this object.
@raise NotImplementedError: Raised if the function is called on a L{Ptex} image set.
@warning: This method cannot be undone, so please use caution.
----------
ImageSet.exportImages
Export the images of the image set to disk.

This internally calls the saveAs method of L{Image}, with the same arguments.

>>> import mari
>>> currentImageSet = mari.geo.current().currentChannel().currentLayer().imageSet()
>>> currentImageSet.exportImages('/tmp/test.$UDIM.tif')

@type  PathAndTemplate: str
@param PathAndTemplate: The target path for the export and the template to export the files to. string.
@type  Options: int
@param Options: Pass in a value other than the default to turn on an option, such as disabling "small uniforms". See L{Image.SaveOptions}.
@type  FileOptions: variant
@param FileOptions: This is a key/value map of optional parameters passed to the file writer plugin.
@rtype: None
@raise IOError: Raised if there is a problem saving the file.
@raise TypeError: Raised if the options parameter is not a dict.
@raise NotImplementedError: Raised if the function is called on a L{Ptex} image set.
----------
ImageSet.findSnapshotWithID
Returns the snapshot with the given identifier, if found.

If more than one snapshot with the given identifier exists, the first one will be returned.

@type  ID: str
@param ID: The shot identifier to search for
@rtype: L{Snapshot}
@return: The first snapshot with the given identifier, or None
@raise NotImplementedError: Raised if the function is called on a L{Ptex} image set.
----------
ImageSet.frameCount
Returns the number of frames of animations for this image set.

L{Image} sets may be animated. Each image can have multiple frames associated with it.

@rtype: int
@return: The number of frames of animation
----------
ImageSet.image
Returns the image that corresponds to the given UV index.

@type  UVIndex: int
@param UVIndex: The UV index of the image to return. You can get a list of the UV indices in use (for all image sets and patches) by calling L{uvIndices()}.
@type  Frame: int
@param Frame: The frame to retrieve the image for. If left as the default, -1, it uses the default keyframe.
@rtype: L{Image}
@raise NotImplementedError: Raised if the function is called on a L{Ptex} image set.
@deprecated: This method won't be available for L{Ptex} image sets in future.
@see: L{frameCount()}, L{uvIndices()}
----------
ImageSet.imageCount
Returns the number of images in this image set.

@rtype: int
@return: The number of images that make up this image set
@raise NotImplementedError: Raised if the function is called on a L{Ptex} image set.
@deprecated: This method won't be available for L{Ptex} image sets in future.
----------
ImageSet.imageList
Returns the list of images for this image set.

As of version 1.4v3, these images are returned in UV index order - the same order as GeoEntity::patches(). Note however that these indices do not necessarily map directly to UDIMs, as some UDIMs may be unused, and there will not be any corresponding spaces left empty in the array. To be sure of the UDIM of a patch, you should instead either call the L{GeoPatch.udim()} function on the patch in the corresponding position in the results of GeoEntity::patches(), or iterate through the UV indices of the image set, where you can reliably add the constant 1001 to each of them to calculate the UDIM. For example:

>>> import mari
>>> layer = mari.geo.current().currentChannel().currentLayer()
>>> result = True
>>> if layer.isPaintableLayer():
...     image_set = layer.imageSet()
...     for index in image_set.uvIndices():
...         result = result and image_set.image(index).saveAs("/tmp/"+str(index + 1001) + '.tif')

Alternatively, you can retrieve a list of all images in an array where the indices match the UV indices (and so can be easily converted to UDIMs) using the function L{uvImageList()}.

@type  Frame: int
@param Frame: The frame number to return. If left as the default, -1, the current frame is used.
@rtype: list of  L{Image}
@return: A list of the images in this image set
@raise NotImplementedError: Raised if the function is called on a L{Ptex} image set.
@note: In versions older than 1.4v3, this function does not necessarily return the images in any particular order, or in the same order as GeoEntity::patches().
@deprecated: This method won't be available for L{Ptex} image sets in future.
@see: L{uvImageList()}
----------
ImageSet.importImages
Imports a set of texture files into the images in the image set.

The file names to import and the images to import them into can be specified in two ways.

To specify a template for the file paths to import from:

>>> import mari
>>> layer = mari.geo.current().currentChannel().currentLayer()
>>> if layer.isPaintableLayer():
...     image_set = layer.imageSet()
...     # To export all images:
...     image_set.importImages('/tmp/filename.$UDIM.tif', image_set.SCALE_THE_IMAGE)
...     # To export images for UV indices 2 and 3: (UDIMs 1003 and 1004)
...     image_set.importImages('/tmp/filename.$UDIM.tif', image_set.SCALE_THE_IMAGE, [2, 3])

To specify the items as a sequence of sequences that each contain an L{Image} object and a source path: (both lists and tuples will work)

>>> image_set.importImages([[image_set.image(0), '/tmp/img0.tif'], [image_set.image(1), '/tmp/img1.tif']],
...                        image_set.SCALE_THE_IMAGE)

@type  ImagePaths: variant
@param ImagePaths: Specifies the images and file names to import. This parameter can be either a string template containing "$UDIM", or a list of two-element sequences containing an L{Image} object and a path. See above for examples.
@type  ScaleOption: L{ScaleChoice}
@param ScaleOption: When the existing patch and the image in the file to import are of different sizes, this indicates which of the two to rescale to match the other
@type  UVIndexList: list of  int
@param UVIndexList: This parameter can only be used when passing in a string template for the L{ImagePaths} argument. Pass in a list of zero-based UV indices if desired to specify the patches to export images for. If not specified or empty, images will be exported for all indices. The UDIM for a patch is the zero-based UV index plus 1001.
@type  RemoveAlpha: bool
@param RemoveAlpha: Remove the alpha channel (convert RGBA to RGB).
@rtype: None
@raise NotImplementedError: Raised if the function is called on a L{Ptex} image set.
@raise ValueError: Raised if no image paths were supplied; if the scale option was invalid; if an invalid UV index was specified; or if a non-empty UV index list parameter was supplied, but the image paths parameter was not a string.
@deprecated: This method won't be available for L{Ptex} image sets in future.
----------
ImageSet.importImagesFromDict
Imports a map of texture files into the images in the image set.

The file names to import are specified as a dictionary of target L{Image} objects to image file paths.

>>> image_set.importImages({image_set.image(0): '/tmp/img0.tif', image_set.image(1): '/tmp/img1.tif'},
...                        image_set.SCALE_THE_IMAGE)

@type  ImagePaths: QMap of  L{Image} , str
@param ImagePaths: Specifies the L{Image} objects and file names to import in a dictionary. See the example above.
@type  ScaleOption: L{ScaleChoice}
@param ScaleOption: When the existing patch and the image in the file to import are of different sizes, this indicates which of the two to rescale to match the other
@type  RemoveAlpha: bool
@param RemoveAlpha: Remove the alpha channel (convert RGBA to RGB).
@rtype: None
@raise NotImplementedError: Raised if the function is called on a L{Ptex} image set.
@raise ValueError: Raised if no image paths were supplied; if the scale option was invalid; if an invalid UV index was specified; or if a non-empty UV index list parameter was supplied, but the image paths parameter was not a string.
@deprecated: This method won't be available for L{Ptex} image sets in future.
----------
ImageSet.isAnimated
Indicates whether the image set has an animation.

@rtype: bool
@return: True if this image set has animation - i.e. more than one frame of image data
----------
ImageSet.isPtex
Indicates whether this image set is a L{Ptex} image set.

@rtype: bool
@return: True if this image set uses per-face L{Ptex} mapping, or False otherwise
----------
ImageSet.name
Returns the name of the image set.

@rtype: str
@see: L{setName()}
----------
ImageSet.nameChanged
This is emitted after the image set has been renamed.

@type  NewName: str
@param NewName: The new name of the image set
@rtype: None
----------
ImageSet.removeKeyFrame
Removes a key frame.

@type  FrameNumber: int
@rtype: bool
@return: True if the new key frame was successfully removed or False otherwise.
----------
ImageSet.resize
Resize a set of images in the image set.

@type  NewSize: L{ImageSet.Size}
@param NewSize: The desired size for the image.
@type  UVIndexList: list of  int
@param UVIndexList: Pass in a list of zero-based UV indices if desired to specify which patches to resize the images of. If not specified or empty, all patches will be resized. The UDIM for a patch is the zero-based UV index plus 1001.
@rtype: None
@raise ValueError: Raised if the size provided was invalid, or if an invalid UV index was specified.
@raise NotImplementedError: Raised if the function is called on a L{Ptex} image set.
----------
ImageSet.revertToSnapshot
Reverts the state of the object to that in the given snapshot.

@type  OldSnapshot: L{Snapshot}
@param OldSnapshot: A valid snapshot of this object
@rtype: None
@raise ValueError: The snapshot provided was invalid, or not owned by this object.
@raise NotImplementedError: Raised if the function is called on a L{Ptex} image set.
----------
ImageSet.setName
Sets a new name for the image set.

@type  NewName: str
@param NewName: The new name for the image set
@rtype: None
@raise ValueError: Raised if an image set with the given name already exists on the object.
@see: L{name()}
----------
ImageSet.snapshotList
Returns a list of the snapshots available on the object.

@rtype: list of  L{Snapshot}
@return: A list of the available snapshots
@raise NotImplementedError: Raised if the function is called on a L{Ptex} image set.
----------
ImageSet.supportedWriteFormats
Returns a string list of all image formats that the image set can be written as.

This function returns a list of unique lower case strings in ascending alphabetic order.

@rtype: list of str
@see: L{ImageManager.supportedWriteFormats()}
----------
ImageSet.uvImageList
Returns a list of the images for this image set, in UV coordinate order.

This will include some entries with the value None if any UDIM is not used by the model. The advantage of this over the L{imageList()} function is that the index of each image in the return value can be converted to a UDIM by simply adding the constant 1001.

For example:

>>> import mari
>>> layer = mari.geo.current().currentChannel().currentLayer()
>>> result = True
>>> if layer.isPaintableLayer():
...     image_set = layer.imageSet()
...     for index, image in enumerate(image_set.uvImageList()):
...         result = result and image.saveAs('/tmp/{0}.tif'.format(index + 1001))

@type  Frame: int
@rtype: list of  L{Image}
@return: A list of the images for the image set, with one entry per UV patch position (or UDIM)
@raise NotImplementedError: Raised if the function is called on a L{Ptex} image set.
@deprecated: This method won't be available for L{Ptex} image sets in future.
@see: L{imageList()}
----------
ImageSet.uvIndex
Return the UV Index for the given image if it belongs to this image set.

@type  UvImage: L{Image}
@param UvImage: The image to find the UV index for
@rtype: int
@return: The UV index of the given image if it belongs to this image set, -1 otherwise
----------
ImageSet.uvIndices
Returns a list of all of the UV indices used by the image set.

The UV indices are integers, but not necessarily consecutive.

@rtype: list of  int
@raise NotImplementedError: Raised if the function is called on a L{Ptex} image set.
@deprecated: This method won't be available for L{Ptex} image sets in future.
----------
IntSlider
An integer slider widget.

Provides a custom integer slider widget.

B{Example Code}

>>> # This example creates a new FloatSlider object, add it to a QWidget and show it
>>> import mari
>>> import PySide
>>> int_slider = mari.IntSlider()
>>> container = PySide.QtGui.QWidget()
>>> container.setLayout(PySide.QtGui.QHBoxLayout())
>>> int_slider.addToLayout(container.layout())
>>> container.show()
----------
IntSlider.__init__
Sets to the int slider specified by the given components.

@type  Parent: QWidget
@rtype: L{IntSlider}
----------
IntSlider.setValue
Sets the value of the slider.

@type  Value: int
@param Value: The value to set the slider to.
@rtype: None
@see: L{value()}
----------
IntSlider.value
Returns the value of the slider.

@rtype: int
@return: The value of the slider.
@see: L{setValue()}
----------
IntSlider.valueChanged
This is emitted when the value of the slider changes.

@type  Value: int
@param Value: The value the slider has changed to.
@rtype: None
----------
Layer
A layer in a L{Channel} is an image data operation that can be stacked on top of another layer.

Layers may contain their own image data, such as L{PaintableLayer}, which can be blended with other layers in a layer stack. Other layer types, such as L{AdjustmentLayer}, can specify operations to be performed on the image data from the layers below them in the stack, or in the case of L{ProceduralLayer}, can contain operations that generate new image data from a set of parameters.

Each layer can also contain a mask, either as an image set or a separate layer stack. Most can also contain an adjustment stack, which specifies adjustment operations to be performed only on that layer; see L{AdjustableLayer} for details.

You can access all types of layers from their containing L{Channel} objects - for example: C{channel.layerList()}

B{Example Code}

>>> # This example finds all layers in the current channel
>>> import mari
>>> layers = mari.geo.current().currentChannel().layerList()
----------
Layer.activeCacheUpToHereParents
Returns the top most layer on each of the cache stacks being used that this layer is part of.

@rtype: list of  L{Layer}
@return: The top most layer on each of the cache stacks being used that this layer is part of.
----------
Layer.advancedBlendComponentName
Return the display name for a given advanced blend component value.

C{print mari.current.layer().advancedBlendComponentName( mari.Layer.RED_BLEND)}

@type  Value: L{AdvancedBlendComponent}
@param Value: The L{AdvancedBlendComponent} value to query
@rtype: str
@return: A human readable version of the given advanced blend component value
----------
Layer.advancedBlendComponentStr
Return the advanced blend component for this layer as a string.

C{print mari.current.layer().advancedBlendComponentStr()}

@rtype: str
@return: The display value for the advanced blend component value for this layer
----------
Layer.blendAmount
Get blend amount of the layer.

@rtype: float
@return: The blend amount of the layer
@see: L{setBlendAmount()}
----------
Layer.blendAmountChanged
Emitted when the blend amount of the layer changes.

@type  Amount: float
@param Amount: The new value for the blend amount.
@rtype: None
----------
Layer.blendAmountEnabled
Get enabled state of the blend amount of the layer.

@rtype: bool
@return: The enabled state of the blend amount of the layer
@see: L{setBlendAmountEnabled()}
----------
Layer.blendComponentChanged
Emitted when the advanvced blend component of the layer is changed.

C{def blendComponentChanged(a):}

C{print "new component is ",a}

C{mari.utils.connect( mari.current.layer().blendComponentChanged, blendComponentChanged)}

@type  Type: str
@param Type: The new blend component for this layer
@rtype: None
----------
Layer.blendMode
Returns the blend mode of the layer.

Returns CUSTOM if the blend mode is a custom one.

@rtype: L{BlendMode}
@return: The blend mode
@see: L{setBlendMode()}
----------
Layer.blendModeChanged
Emitted when the blend mode of the layer changes.

C{def blendModeChanged(a):}

C{print "new mode is ",a}

C{mari.utils.connect( mari.current.layer().blendModeChanged, blendModeChanged)}

@type  Mode: str
@param Mode: The pretty string name of the blend mode.
@rtype: None
----------
Layer.blendModeName
Convert blend mode to a pretty string name.

@type  BlendModeValue: L{BlendMode}
@param BlendModeValue: The blend node value to find a string for
@rtype: str
@return: The pretty string name of the blend mode
----------
Layer.blendModeStr
Returns the pretty string name of the blend mode of the layer.

@rtype: str
@return: The pretty string name of the blend mode
@raise ValueError: Raised if the blend mode on the layer is not supported.
----------
Layer.blendType
Return the blend type for this layer.

C{print mari.current.layer().blendType()}

@rtype: L{BlendType}
@return: The L{BlendType} enabled for this layer
@see: L{setBlendType()}
----------
Layer.blendTypeChanged
Emitted when the blend type (Basic, Advanced) of the layer is changed.

C{def blendTypeChanged(a):}

C{print "new type is ",a}

C{mari.utils.connect( mari.current.layer().blendTypeChanged, blendTypeChanged)}

@type  Type: str
@param Type: The new blend type for this layer
@rtype: None
----------
Layer.blendTypeName
Convert blend type to a pretty string name.

C{print mari.current.layer().blendTypeName( mari.Layer.ADVANCED_BLEND)}

@type  BlendTypeValue: L{BlendType}
@param BlendTypeValue: The blend node type to find a string for
@rtype: str
@return: The pretty string name of the blend type
----------
Layer.blendTypeStr
Returns the pretty string name of the blend type of the layer.

C{print mari.current.layer().blendTypeStr()}

@rtype: str
@return: The pretty string name of the blend type
@raise ValueError: Raised if the blend type on the layer is not supported.
----------
Layer.cacheLayer
Cache this layer

@rtype: None
@raise RuntimeError: Raised if this layer cannot be cached.
----------
Layer.cacheStateChanged
This is emitted if the cache status changes.

@rtype: None
----------
Layer.cacheUpToHere
Caches the layer stack up to this layer

@rtype: None
@raise RuntimeError: Raised if the layer stack up to here cannot be cached.
----------
Layer.cacheUpToHereParents
Returns the top most layer on each of the cache stacks, even if it is not in use, that this layer is part of.

@rtype: list of  L{Layer}
@return: The top most layer on each of the cache stacks, even if it is not in use, that this layer is part of.
----------
Layer.close
Removes and deletes the layer from its layer stack.

@rtype: None
----------
Layer.colorTag
Return the current color tag of this layer.

@rtype: str
@return: This returns the name of the color assigned to this layer. The name will be one of the valid names returned by L{colorTagNames()} or "none" if no tag is assigned
@see: L{setColorTag()}
----------
Layer.colorTagChanged
This is emitted when the color tag changes.

@type  Col: str
@param Col: The name of the new color tag.
@rtype: None
----------
Layer.colorTagNames
Return the list of valid color tags.

Users may assign color tags to layers to help catagorize them. This method returns the list of valid color tags that can be assigned to layers. No other tag values will be accepted

@rtype: list of str
----------
Layer.convertedToPaint
This is emitted when the layer is converted to paintable.

@type  Success: bool
@param Success: The result of the signal.
@type  ThisLayer: L{Layer}
@param ThisLayer: This layer, for easy connection to other slots for updates.
@rtype: None
----------
Layer.getAdvancedBlendComponent
Get the advance blend type component.

This defines how the mask is created using the input layer and the LUT 
C{print mari.current.layer().getAdvancedBlendComponent( )}

@rtype: L{AdvancedBlendComponent}
@return: The current advanced blend component set on this layer
----------
Layer.getLayerBelowBlendLut
Return the 'Layer Below' lookup table used when advanced blending is enabled.

C{LUT =  mari.current.layer().getLayerBelowBlendLut()}

@rtype: variant
@return: A handle to the lookuptable
----------
Layer.getThisLayerBlendLut
Return the 'This layer' lookup table used when advanced blending is enabled.

C{LUT =  mari.current.layer().getThisLayerBlendLut()}

@rtype: variant
@return: A handle to the lookuptable
----------
Layer.groupStack
Returns the group layer stack this group layer contains.

@rtype: L{LayerStack}
@return: Returns a layer stack
@raise RuntimeError: Raised if the layer is not a group layer
----------
Layer.hasCacheUpToHere
Indicates whether the stack up to this layer has cache data, even if it is not in use.

@rtype: bool
@return: True if the stack up to this layer has cache data.
----------
Layer.hasLayerCache
Indicates whether this layer has cache data, even if it is not in use.

@rtype: bool
@return: True if this layer has cache data.
----------
Layer.hasMask
Indicates whether this layer has a paintable mask image set or mask stack.

@rtype: bool
@return: True is this layer has a paintable mask image set or mask stack
----------
Layer.hasMaskStack
Indicates whether this layer has a mask stack.

@rtype: bool
@return: True if this layer has a mask stack
----------
Layer.hash
Returns a unique identifier for this layer.

This hash is assumed to be universally unique (256bit skein hash). This can be used to determine if a layer or its children have changed since some given checkpoint. A different hash means a different layer or children. This hash is based on image data, blend mode, parameters and anything that might effect the pixel output. Use this to detect any changes to the layers.

@type  UVIndex: int
@param UVIndex: The UV index of the patch to return the hash of, or -1 to return the hash of all the patches.
@rtype: str
@return: A hash string that uniquely identifies this version of this layer and its children, or an empty string on failure.
@see: L{imageHash()}
----------
Layer.imageHash
Returns a unique identifier for this layer's image data.

This hash is assumed to be universally unique (256bit skein hash). This can be used to determine if a layer or its children have changed their image data since some given checkpoint. A different hash means a different layer or children. This hash is only based on image data and can be used to detect changes in the images.

@type  UVIndex: int
@param UVIndex: The UV index of the patch to return the hash of, or -1 to return the hash of all the patches.
@rtype: str
@return: A hash string that uniquely identifies this version of this layer and its children image data, or an empty string on failure.
@see: L{hash()}
----------
Layer.isAdjustableLayer
Indicates whether this is a channel layer.

@rtype: bool
@return: True if this layer is a channel layer or False if not.
----------
Layer.isAdjustmentLayer
Indicates whether this is a adjustment layer.

@rtype: bool
@return: True if this layer is a adjustment layer or False if not.
----------
Layer.isBakePointLayer
Indicates whether this is a bake point layer.

@rtype: bool
@return: True if this layer is a bake point layer or False if not.
@raise RuntimeError: Raised if the experimental bake point layer feature is not enabled.
----------
Layer.isCachedUpToHere
Indicates whether the stack up to this layer is cached and the cache is being used.

@rtype: bool
@return: True if the stack up to this layer is cached and is being used.
----------
Layer.isChannelLayer
Indicates whether this is a channel layer.

@rtype: bool
@return: True if this layer is a channel layer or False if not.
----------
Layer.isChildOfActiveCacheUpToHere
Indicates whether the layer is part of a cache stack that is being used.

@rtype: bool
@return: True if the layer is part of a cache stack that is being used.
----------
Layer.isChildOfCacheUpToHere
Indicates whether the layer is part of a cache stack, even if it is not in use.

@rtype: bool
@return: True if the layer is part of a cache stack.
----------
Layer.isGraphLayer
Indicates whether this is a node graph layer.

@rtype: bool
@return: True if this layer is a node graph layer or False if not.
----------
Layer.isGroupLayer
Indicates whether this is a group layer.

@rtype: bool
@return: True if this layer is a channel layer or False if not.
----------
Layer.isLayerCached
Indicates whether this layer is cached and the cache is being used.

@rtype: bool
@return: True if this layer is cached and is being used.
----------
Layer.isLocked
Indicates whether this layer is locked and, if so, unmodifiable.

@rtype: bool
@return: True if this layer is locked, or False if unlocked.
----------
Layer.isMaskEnabled
Indicates if the mask is disabled.

@rtype: bool
@return: False is a mask is present and disabled.
----------
Layer.isModifiable
Indicates whether this layer is allowed to be modified.

This is not the same as L{isLocked()}, if a parent layer L{isLocked()} then this layer will not modifiable even though it is not locked.

@rtype: bool
@return: True if the layer can be modified.
----------
Layer.isPaintableLayer
Indicates whether this is a paintable layer.

@rtype: bool
@return: True if this layer is a paintable layer or False if not.
----------
Layer.isProceduralLayer
Indicates whether this is a procedural layer.

@rtype: bool
@return: True if this layer is a procedural layer or False if not.
----------
Layer.isSelected
Indicates whether this layer is selected.

@rtype: bool
@return: True if the layer is selected, or False if not.
----------
Layer.isShaderLayer
Indicates whether this is a shader layer.

@rtype: bool
@return: True if this layer is a shader layer or False if not.
----------
Layer.isShared
Indicates whether this layer is shared.

@rtype: bool
@return: True if the layer is shared, or False if not.
----------
Layer.isVisible
Indicates whether this layer is visible.

@rtype: bool
@return: True if the layer is visible, or False if not.
----------
Layer.layerNode
Returns the node graph node that corresponds to this L{Layer}.

Mari's layers are all build on top of node graph. A layer consists of a Merge node, its business node which provide the content of layer and, if existing, a mask. The primary node represending a layer is its Merge node which provides the blending logic. This function returns the Merge node.

@rtype: L{Node}
@return: the node graph Merge node that corresponds to this L{Layer}
----------
Layer.lockedChanged
This is emitted when the locked state changes.

@type  Locked: bool
@param Locked: The new locked state.
@rtype: None
----------
Layer.makeCurrent
Sets this layer as the currently active layer on the currently active channel if it belongs to it and make this the current layer of the geo entity.

@rtype: None
----------
Layer.makeMask
Creates a mask image set on the layer

Or the layer is not modifiable.

@rtype: L{ImageSet}
@return: Return an image set
----------
Layer.makeMaskStack
Creates a mask stack on the layer

@rtype: L{LayerStack}
@raise RuntimeError: Raised if the layer mask stack cannot be create or already exists or the layer is not modifiable.
----------
Layer.maskCreated
This is emitted when a mask is created on a layer.

@type  Mask: L{Layer.MaskType}
@param Mask: The type of mask added (its type being L{MaskType}).
@rtype: None
----------
Layer.maskImageSet
Returns the image set used by this layers mask

@rtype: L{ImageSet}
@return: Return an image set
@see: L{setMaskImageSet()}
----------
Layer.maskRemoved
This is emitted when a mask is removed on a layer.

@rtype: None
----------
Layer.maskStack
Returns the mask stack that is applied to the mask of this layer

@rtype: L{LayerStack}
@return: Returns a layer stack
@see: L{setMaskStack()}
----------
Layer.maskStackCreated
This is emitted when a mask stack is created.

@rtype: None
----------
Layer.name
Returns the name of the layer.

@rtype: str
@return: The name of this layer.
@see: L{setName()}
----------
Layer.nameChanged
This is emitted after the channel has had its name changed.

@type  NewName: str
@param NewName: The new name.
@rtype: None
----------
Layer.parents
Returns a list of all the layers and channels that use this layer.

@rtype: list of  variant
@return: A list of layers and channels that use this layer
----------
Layer.removeMask
Remove the mask stack from the layer

@rtype: None
@raise RuntimeError: Raised if the layer mask stack cannot be removed or does not exist or the layer is not modifiable.
----------
Layer.selectedChanged
This is emitted when the selection state changes.

@type  Selected: bool
@param Selected: The new selected state.
@type  ThisLayer: L{Layer}
@param ThisLayer: The layer that changed for easy connection to other slots for updates.
@rtype: None
----------
Layer.setAdvancedBlendComponent
Set the advance blend type component.

This defines how the mask is created using the input layer and the LUT 

C{mari.current.layer().setAdvancedBlendComponent( mari.Layer.RED_BLEND )}

@type  Component: L{AdvancedBlendComponent}
@param Component: The new component value
@rtype: None
@return: The current advanced blend component set on this layer
----------
Layer.setBlendAmount
Sets the blend amount of the layer.

@type  BlendAmount: float
@param BlendAmount: The new value for the blend amount. This must be in the range of 0.0 to 1.0.
@rtype: None
@raise ValueError: Raised if the blend amount was invalid.
@see: L{blendAmount()}
----------
Layer.setBlendAmountEnabled
Enables or Disables the blend amount of the layer.

@type  Enabled: bool
@param Enabled: The new enabled state to set the blend amount to.
@rtype: None
@see: L{blendAmountEnabled()}
----------
Layer.setBlendMode
Sets the blend mode of the layer.

@type  BlendModeValue: variant
@param BlendModeValue: The new value for the blend mode. Both the L{BlendMode} enum and the name of the blend mode is accepted.
@rtype: None
@raise ValueError: Raised if the blend mode was invalid.
@see: L{blendMode()}
----------
Layer.setBlendType
Set the blend type for this layer.

C{mari.current.layer().setBlendType(mari.Layer.ADVANCED_BLEND)}

@type  Type: L{BlendType}
@param Type: The type of blending to enable for this layer
@rtype: None
@see: L{blendType()}
----------
Layer.setCachedUpToHere
sets the cached state up to this layer.

@type  Cache: bool
@param Cache: Whether to cache up to this layer. True has the same effect as L{cacheUpToHere()} while False has the same effect as L{uncacheUpToHere()}.
@rtype: None
----------
Layer.setColorTag
Set the tag color for this layer.

This is a GUI only tag that allows users to catagorize layers by assigning a color tag

@type  Col: str
@param Col: The name of the color tag to assign. This should be one of the valid tags returned by L{colorTagNames()}. Pass "none" to clear any existing tag.
@rtype: None
@raise ValueError: If col is not a valid color tag name
@see: L{colorTag()}
----------
Layer.setLayerBelowBlendLut
Set the "Layer Below" LUT to use when advanced blending

C{LUT = mari.current.layer().getLayerBelowBlendLut()}

C{LUT.setLinear(0,1)}

C{mari.current.layer().setLayerBelowBlendLut(LUT)}

@type  NewLut: L{LookUpTable}
@param NewLut: A Handle to the new LUT to apply when advanced blending
@rtype: None
----------
Layer.setLayerCached
sets the layer cached state of this layer.

@type  Cache: bool
@param Cache: Whether to cache this layer. True has the same effect as L{cacheLayer()} while False has the same effect as L{uncacheLayer()}.
@rtype: None
----------
Layer.setLocked
Locks or unlocks the layer, to optionally prevent modifications.

@type  Lock: bool
@param Lock: True to lock the layer, or False to unlock it.
@rtype: None
----------
Layer.setMaskEnabled
Set the enabled state of the layers mask.

@type  Enabled: bool
@param Enabled: The enabled state to set the mask to
@rtype: None
----------
Layer.setMaskImageSet
Sets a L{Image} set as the layer's mask

Or the mask is not modifiable.

@type  Mask: L{ImageSet}
@rtype: None
@see: L{maskImageSet()}
----------
Layer.setMaskStack
Sets a L{LayerStack} as the layer's mask stack

Or the layer is not modifiable.

@type  MaskStack: L{LayerStack}
@rtype: None
@see: L{maskStack()}
----------
Layer.setName
Sets the name of the layer.

@type  NewName: str
@param NewName: The new name for the layer.
@rtype: None
@see: L{name()}
----------
Layer.setSelected
Sets the selected status of the layer.

@type  Selected: bool
@param Selected: True to select layer, or False to unselect it.
@rtype: None
----------
Layer.setSwizzle
Set one of the layer's color component sources.

@type  Dst: L{SwizzleDestination}
@param Dst: The component to change.
@type  Src: L{SwizzleSource}
@param Src: The source to takde the component from.
@rtype: None
@see: L{swizzle()}
----------
Layer.setThisLayerBlendLut
Set the "This Layer" LUT to use when advanced blending

C{LUT = mari.current.layer().getThisLayerBlendLut()}

C{LUT.setLinear(0,1)}

C{mari.current.layer().setThisLayerBlendLut(LUT)}

@type  NewLut: L{LookUpTable}
@param NewLut: A Handle to the new LUT to apply when advanced blending
@rtype: None
----------
Layer.setVisibility
Shows or hides the layer.

@type  Visible: bool
@param Visible: True to show the layer, or False to hide it.
@rtype: None
----------
Layer.siblingSharedLayerList
Returns the list of layers that share the resources with this layer.

@rtype: list of  L{Layer}
@return: The list of layers that share the resources with this layer
----------
Layer.swizzle
Get the specified layer's color components source.

@type  Dst: L{SwizzleDestination}
@rtype: L{SwizzleSource}
@see: L{setSwizzle()}
----------
Layer.uncacheLayer
Deletes the cache of this layer

@rtype: None
@raise RuntimeError: Raised if the cache for this layer cannot be deleted.
----------
Layer.uncacheUpToHere
Deletes the cache of the layer stack up to this layer

@rtype: None
@raise RuntimeError: Raised if the cache for layer stack up to here cannot be deleted.
----------
LayerStack
This is the interface for creating, traversing and destroying layers on any part of the layer system that has layer stacks.

This is the interface for creating, traversing and destroying layers on any part of the layer system that has layer stacks. Obtain these using methods on the relevant interfaces that return L{LayerStack}. For example: C{layer.makeMaskStack()} B{Example Code}

>>> # This example creates a mask stack and returns the mask stack
>>> import mari
>>> current_layer = mari.geo.current().currentChannel().currentLayer()
>>> mask_stack = current_layer.makeMaskStack()
----------
LayerStack.adjustmentLayerTypeList
Returns a list of adjustment layer types that can be created.

@rtype: list of str
@return: A list of adjustment layer types
----------
LayerStack.clearSelection
Deselects all currently selected layers in the hierarchy of the stack.

@type  Flags: int
@param Flags: Values of L{ClearSelectionFlag} or'ed together.
@rtype: None
----------
LayerStack.createAdjustmentLayer
Returns a new adjustment layer that has been created on layer stack.

@type  LayerName: str
@param LayerName: the name of the layer to create.
@type  PrimaryAdjustmentKey: str
@param PrimaryAdjustmentKey: The path key of the type of the primary adjustment to create.
@type  RefLayer: L{Layer}
@param RefLayer: The layer to create the new layer above. If None then the new layer is created at the top of the layer stack.
@type  Flags: int
@param Flags: Optional layer creation flags. Values of L{LayerCreateFlag} or'ed together.
@rtype: L{Layer}
@return: The newly created adjustment layer.
@raise ValueError: Raised if adjustment key parameter does not match any valid value. Or if the reference layer is not in this stack.
----------
LayerStack.createBakePointLayer
Returns a new bake point layer that has been created on layer stack.

@type  LayerName: str
@param LayerName: The name of the layer to create.
@type  RefLayer: L{Layer}
@param RefLayer: The layer to create the new layer above. If None then the new layer is created at the top of the layer stack.
@type  Flags: int
@param Flags: Optional layer creation flags. Values of L{LayerCreateFlag} or'ed together.
@rtype: L{Layer}
@return: The newly created bake point layer.
@raise ValueError: Raised if the reference layer is not in this stack.
@raise RuntimeError: Raised if the experimental bake point layer feature is not enabled.
----------
LayerStack.createChannelLayer
Returns a new channel layer that has been created on layer stack.

@type  LayerName: str
@param LayerName: the name of the layer to create.
@type  TargetChannel: L{Channel}
@param TargetChannel: The channel to use.
@type  RefLayer: L{Layer}
@param RefLayer: The layer to create the new layer above. If None then the new layer is created at the top of the layer stack.
@type  Flags: int
@param Flags: Optional layer creation flags. Values of L{LayerCreateFlag} or'ed together.
@rtype: L{Layer}
@return: The newly-created channel layer.
@raise ValueError: Raised if channel parameter is not valid, or if the reference layer is not in this stack.
----------
LayerStack.createGraphLayer
Returns a new graph layer that has been created on layer stack.

@type  LayerName: str
@param LayerName: The name of the layer to create.
@type  RefLayer: L{Layer}
@param RefLayer: The layer to create the new layer above. If None then the new layer is created at the top of the layer stack.
@type  Flags: int
@param Flags: Optional layer creation flags. Values of L{LayerCreateFlag} or'ed together.
@rtype: L{Layer}
@return: The newly created graph layer.
@raise ValueError: Raised if the reference layer is not in this stack.
----------
LayerStack.createGroupLayer
Returns a new group layer that has been created on layer stack.

@type  LayerName: str
@param LayerName: The name of the layer to create.
@type  RefLayer: L{Layer}
@param RefLayer: The layer to create the new layer above. If None then the new layer is created at the top of the layer stack.
@type  Flags: int
@param Flags: Optional layer creation flags. Values of L{LayerCreateFlag} or'ed together.
@rtype: L{Layer}
@return: The newly created group layer.
@raise ValueError: Raised if the reference layer is not in this stack.
----------
LayerStack.createPaintableLayer
Returns a new paintable layer that has been created on layer stack.

@type  LayerName: str
@param LayerName: The name of the layer to create.
@type  RefLayer: L{Layer}
@param RefLayer: The layer to create the new layer above. If None then the new layer is created at the top of the layer stack
@type  FillColor: L{Color}
@param FillColor: The color the layer is initially set to.
@type  Flags: int
@param Flags: Optional layer creation flags. Values of L{LayerCreateFlag} or'ed together.
@rtype: L{Layer}
@return: The newly created paintable layer.
@raise ValueError: Raised if the reference layer is not in this stack.
----------
LayerStack.createProceduralLayer
Returns a new procedural layer that has been created on layer stack.

To get a list of the available types of procedural layers to create, call L{Channel.proceduralLayerTypeList()}.

For example:

>>> import mari
>>> channel = mari.geo.current().currentChannel()
>>> procedural_layer_type_list =  channel.proceduralLayerTypeList()

@type  LayerName: str
@param LayerName: The name of the layer to create.
@type  ProceduralKey: str
@param ProceduralKey: The path key of the type of the procedural to create
@type  RefLayer: L{Layer}
@param RefLayer: The layer to create the new layer above. If None then the new layer is created at the top of the layer stack.
@type  Flags: int
@param Flags: Optional layer creation flags. Values of L{LayerCreateFlag} or'ed together.
@rtype: L{Layer}
@return: The newly created procedural layer.
@raise ValueError: Raised if procedural key parameter does not match any valid value. Or if the reference layer is not in this stack.
----------
LayerStack.createShaderLayer
Returns a new shader layer that has been created on layer stack.

@type  LayerName: str
@param LayerName: the name of the layer to create.
@type  TargetShader: L{Shader}
@param TargetShader: The shader to use.
@type  RefLayer: L{Layer}
@param RefLayer: The layer to create the new layer above. If None then the new layer is created at the top of the layer stack.
@type  Flags: int
@param Flags: Optional layer creation flags. Values of L{LayerCreateFlag} or'ed together.
@rtype: L{Layer}
@return: The newly-created channel layer.
@raise ValueError: Raised if channel parameter is not valid, or if the reference layer is not in this stack.
@see: L{GeoEntity.createDiffuseSpecularShader()}, L{GeoEntity.createLayeredShader()}, L{mari.examples.shaderstacks.createShaderStacks()}, L{GeoEntity.createStandaloneShader()}, L{GeoEntity.createShader()}
----------
LayerStack.duplicateLayers
Creates copies of the given layers within the layer stack.

@type  LayersToDuplicate: list of  L{Layer}
@param LayersToDuplicate: The list of layers to create copies of. If empty all currently selected layers will be used.
@type  RefLayer: L{Layer}
@param RefLayer: The reference layer, above which the new layer is created. If None then the layers are added to the top of this stack.
@type  Flags: int
@param Flags: Optional layer creation flags. Values of L{LayerCreateFlag} or'ed together.
@rtype: list of  L{Layer}
@return: The newly created layer copies.
@raise ValueError: Raised if the layers to duplicate or the reference layer are not in this stack.
----------
LayerStack.exportImages
Exports a set of images from the layer stack.

This is the same as selecting "Export All Layers" from the GUI within the given layer stack. To export an individual layer, call L{PaintableLayer.exportImages()} or L{ProceduralLayer.exportImages()}.

Pass in the path and template to export the files to - for example:

>>> import mari
>>> channel = mari.geo.current().currentChannel()
>>> channel.exportImages('/tmp/$CHANNEL.$LAYER.$UDIM.tif')

Pass in the path and template to export the files to and two options - for example:

>>> import mari
>>> channel = mari.geo.current().currentChannel()
>>> channel.exportImages('/tmp/$CHANNEL.$LAYER.$UDIM.tif', 0, [], {'A' : 'B', 'C' : 'D'})

@type  PathAndTemplate: str
@param PathAndTemplate: The target path for the export and the template to export the files to, in a single string.
@type  Options: int
@param Options: Pass in a value other than the default to turn on an option, such as disabling "small uniforms". See L{Image.SaveOptions}.
@type  UVIndexList: list of  int
@param UVIndexList: Pass in a list of zero-based UV indices if desired to specify the patches to export images for. If not specified or empty, images will be exported for all indices. The UDIM for a patch is the zero-based UV index plus 1001.
@type  FileOptions: variant
@param FileOptions: This is a key/value map of optional parameters passed to the file writer plugin
@rtype: None
@raise ValueError: Raised if the path and template parameter was empty, or if an invalid UV index was specified.
@raise RuntimeError: Raised if the stack contains multiple layers, but the export was not to a layered format and the template did not contain $LAYER. This would otherwise write the same file multiple times.
@raise IOError: Raised if an error occurred with the export process.
@see: L{exportImagesFlattened()}, L{PaintableLayer.exportImages()}, L{ProceduralLayer.exportImages()}, L{importImages()}
----------
LayerStack.exportImagesFlattened
Exports a set of images from the flattened contents of the layer stack.

This is the same as selecting "Export All Layers Flattened" from the GUI within the given layer stack. It bakes the contents of the layer stack into a single temporary image for each patch, and then exports those.

Pass in the path and template to export the files to - for example:

>>> import mari
>>> channel = mari.geo.current().currentChannel()
>>> channel.exportImagesFlattened('/tmp/$CHANNEL.$UDIM.tif')

Some file specific options can be passed via FilOptions - for example :

>>> import mari
>>> channel = mari.geo.current().currentChannel()
>>> channel.exportImagesFlattened('/tmp/$CHANNEL.$UDIM.exr',0,[],{"compression":"zip"})

For OpenEXR files, L{FileOptions} uses the "compression" method as an option for selecting which compression type is used. The following values are accepted as OpenEXR "compression" options.
  - 'none' : 'none'
  - 'Zip (1 scanline)' : 'zips'
  - 'Zip (16 scanlines)' : 'zip'
  - 'PIZ Wavelet (32 scanlines)' :'piz'
  - 'RLE' : 'rle'
  - 'B44': 'b44'
  - 'B44A': 'b44a'
  - 'DWAA': 'dwaa'
  - 'DWAB': 'dwab'

Note that both the long and short names for the compression method are accepted. Either of the following lines will set the compression type to Zip (16 scanlines).

>>> channel.exportImagesFlattened('/tmp/$CHANNEL.$UDIM.exr',0,[],{"compression":"zip"})

>>> channel.exportImagesFlattened('/tmp/$CHANNEL.$UDIM.exr',0,[],{"compression":"Zip (16 scanlines)"})

@type  PathAndTemplate: str
@param PathAndTemplate: The target path for the export and the template to export the files to, in a single string.
@type  Options: int
@param Options: Pass in a value other than the default to turn on an option, such as disabling "small uniforms". See L{Image.SaveOptions}.
@type  UVIndexList: list of  int
@param UVIndexList: Pass in a list of zero-based UV indices if desired to specify the patches to export images for. If not specified or empty, images will be exported for all indices. The UDIM for a patch is the zero-based UV index plus 1001.
@type  FileOptions: variant
@param FileOptions: This is a key/value map of optional parameters passed to the file writer plugin
@rtype: None
@raise ValueError: Raised if the path and template parameter was empty, or if an invalid UV index was specified.
@raise IOError: Raised if an error occurred with the export process.
@see: L{exportSelectedPatches()}, L{exportImages()}, L{importImages()}, L{exportSelectedPatchesFlattened()}
----------
LayerStack.exportSelectedPatches
Exports images from the selected patches.

This is the same as selecting "Export All Layers" from the GUI within the given layer stack. To export an individual layer, call L{PaintableLayer.exportImages()} or L{ProceduralLayer.exportImages()}. Images will only be exported for patches that are currently selected.

Pass in the path and template to export the files to - for example:

>>> channel.exportSelectedPatches('/tmp/$CHANNEL.$LAYER.$UDIM.tif')

@type  PathAndTemplate: str
@param PathAndTemplate: The target path for the export and the template to export the files to, in a single string.
@type  Options: int
@param Options: Pass in a value other than the default to turn on an option, such as disabling "small uniforms". See L{Image.SaveOptions}.
@type  FileOptions: variant
@param FileOptions: This is a key/value map of optional parameters passed to the file writer plugin
@rtype: None
@raise ValueError: Raised if the path and template parameter was empty, or if an invalid UV index was specified.
@raise RuntimeError: Raised if the stack contains multiple layers, but the export was not to a layered format and the template did not contain $LAYER. This would otherwise write the same file multiple times.
@raise IOError: Raised if an error occurred with the export process.
@see: L{exportImagesFlattened()}, L{ProceduralLayer.exportImages()}, exportPaintableLayer.exportImages(), L{importImages()}, L{exportSelectedPatchesFlattened()}
----------
LayerStack.exportSelectedPatchesFlattened
Exports the selected patches with the layer stack flattened.

This is the same as selecting "Export All Layers Flattened" from the GUI within the given layer stack. It bakes the contents of the layer stack into a single temporary image for each selected patch, and then exports those.

Pass in the path and template to export the files to - for example:

>>> channel.exportSelectedPatchesFlattened('/tmp/$CHANNEL.$UDIM.tif')

@type  PathAndTemplate: str
@param PathAndTemplate: The target path for the export and the template to export the files to, in a single string.
@type  Options: int
@param Options: Pass in a value other than the default to turn on an option, such as disabling "small uniforms". See L{Image.SaveOptions}.
@type  FileOptions: variant
@param FileOptions: This is a key/value map of optional parameters passed to the file writer plugin
@rtype: None
@raise ValueError: Raised if the path and template parameter was empty, or if an invalid UV index was specified.
@raise IOError: Raised if an error occurred with the export process.
@see: L{exportSelectedPatches()}, L{exportImages()}, L{importImages()}
----------
LayerStack.findLayer
Returns the layer with the given name.

@type  LayerName: str
@rtype: L{Layer}
@return: The requested layer. Return None is not found.
----------
LayerStack.groupLayers
Creates a new group layer on the layer stack and adds the given layers to it.

If an empty layer list is given then a new group layer won't be created.

@type  LayersToGroup: list of  L{Layer}
@param LayersToGroup: The list of layers to add to the new group. If empty all currently selected layers will be used.
@type  RefLayer: L{Layer}
@param RefLayer: The reference layer, above which the new layer is created. If None then the layer is added to the top of this stack.
@type  LayerName: str
@param LayerName: The name of the layer to create. If empty a unique name will be auto-generated for the layer.
@type  Flags: int
@param Flags: Optional layer creation flags. Values of L{LayerCreateFlag} or'ed together.
@rtype: L{Layer}
@return: The newly created group layer.
@raise ValueError: Raised if the layers to group or the reference layer are not in this stack.
----------
LayerStack.hash
Returns a unique identifier for this layer stack.

This hash is assumed to be universally unique (256bit skein hash). This can be used to determine if a layer stack or its children have changedsince some given checkpoint. A different hash means a different layer or children. This hash is based on image data, blend mode, parameters and anything that might effect the pixel output. Use this to detect any changes to the layers.

@type  UVIndex: int
@param UVIndex: The UV index of the patch to return the hash of, or -1 to return the hash of all the patches.
@rtype: str
@return: A hash string that uniquely identifies this version of this layer stack and its childrens, or an empty string on failure.
@see: L{imageHash()}
----------
LayerStack.imageHash
Returns a unique identifier for this layer stack's image data.

This hash is assumed to be universally unique (256bit skein hash). This can be used to determine if a layer stack or its children have changed their image data since some given checkpoint. A different hash means a different layer or children. This hash is only based on image data and can be used to detect changes in the images.

@type  UVIndex: int
@param UVIndex: The UV index of the patch to return the hash of, or -1 to return the hash of all the patches.
@rtype: str
@return: A hash string that uniquely identifies this version of this layer stack and its childrens image data, or an empty string on failure.
@see: L{hash()}
----------
LayerStack.importImages
Imports a set of images into the layer stack.

This is the same as selecting "Import into Layer Stack" from the GUI. To import into an individual layer, call L{PaintableLayer.importImages()}.

Pass in the path to the files and the template to import them from - for example:

>>> channel.importImages('/tmp/$CHANNEL.$UDIM.psd')

@type  PathAndTemplate: str
@param PathAndTemplate: The path to the files and the template to import them from, in a single string.
@type  ScaleOption: L{ImageSet.ScaleChoice}
@param ScaleOption: When the existing patch and the image in the file to import are of different sizes, this indicates which of the two to rescale to match the other
@type  MatchingLayersOption: L{LayerImportOption}
@param MatchingLayersOption: Determines what to do when the current layer stack and the layers being imported contain matching layer names, where the types of both layers match. This is the most common case. The default is to update the existing layers.
@type  MismatchingLayersOption: L{LayerImportOption}
@param MismatchingLayersOption: Determines what to do when the current layer stack and the layers being imported contain matching layer names, where the types of the existing layers and those being imported do not match. This can happen when an exported file contains procedural layers baked as paintable, for example. The default is to skip the mismatching layers.
@type  UVIndexList: list of  int
@param UVIndexList: Pass in a list of zero-based UV indices if desired to specify the patches to export images for. If not specified or empty, images will be exported for all indices. The UDIM for a patch is the zero-based UV index plus 1001.
@type  RemoveAlpha: bool
@param RemoveAlpha: Remove the alpha channel (convert RGBA to RGB).
@rtype: None
@raise ValueError: Raised if the path and template parameter was empty, or if one or both of the matching and mismatching layers options was invalid.
@raise IOError: Raised if an error occurred with the import process.
@see: L{exportImages()}, L{PaintableLayer.importImages()}
----------
LayerStack.layer
Returns the layer with the given name.

@type  LayerName: str
@param LayerName: The name of the layer to retrieve
@rtype: L{Layer}
@return: The requested layer.
@raise ValueError: Raised if the given layer name was not found on the object.
----------
LayerStack.layerList
Returns the list of layers that make up this objects layer stack.

@rtype: list of  L{Layer}
@return: The list of layers for this object's layer stack
----------
LayerStack.mergeLayers
Merges the given layers within the layer stack into a single paintable layer.

@type  LayersToMerge: list of  L{Layer}
@param LayersToMerge: The list of layers to merge. If empty all currently selected layers will be used.
@type  RefLayer: L{Layer}
@param RefLayer: The reference layer, above which the merge result is added. If None then the new layer is added to the top of this stack.
@type  Flags: int
@param Flags: Optional layer creation flags. Values of L{LayerCreateFlag} or'ed together.
@rtype: L{Layer}
@return: The newly created merged layer
@raise ValueError: Raised if the layers to merge or the reference layer are not in this stack.
----------
LayerStack.moveLayer
Moves the layer from its current layer stack position to this stack and position.

@type  LayerToMove: L{Layer}
@param LayerToMove: The layer that is to be moved.
@type  RefLayer: L{Layer}
@param RefLayer: The reference layer to move the layer above. If None then the layer is moved to the top of this stack.
@rtype: None
@raise ValueError: Raised if the reference layer is not in this stack.
----------
LayerStack.moveLayerBelow
Moves the layer from its current layer stack position to this stack and position.

@type  LayerToMove: L{Layer}
@param LayerToMove: The layer that is to be moved.
@type  RefLayer: L{Layer}
@param RefLayer: The reference layer to move the layer below. If None then the layer is moved to the top of this stack.
@rtype: None
@raise ValueError: Raised if the reference layer is not in this stack.
----------
LayerStack.name
Returns the name of the object.

@rtype: str
@return: The name of this object
----------
LayerStack.proceduralLayerTypeList
Returns a list of procedural layer types that can be created.

@rtype: list of str
@return: A list of procedural layer types
----------
LayerStack.removeLayers
Removes the given layers within the layer stack.

@type  LayersToRemove: list of  L{Layer}
@param LayersToRemove: The list of layers to remove. If empty all currently selected layers will be used.
@rtype: None
@raise ValueError: Raised if the layers to remove are not in this stack.
----------
LayerStack.shareLayer
Shares the layer from its current layer stack position to this stack and position.

@type  LayerToShare: L{Layer}
@param LayerToShare: The layer that is to be shared.
@type  RefLayer: L{Layer}
@param RefLayer: The reference layer to move the layer above. If None then the layer is moved to the top of this stack.
@type  Flags: int
@param Flags: Optional layer creation flags. Values of L{LayerCreateFlag} or'ed together.
@rtype: L{Layer}
@return: The newly-shared layer.
@raise ValueError: Raised if the reference layer is not in this stack.
----------
LayerStack.ungroupLayers
Removes the group layers specified and inserts the deleted group's layer stack in its place in the layer stack.

@type  GroupLayersToUngroup: list of  L{Layer}
@param GroupLayersToUngroup: The list of group layers to ungroup. If empty all currently selected layers will be used.
@rtype: None
@raise ValueError: Raised if the layers to ungroup are not in this stack.
----------
Light
An object for creating lighting effects on a 3D mesh.

You can access lights through the L{LightManager} - for example: C{mari.lights.list()}

B{Example Code}

>>> # This example shows hot to obtain all lights
>>> import mari
>>> lights = mari.lights.list()
----------
Light.isEnvironmentLight
Indicates whether this is a environment light.

@rtype: bool
@return: True if this light is an environment light or False if not.
----------
Light.isOn
Indicates whether the light is on or off.

@rtype: bool
@return: True if the light is turned on, or False otherwise
----------
Light.isPointLight
Indicates whether this is a point light.

@rtype: bool
@return: True if this light is an point light or False if not.
----------
Light.name
Returns the name of the light.

@rtype: str
@return: The name of the light.
----------
Light.onChanged
Emitted when on changes.

@type  On: bool
@param On: The new value
@rtype: None
----------
Light.setOn
Turns the light on or off.

@type  OnOrOff: bool
@param OnOrOff: Set to True to turn the light on, or False to turn it off
@rtype: None
----------
LightManager
Manages the lights in the scene.

B{Example Code}

>>> # This example shows how to obtain all lights
>>> import mari
>>> lights = mari.lights.list()
----------
LightManager.current
Returns the currently selected light.

@rtype: L{Light}
@return: The currently selected light.
----------
LightManager.list
Returns a list of all lights in the project.

@rtype: list of  L{Light}
@return: All lights in the project.
----------
LightManager.selection
Returns a list of all selected lights in the project.

@rtype: list of  L{Light}
@return: All selected lights in the project.
----------
LineEdit
A numeric slider widget.

Provides a custom line edit widget, which accepts integers (the default) or floating point values. B{Example Code}

>>> # This example creates a new FloatSlider object, add it to a QWidget and show it
>>> import mari
>>> import PySide
>>> line_edit = mari.LineEdit()
>>> container = PySide.QtGui.QWidget()
>>> container.setLayout(PySide.QtGui.QHBoxLayout())
>>> line_edit.addToLayout(container.layout())
>>> container.show()
----------
LineEdit.__init__
Sets to the int slider specified by the given components.

@type  Parent: QWidget
@type  Value: int
@type  Range: int
@rtype: L{LineEdit}
----------
LineEdit.addFloatValidator
Adds a validator to provided range checking of floating-point numbers.

@type  Minimum: float
@param Minimum: The minimum value accepted.
@type  Maximum: float
@param Maximum: The maximum value accepted.
@type  Precision: int
@param Precision: The number of decimal places accepted.
@rtype: None
----------
LineEdit.addToLayout
Adds the line edit to the given layout.

@type  Layout: QLayout
@param Layout: The layout to add the line edit widget to
@rtype: None
@raise ValueError: Raised if the given layout is null.
----------
LineEdit.blockSignals
Disables or re-enables the emission of signals from the object.

If L{Block} is True, this will block the emission of signals from this object - i.e., emitting a signal will not invoke anything connected to it. If L{Block} is False, any previous blocking will be deactivated.

Signals are always enabled by default.

When using this function, you should store the return value, which is the previous setting for whether signals were blocked. When your processing has finished, you should call this function again with the previous value. This will ensure that signals will not be re-enabled earlier than intended.

@type  Block: bool
@param Block: True to block signals, or False to unblock them - but see above for why this should generally be called with a stored value instead of an explicit False
@rtype: bool
@return: The previous value of whether signals were blocked.
----------
LineEdit.home
Moves the text cursor to the beginning of the line unless it is already there.

@type  Mark: bool
@param Mark: If True, text is selected towards the first position; otherwise, any selected text is unselected if the cursor is moved.
@rtype: None
----------
LineEdit.isEnabled
Returns whether the line edit is enabled.

@rtype: bool
----------
LineEdit.isReadOnly
Returns whether the line edit is read only.

@rtype: bool
----------
LineEdit.lostFocus
This is emitted when the line edit loses focus.

@rtype: None
----------
LineEdit.maximumHeight
Returns the maximum height in pixels.

@rtype: int
@see: L{setMaximumHeight()}
----------
LineEdit.maximumWidth
Returns the maximum width in pixels.

@rtype: int
@see: L{setMaximumWidth()}
----------
LineEdit.movedMouse
This is emitted when the mouse is dragged from the line edit.

@type  YPosition: int
@param YPosition: The relative y position of the cursor.
@rtype: None
----------
LineEdit.setEnabled
Sets whether the line edit is enabled.

@type  Enabled: bool
@rtype: None
----------
LineEdit.setMaximumHeight
Sets the maximum height in pixels.

@type  Maximum: int
@rtype: None
@see: L{maximumHeight()}
----------
LineEdit.setMaximumWidth
Sets the maximum width in pixels.

@type  Maximum: int
@rtype: None
@see: L{maximumWidth()}
----------
LineEdit.setRange
Sets the range of the line edit.

@type  Range: int
@param Range: The range to set on the line edit.
@rtype: None
----------
LineEdit.setReadOnly
Sets whether the line edit is read only.

@type  ReadOnly: bool
@rtype: None
----------
LineEdit.setText
Sets the text entered in the line edit.

@type  Text: str
@rtype: None
@see: L{text()}
----------
LineEdit.setValue
Sets the value of the slider.

@type  Value: int
@param Value: The value to set the slider to.
@rtype: None
----------
LineEdit.text
Returns the entered text.

@rtype: str
@see: L{setText()}
----------
LocatorEntity
These are the locator object in the "Objects" Gui.
----------
LocatorEntity.addLocator
Add a locator to this object.

@rtype: L{LocatorEntity}
@return: The newly-created locator.
----------
LocatorEntity.hideLocator
Hide the locator UI object.

@rtype: None
----------
LocatorEntity.isSelected
Indicates whether the object is currently selected.

@rtype: bool
@return: True if the object is selected, or False if not
----------
LocatorEntity.name
Returns the name of the object.

@rtype: str
@return: The name of this object
@see: L{setName()}
----------
LocatorEntity.nameChanged
This is emitted after the entity has been renamed.

@type  NewName: str
@param NewName: The new name of the entity
@rtype: None
----------
LocatorEntity.setName
Changes the name of the object.

@type  NewName: str
@param NewName: The new name of the object
@rtype: None
@see: L{name()}
----------
LocatorEntity.setSelected
Changes the selection state of the object.

@type  Selected: bool
@param Selected: True to select the object, or False to deselect it
@rtype: None
@note: Exactly one object can be selected at a time. If only one object is available, it cannot be deselected.
----------
LocatorEntity.setTransform
Sets the transform of the geo entity for a frame.

@type  pTransform: L{Matrix}
@param pTransform: Translation vector
@type  Frame: int
@param Frame: L{Frame}
@rtype: None
@raise ValueError: Throws a value error if the input if not a valid matrix
@see: L{transform()}
----------
LocatorEntity.showLocator
Show the locator UI object.

@rtype: None
----------
LocatorEntity.transform
Returns the transform matrix at a given frame.

@type  Frame: int
@param Frame: L{Frame}
@rtype: L{Matrix}
@return: L{Matrix} of the transform.
@see: L{setTransform()}
----------
LocatorEntity.translation
Returns the translation vector at a given frame.

@type  Frame: int
@param Frame: L{Frame}
@rtype: L{VectorN}
@return: Vector of the translation.
----------
Lockable
Provides an interface to objects within Mari that are lockable and hidable.

This includes methods for settings and getting the visible and locked status and signals to indicate when these states are changed.

B{Example Code}

>>> # This examples obtains the patch with UDIM 1001 of current geometry object, and locks it
>>> import mari
>>> patch_1001 = mari.geo.current().patch(0)
>>> patch_1001.lock()
----------
Lockable.hide
Hides the object from view.

@rtype: None
@see: L{show()}, L{setVisibility()}, L{isVisible()}
----------
Lockable.isLocked
Indicates whether this object is locked, and if so, unmodifiable.

@rtype: bool
@return: True if this image is locked, or False if unlocked
@see: L{lock()}, L{unlock()}, L{setLocked()}
----------
Lockable.isVisible
Indicates whether this object is visible.

@rtype: bool
@return: True if the object is visible, or False if not.
@see: L{show()}, L{setVisibility()}, L{hide()}
----------
Lockable.lock
Locks the object to prevent modifications.

@rtype: None
@see: L{isLocked()}, L{setLocked()}, L{unlock()}
----------
Lockable.lockedChanged
This is emitted after the object is locked or unlocked.

@type  Locked: bool
@param Locked: True if the object is now locked, or False otherwise
@rtype: None
----------
Lockable.setLocked
Locks or unlocks the object, to optionally prevent modifications.

@type  Locked: bool
@rtype: None
@see: L{isLocked()}, L{lock()}, L{unlock()}
----------
Lockable.setVisibility
Shows or hides the object.

@type  Visible: bool
@param Visible: True to show the object, or False to hide it.
@rtype: None
@see: L{show()}, L{isVisible()}, L{hide()}
----------
Lockable.show
Shows the object again after a previous L{hide()} operation.

@rtype: None
@see: L{setVisibility()}, L{isVisible()}, L{hide()}
----------
Lockable.unlock
Unlocks the object and allows modifications.

@rtype: None
@see: L{isLocked()}, L{lock()}, L{setLocked()}
----------
Lockable.visibilityChanged
This is emitted after the object is shown or hidden.

@type  Visible: bool
@param Visible: True if this object is now visible, or False otherwise
@rtype: None
----------
LookUpTable
Objects of this class holds 1-dimensional look up table curve.

Curve is defined from a set of control points.

Objects of this class often appears as parameters of shaders and layers

B{Example Code}

>>> # This example creates a "Brightness Lookup" layer and obtains its "Map" parameter, which is of LookUpTable type
>>> import mari
>>> layer = mari.geo.current().currentChannel().createAdjustmentLayer("Test", "Filter/Brightness Lookup")
>>> lut = layer.getPrimaryAdjustmentParameter("Map")
----------
LookUpTable.__init__
Sets to the settings specified by the given components.

@rtype: L{LookUpTable}
----------
LookUpTable.controlPoints
Returns the list of control points as a list of L{VectorN}.

@rtype: list of  L{VectorN}
@return: The list of control points as a list of L{VectorN}
@see: L{setControlPoints()}
----------
LookUpTable.controlPointsAsString
Returns the string representation of the control points of the look up table.

@rtype: str
@return: The string representation of the contol points of the look up table
----------
LookUpTable.invert
Inverts the look up curve.

@rtype: None
----------
LookUpTable.isClamped
Returns whether values outside of [0,1] are clamped.

@rtype: bool
@return: Whether values outside of [0,1] are clamped
----------
LookUpTable.setClamped
Sets whether values outside of [0,1] are clamped.

@type  Clamped: bool
@param Clamped: If True, values outside of [0,1] are clamped
@rtype: None
----------
LookUpTable.setControlPoints
Sets the control points from a given list of L{VectorN}.

@type  ControlPoints: list of  L{VectorN}
@param ControlPoints: The list of control points of L{VectorN}
@rtype: None
@raise ValueError: Raised if the ControlPoints is invalid.
@see: L{controlPoints()}
----------
LookUpTable.setControlPointsFromString
Sets the control points from given string representation of look up table.

@type  ControlPointsString: str
@param ControlPointsString: The string reprentation of control points to set
@rtype: None
----------
LookUpTable.setLinear
Sets the look up table curve to a linear curve.

@type  ValueAtZero: float
@param ValueAtZero: The value to map zero to
@type  ValueAtOne: float
@param ValueAtOne: The value to map one to
@rtype: None
----------
Matrix
Objects of this class hold a matrix 4x4.

B{Example Code}
----------
Matrix.asList
Returns the elements of the matrix as a list of 16 values.

@rtype: tuple of  double
@return: The elements of the matrix
----------
Matrix.length
Returns the length of the vector.

This is the same as size().

@rtype: int
@return: The length of the vector
----------
MenuManager
Manages creation and manipulation of menu entries.

The menu manager creates and manipulates entries on the menus.

Menu paths are all split into three components: the "set" (e.g. "MainWindow" for the main window menu), the "root" (e.g. "File", potentially with an "&" in it for the shortcut key), and the "submenu" (an optional menu under that, such as "Open", also possibly containing "&" characters). This split will be made automatically by the various menu functions, but it is necessary to supply at least a set and a root to add an action.

Path elements should be separated by slashes, and any leading slash is ignored - so using either "MainWindow/File" or "/MainWindow/File" is equivalent.

B{Example Code}

>>> # This example finds the "Print Hello" action from registered actions and add it to the menus
>>> import mari
>>> action = mari.actions.find("Mari/Scripts/MyCustomActions/Print Hello")
>>> #mari.menus.addAction(action,"MainWindow/P&ython/&Examples")

>>> # This example removes the "Print Hello" action from the menus
>>> import mari
>>> #mari.menus.removeAction("MainWindow/P&ython/&Examples/Print Hello")
----------
MenuManager.actions
Returns the actions available for the given set, root and optional sub menu.

C{mari.menus.actions("MainWindow","&File")}

@type  rSet: str
@param rSet: The set containing the root menu to look in.
@type  rRoot: str
@param rRoot: The root menu to look up items in.
@type  rSubMenu: str
@param rSubMenu: The submenu to look up items in.
@rtype: list of  L{Action}
@return: The list of items associated with a given set/root menu/submenu
----------
MenuManager.addAction
Adds an action to the menu in the given path.

C{# Create an example item in the main file menu, before the save option}

C{mari.menus.addAction(mari.actions.create('Create Project And Import', 'mari.examples.create_project.createAndImport()'), "MainWindow/&File/", "/MainWindow/&File/&Save")}

@type  pAction: L{Action}
@param pAction: The existing action to add to the menu.
@type  rPath: str
@param rPath: The menu path to add
@type  rAddBefore: str
@param rAddBefore: The text of an item in the given menu. The new action will be added immediately before the given item. If left blank, the item will be appended to the end of the menu. To add before a separator, pass in any string beginning with '-'. This should be just the name of the item not the full path. To find the list of items in a menu use L{itemNames()}
@rtype: None
@raise ValueError: Raised if the action or path were invalid, or if an item to add before was specified but did not match a valid item in the given menu.
----------
MenuManager.addSeparator
Adds a separator to the menu in the given path.

@type  Path: str
@param Path: The menu path to add
@type  rAddBefore: str
@param rAddBefore: The text of an item in the given menu. The new action will be added immediately before the given item. If left blank, the item will be appended to the end of the menu. To add before another separator, pass in any string beginning with '-'.
@rtype: None
@raise ValueError: Raised if the action or path were invalid, or if an item to add before was specified but did not match a valid item in the given menu.
----------
MenuManager.itemNames
Returns the names of the items available for the given set, root and optional sub menu.

C{mari.menus.itemNames("MainWindow","&File")}

@type  rSet: str
@param rSet: The set containing the root menu to look in.
@type  rRoot: str
@param rRoot: The root menu to look up items in.
@type  rSubMenu: str
@param rSubMenu: The submenu to look up items in.
@rtype: list of str
@return: The list of items associated with a given set/root menu/submenu
----------
MenuManager.removeAction
Removes an action specified by a path from the menu.

@type  rFullPath: str
@param rFullPath: The path to the action, including its name.
@rtype: None
@raise ValueError: Raised if the action was not found.
----------
MenuManager.roots
Returns a list of the root menus available for the given set.

Mari has a hierarchical menu system. Menus may contain other menus. Each set of menus has one or more root menus. These are the items that appear in the menu bar and are presented as context menus.

@type  rSet: str
@param rSet: The set to look up root menus for.
@rtype: list of str
@return: A list of the root menu names.
----------
MenuManager.sets
Returns a list of the available menu sets.

Mari maintains multiple sets of menus. These menus appear in different contexts such as the main window or the context (right click) menus of various palettes. This method returns the list of set names.

@rtype: list of str
@return: The list of available menu sets.
----------
MenuManager.submenus
Returns a list of the submenus available for the given set and root menu.

@type  rSet: str
@param rSet: The set containing the root menu to look in.
@type  rRoot: str
@param rRoot: The root menu to look up submenus in.
@rtype: list of str
@return: The list of sub menus associated with a given root menu
----------
Metadata
An interface for dealing with metadata associated with Mari objects.

Users can add arbitrary amounts of metadata to objects. This metadata can be used for asset management tracking, or any situation where extra information is required for an object.

Items of metadata are stored in the form of string and variant pairs, allowing the use of different types of data. Certain types of metadata have GUI editor components; these are exposed in the "User Attributes" section of the property editor.

B{Example Code}

>>> # This adds a new metadata (i.e. attribute) called "MyVersion" to the current channel
>>> import mari
>>> channel = mari.geo.current().currentChannel()
>>> channel.setMetadata("MyVersion", "2.1")
----------
Metadata.hasMetadata
Indicates whether an item of metadata with the given name exists on the object.

@type  Name: str
@param Name: The name of the metadata item to query
@rtype: bool
@return: True if a metadata item with the given name is associated with this object, or False otherwise
----------
Metadata.isSupportedMetadataType
Returns whether the data type of the argument can be stored as metadata.

Most plain-old data types (e.g., integers, floats and strings) are supported. If the data type you would like to add as metadata is not supported, you should consider serializing it to a unicode string and saving that as metadata instead.

@type  Value: variant
@param Value: An object instance of the type you would like to check.
@rtype: bool
@return: True if the type is supported, and False if not.
----------
Metadata.metadata
Returns the value of an item of metadata.

@type  Name: str
@param Name: The name of the item to query
@rtype: variant
@return: The value of the item.
@raise ValueError: Raised if no metadata item with the given name was found, and no default value was provided.
@see: L{setMetadata()}
----------
Metadata.metadataAsImage
Retrieves the current value of a parameter and, if possible, return the L{Image} it relates to.

@type  Name: str
@param Name: The name of the parameter to inspect.
@rtype: L{Image}
@return: L{Image} of the parameter. None if not image is assigned.
@raise ValueError: Raised if name of the parameter does not match any existing items.
@see: L{metadata()}
----------
Metadata.metadataCreated
This is emitted when a metadata item is added.

@type  Name: str
@param Name: The name of the metadata that has been added.
@type  Value: variant
@param Value: The value of the new metadata item.
@rtype: None
----------
Metadata.metadataDefault
Returns the default value of an item of metadata on the object.

@type  Name: str
@param Name: The name of the item
@rtype: variant
@return: The default value of the item
@raise ValueError: Raised if no metadata item with the given name was found.
@see: L{setMetadataDefault()}
----------
Metadata.metadataDescription
Returns the description of an item of metadata on the object.

@type  Name: str
@param Name: The name of the item
@rtype: str
@return: The description of the item
@raise ValueError: Raised if no metadata item with the given name was found.
@see: L{setMetadataDescription()}
----------
Metadata.metadataDisplayName
Returns the display name of an item of metadata on the object.

@type  Name: str
@param Name: The name of the item
@rtype: str
@return: The display name of the item
@raise ValueError: Raised if no metadata item with the given name was found.
@see: L{setMetadataDisplayName()}
----------
Metadata.metadataFlags
Returns the flags of an item of metadata on the object.

@type  Name: str
@param Name: The name of the item
@rtype: MetadataFlags
@return: The flags of the item
@raise ValueError: Raised if no metadata item with the given name was found.
@see: L{setMetadataFlags()}
----------
Metadata.metadataIsEnabled
Return True if the given item of metadata is enabled.

@type  Name: str
@param Name: The name of the metadata
@rtype: bool
@return: True if the given metadata item is enabled, False otherwise
@raise ValueError: Raised if no metadata item with the given name was found.
----------
Metadata.metadataItemList
Returns the list of strings that the user can select from to choose the value of the metadata item.

@type  Name: str
@param Name: The name of the item
@rtype: list of str
@return: The list of potential value strings. If no list of strings has been set using L{setMetadataItemList()}, the list will be empty.
@raise ValueError: Raised if no metadata item with the given name was found.
@see: L{setMetadataItemList()}
----------
Metadata.metadataMax
Returns the range of an item of metadata on the object.

@type  Name: str
@param Name: The name of the item
@rtype: variant
@return: The maximum value of the item
@raise ValueError: Raised if no metadata item with the given name was found.
----------
Metadata.metadataMin
Returns the range of an item of metadata on the object.

@type  Name: str
@param Name: The name of the item
@rtype: variant
@return: The minimum value of the item
@raise ValueError: Raised if no metadata item with the given name was found.
----------
Metadata.metadataNames
Returns a list of the metadata items associated with this object.

@rtype: list of str
@return: A list of the metadata names
----------
Metadata.metadataRemoved
This is emitted when a item of metadata is removed from this object.

@type  Name: str
@param Name: The name of the metadata item that was removed.
@rtype: None
----------
Metadata.metadataStep
Returns the step size of an item of metadata on the object.

@type  Name: str
@param Name: The name of the item
@rtype: variant
@return: The step size of the item
@raise ValueError: Raised if no metadata item with the given name was found.
@see: L{setMetadataStep()}
----------
Metadata.metadataValueChanged
This is emitted when a metadata item's value is changed.

@type  Name: str
@param Name: The name of the metadata that has been changed.
@type  Value: variant
@param Value: The new value of the metadata item.
@rtype: None
----------
Metadata.removeMetadata
Removes an item of metadata.

@type  Name: str
@param Name: The name of the medata item to remove
@rtype: None
@raise ValueError: Raised if no metadata item with the given name was found.
----------
Metadata.setMetadata
Adds or modifies an item of metadata on the object.

If a metadata item with the given name exists already, its value will be updated. If not, a new one will be created.

@type  Name: str
@param Name: The name of the item
@type  Value: variant
@param Value: The value of the item
@rtype: None
@raise ValueError: Raised if the type of the value is not supported by the metadata system.
@see: L{metadata()}
----------
Metadata.setMetadataDefault
Modifies the default value of an item of metadata on the object.

If a metadata item with the given name exists already, its default value will be updated.

@type  Name: str
@param Name: The name of the item
@type  Default: variant
@param Default: The default value of the item
@rtype: None
@raise ValueError: Raised if no metadata item with the given name was found.
@see: L{metadataDefault()}
----------
Metadata.setMetadataDescription
Modifies the description of an item of metadata on the object.

If a metadata item with the given name exists already, its description will be updated.

@type  Name: str
@param Name: The name of the item
@type  Description: str
@param Description: The description of the item
@rtype: None
@raise ValueError: Raised if no metadata item with the given name was found.
@see: L{metadataDescription()}
----------
Metadata.setMetadataDisplayName
Modifies the display name of an item of metadata on the object.

If a metadata item with the given name exists already, its display name will be updated.

@type  Name: str
@param Name: The name of the item
@type  DisplayName: str
@param DisplayName: The display name of the item
@rtype: None
@raise ValueError: Raised if no metadata item with the given name was found.
@see: L{metadataDisplayName()}
----------
Metadata.setMetadataEnabled
Set the enabled flag for the given item of metadata.

@type  Name: str
@param Name: The name of the metadata
@type  Enabled: bool
@param Enabled: The new enabled state of the metadata item
@rtype: None
@raise ValueError: Raised if no metadata item with the given name was found.
----------
Metadata.setMetadataFlags
Modifies the flags of an item of metadata on the object.

If a metadata item with the given name exists already, its flags will be updated.

@type  Name: str
@param Name: The name of the item
@type  Flags: MetadataFlags
@param Flags: The flags of the item
@rtype: None
@raise ValueError: Raised if no metadata item with the given name was found.
@see: L{metadataFlags()}
----------
Metadata.setMetadataGroupHints
Modifies the group hint of an item of metadata on the object.

If a metadata item with the given name exists already, its flags will be updated.

@type  Name: str
@param Name: The name of the item
@type  Hints: MetadataGroupHints
@param Hints: The hint of the item
@rtype: None
@raise ValueError: Raised if no metadata item with the given name was found.
----------
Metadata.setMetadataItemList
Sets a list of strings that the user can select from to choose the value of the metadata item.

If a metadata item with the given name exists already, its item list will be updated.

@type  Name: str
@param Name: The name of the item
@type  ItemList: list of str
@param ItemList: The item list of the item
@rtype: None
@raise ValueError: Raised if no metadata item with the given name was found.
@see: L{metadataItemList()}
----------
Metadata.setMetadataRange
Modifies the range of an item of metadata on the object.

If a metadata item with the given name exists already, its range will be updated.

@type  Name: str
@param Name: The name of the item
@type  Min: variant
@param Min: The minimum value of the item
@type  Max: variant
@param Max: The maximum value of the item
@rtype: None
@raise ValueError: Raised if no metadata item with the given name was found.
----------
Metadata.setMetadataStep
Modifies the step size of an item of metadata on the object.

If a metadata item with the given name exists already, its step size will be updated.

@type  Name: str
@param Name: The name of the item
@type  Step: variant
@param Step: The step size of the item
@rtype: None
@raise ValueError: Raised if no metadata item with the given name was found.
@see: L{metadataStep()}
----------
Metadata.uuid
Return a UUID that uniquely identifies this object.

Mari maintains a unique ID for each object, this will return that UUID 
C{print mari.current.channel().uuid()}

@rtype: str
@return: A String containing the UUID for the object
----------
Node
Provides shader node graph functionality.

B{Example Code}

>>> # This example obtains a node from the node graph of the current geo entity
>>> import mari
>>> nodeGraph = mari.geo.current().nodeGraph()
>>> node = nodeGraph.nodeList()[0]
----------
Node.addNodeContext
Adds the given L{Context} to this node with the given L{Name}.

@type  Name: str
@param Name: The name of the L{Context} is added under.
@type  Context: L{NodeContext}
@param Context: The L{NodeContext} object to add.
@rtype: None
@raise RuntimeError: Raised if the L{NodeContext} cannot be added.
----------
Node.addTag
Adds the given tag to this node.

All system tags are prefixed by underscores(_).Tags with underscores cannot be added unless L{ForceAdd} is True.

@type  Tag: str
@param Tag: The tag to add.
@type  ForceAdd: bool
@param ForceAdd: Force adding the tag even if the given tag is considered a system tag.
@rtype: None
@raise RuntimeError: Raised if the given tag cannot be added.
----------
Node.attachViewer
Connects the viewer to this node for glsl rendering on the canvas.

@type  InputNumber: int
@param InputNumber: A number of the viewer's input that the node should be connected to. It should be in a range from 1 to 9.
@rtype: None
----------
Node.bake
Bakes the result at the current node into an L{ImageSet} and returns the L{PaintNode} owning the L{ImageSet}.

@type  Width: int
@param Width: The default width of the L{ImageSet} (ignored for L{Ptex})
@type  Height: int
@param Height: The default height of the (ignored for L{Ptex})
@type  Depth: int
@param Depth: The default bit depth of the L{ImageSet}
@rtype: L{PaintNode}
@raise RuntimeError: Raised if the PainNode could not be created
----------
Node.bypassInput
Returns the index of input passed to the output bypassing this node.

Bypassing a node effectively disables this node and pass an input straight to the output. This method allows to set which input is passed to the output.

@rtype: int
@return: -1 if this node is processed in the normal manner. If this node is bypassed, then the index of input passed to the output bypassing this node is returned
@see: L{setBypassInput()}
----------
Node.hasTag
Returns whether this node has the given tag.

@type  Tag: str
@rtype: bool
@return: Whether this node has the given tag.
----------
Node.hash
Returns a unique identifier for this node and its children.

This hash is assumed to be universally unique (256bit skein hash). This can be used to determine if this node or any of its connected child has changed since some given checkpoint. This hash is based on image data, parameters and anything that might effect the pixel output. Use this to detect any changes to a node, in the node graph.

@type  UVIndex: int
@param UVIndex: The UV index of the patch to return the hash of, or -1 (default) to return the hash of all the patches.
@type  IgnoreChildren: bool
@param IgnoreChildren: A flag to specify whether we only want the hash of this node itself or whether we want an accumulative hash of this node and its connected children (default value).
@rtype: str
@return: A hash string that uniquely identifies a node and its childrens, or an empty string on failure.
----------
Node.inputNode
Returns the node connected to the given input port name .

If no node is connected, None is returned.

@type  PortName: str
@param PortName: The name of the port to which the returned node is connected.
@rtype: L{Node}
@return: The node connected to the given port name. If no node is connected, None is returned.
@see: L{setInputNode()}
----------
Node.inputPortCount
Returns the number of input point count.

@rtype: int
@return: The number of input port count.
----------
Node.inputPortName
Returns the input port name at the given index.

@type  Index: int
@rtype: str
@return: The input port name at the given index.
----------
Node.inputPortNames
Returns a list of all the names of the input points of this node.

@rtype: list of str
@return: The list of input port names.
----------
Node.isBakePointNode
Returns whether this node is a L{BakePointNode}.

@rtype: bool
@return: Whether this node is a L{BakePointNode}
----------
Node.isGroupNode
Returns whether this node is an L{GroupNode}.

@rtype: bool
@return: Whether this node is an L{GroupNode}
----------
Node.isPaintNode
Returns whether this node is a L{PaintNode}.

@rtype: bool
@return: Whether this node is a L{PaintNode}
----------
Node.isSelected
Returns whether this node is selected.

@rtype: bool
@return: Whether this node is selected.
----------
Node.name
Returns the name of the node.

@rtype: str
@return: The name of this node.
@see: L{setName()}
----------
Node.nodeContext
Returns the L{NodeContext} of the given name.

@type  Name: str
@param Name: The name of the L{NodeContext}
@rtype: L{NodeContext}
@return: The L{NodeContext} of the given name
----------
Node.nodeContextNames
Returns the names of L{NodeContext} this L{Node} holds.

@rtype: list of str
@return: The list of names of L{NodeContext} this L{Node} holds
----------
Node.nodeInformation
Gets vital information about the node such as its inputs, attributes and outputs.

@rtype: str
@return: Vital node information.
----------
Node.nodeName
Returns the name of the node.

@rtype: str
@return: The name of the node.
@deprecated: This function will be removed in a future version. Please use L{name()} instead.
@see: L{setNodeName()}
----------
Node.parentNodeGraph
Returns the L{NodeGraph} this L{Node} belongs to.

@rtype: L{NodeGraph}
@return: L{NodeGraph} object this L{Node} belongs to.
----------
Node.printVersionHashSource
Prints the node's source that is hashed and compared at upgrade time.

@rtype: None
----------
Node.removeNodeContext
Removes the Context from this node with the given L{Name}.

@type  Name: str
@param Name: The name of the Context to be removed.
@rtype: None
@raise RuntimeError: Raised if the L{NodeContext} cannot be removed.
----------
Node.removeTag
Removes the given tag to this node.

All system tags are prefixed by underscores(_).Tags with underscores cannot be removed unless L{ForceRemove} is True.

@type  Tag: str
@param Tag: The tag to remove.
@type  ForceRemove: bool
@param ForceRemove: Force removing the tag even if the given tag is considered a system tag.
@rtype: None
@raise RuntimeError: Raised if the given tag cannot be removed.
----------
Node.setBypassInput
Set which input value is passed to output bypassing this node.

Bypassing a node effectively disables this node and pass an input straight to the output. This method allows to set which input is passed to the output.

@type  BypassInput: int
@param BypassInput: The index of the input to pass to output instead of processing this node. If -1 is given, no input is passed to the output and the result of processing node is passed to the output.
@rtype: None
@see: L{bypassInput()}
----------
Node.setInputNode
Connects the given node to the given input port name.

@type  PortName: str
@param PortName: The name of the port to which the given node is connected.
@type  NodeToConnect: L{Node}
@param NodeToConnect: The node to connect to the input port name. If None, the input port gets disconnected.
@rtype: None
@return: The node connected to the given port name. If no node is connected, None is returned.
@raise RuntimeError: Raised if this node and NodeToConnect belong to different node graphs. Also raised if the connection would break DAG.
@see: L{inputNode()}
----------
Node.setMetadata
Adds or modifies an item of metadata on the object.

If a metadata item with the given name exists already, its value will be updated. If not, a new one will be created. This overrides L{Metadata.setMetadata()}

@type  Name: str
@param Name: The name of the item
@type  Value: variant
@param Value: The value of the item
@rtype: None
@raise ValueError: Raised if the type of the value is not supported by the metadata system.
----------
Node.setName
Sets the name of the node.

@type  NewName: str
@param NewName: The new name for the node.
@rtype: None
@see: L{name()}
----------
Node.setNodeName
Sets the name of the node.

@type  NewName: str
@param NewName: The new name of the node.
@rtype: None
@deprecated: This function will be removed in a future version. Please use L{setName()} instead.
@see: L{nodeName()}
----------
Node.setSelected
Sets whether this node is selected.

@type  Selected: bool
@param Selected: If True, this node will be selected. If False, this node wil be deselected.
@rtype: None
----------
Node.setTypeID
Sets the type of this node.

This overwrites the node's type information. The type information is used for the node upgrade mechanism. Once the node's typeID is changed, the node will not be upgraded when the original node's XML file has changed.

@type  TypeID: str
@param TypeID: The type of node to set this node to.
@rtype: None
@see: L{typeID()}
----------
Node.tagList
Returns the list of tags this node holds.

@rtype: list of str
@return: The list of tags this node holds.
----------
Node.typeID
Returns the type of this node.

@rtype: str
@return: The type of this node.
@see: L{setTypeID()}
----------
NodeContext
Provides shader node graph context functionality.

L{NodeContext} is a patricular context attached to a node. For example, the GLSL context of a node is how the node is represented in GLSL so that the GLSL code is used when rendered in the view port.

L{NodeContext} mechanism is used to add some custom contextual information to a node. A common usage would be to attach information about offline renderer so that the node graph can be processed and translated into the language of the offline renderer.

Each L{NodeContext} attached to a L{Node} is stored in Mari.
----------
NodeContext.__init__
Sets to the settings specified by the given components.

@rtype: L{NodeContext}
----------
NodeContext.metadataSupported
Return whether the given metadata is supported by this context.

A metadata supported by any context will be enabled for editing in the node property UI.

@type  MetadataName: str
@param MetadataName: The name of the metadata to query
@rtype: bool
@see: L{setMetadataSupported()}
----------
NodeContext.setMetadataSupported
Sets whether the metadata of the parent node is supported by this context.

A metadata supported by any context will be enabled for editing in the node property UI.

@type  MetadataName: str
@param MetadataName: The name of the metadata to set the support
@type  Supported: bool
@param Supported: Whether the specified metadata is supported
@rtype: None
@see: L{metadataSupported()}
----------
NodeGraph
Provides shader node graph functionality.

B{Example Code}

This example creates a Perlin node and Merge node, connect them and sets a property

>>> # obtain the root level node graph of the current geo entity
>>> import mari
>>> nodeGraph = mari.geo.current().nodeGraph()
>>>
>>> # Obtain the list of node types
>>> nodeTypeList = nodeGraph.typeList()
>>>
>>> # Create perlin noise node
>>> perlin = nodeGraph.createNode("Procedural/Noise/Perlin")
>>>
>>> # Create a merge node
>>> merge = nodeGraph.createNode("Layer/Merge")
>>>
>>> # Connect the perlin node to the Base input of the merge node
>>> merge.setInputNode("Base",perlin)
>>>
>>> # Obtain parameters of the merge node
>>> parameterNames = merge.metadataNames()
>>>
>>> # Set the BlendAmount of merge node to 0.5
>>> merge.setMetadata("Amount",0.5)

This example shows how to create a L{PaintNode}

>>> paintNode = nodeGraph.createPaintNode( 1024, 1024, 8, mari.Color(1.0,1.0,0.0,1.0) )
----------
NodeGraph.addNode
Adds the given node to this node graph

@type  NodeToAdd: L{Node}
@param NodeToAdd: The L{Node} to be added.
@rtype: None
----------
NodeGraph.bakeEmptyAndUpdateOutOfDateBakePoints
Bake all empty bake point nodes and update any out of date bake point nodes in the graph.

@rtype: None
----------
NodeGraph.bakeSelectedBakePoints
Bake all the selected bake point nodes in the graph, where we bake any of the selected nodes.

@rtype: None
----------
NodeGraph.createBakePointNode
Creates a L{BakePointNode} with given settings.

@type  Width: int
@param Width: The default width of the L{ImageSet} (ignored for L{Ptex}) to bake into
@type  Height: int
@param Height: The default height of the (ignored for L{Ptex}) to bake into
@type  Depth: int
@param Depth: The default bit depth of the L{ImageSet} to bake into
@type  FillColor: L{Color}
@param FillColor: The color to fill the initial L{ImageSet} to bake into
@rtype: L{BakePointNode}
@raise RuntimeError: Raised if the L{PaintNode} could not be created
----------
NodeGraph.createNode
Creates a node of the given type.

B{Example Code}

This example creates a tri planar node.

>>> # obtain the root level node graph of the current geo entity
>>> import mari
>>> nodeGraph = mari.geo.current().nodeGraph()
>>>
>>> # Create a tri planar node "Projection/Tri Planar Projection"
>>> nodeGraph.createNode("Projection/Tri Planar Projection")
>>>
>>> # Create a tri planar node using the deprecated key "Environment/Tri Planar Projection"
>>> # This should give you a deprecation warning on your console
>>> nodeGraph.createNode("Environment/Tri Planar Projection")

@type  Type: str
@param Type: The type of the node to be created.
@rtype: L{Node}
@raise RuntimeError: Raised if the given type is not valid.
----------
NodeGraph.createPaintNode
Creates a paintable node with given settings.

@type  Width: int
@param Width: The default width of the L{ImageSet} (ignored for L{Ptex})
@type  Height: int
@param Height: The default height of the (ignored for L{Ptex})
@type  Depth: int
@param Depth: The default bit depth of the L{ImageSet}
@type  FillColor: L{Color}
@param FillColor: The color to fill the initial L{ImageSet} in.
@rtype: L{PaintNode}
@raise RuntimeError: Raised if the L{PaintNode} could not be created
----------
NodeGraph.deleteNode
Deletes the given node.

@type  NodeToDelete: L{Node}
@param NodeToDelete: The L{Node} to be deleted.
@rtype: None
@raise RuntimeError: Raised if the given node does not belong to this node graph.
----------
NodeGraph.exportNodesAsArchive
Saves the archive of the given nodes to the given location.

This saves the given nodes in an XML format and saves all dependencies into the given directory If the given location does not exist, it is created. If there are any exising files and directories, they will be deleted.

The nodes saved in the XML file as part of the archive are assigned with new unique UUIDs for sanity. The map returned by this function contains the mapping of the original node UUIDs to the unique UUIDs of the nodes in the XML file. A partial list of the new unique UUIDs can be given as an optional argument to L{importNodesFromArchive()} to load a partial set of nodes from the archive.

@type  DirPath: str
@param DirPath: The directory path to save the nodes archive to.
@type  Nodes: list of  L{Node}
@param Nodes: The list of nodes to save as archive.
@type  NoDataBlockCopy: bool
@param NoDataBlockCopy: Whether to skip copying data blocks. If True, the images are copied only as template, but without texture data. This is False by default.
@type  UVIndexList: list of  int
@param UVIndexList: Pass in a list of zero-based UV indices if desired to specify the patches to export images for. If not specified or empty, images will be exported for all indices. The UDIM for a patch is the zero-based UV index plus 1001.
@rtype: QHash of  str, str
@return: Returns the map of original node UUIDs to the new unique UUIDs stored in the node XML file of the archive.
----------
NodeGraph.getUpstreamNodes
Returns the list of nodes in the upstream of the given node.

@type  DestNode: L{Node}
@param DestNode: The destination node from which this function returns the upstream nodes.
@rtype: list of  L{Node}
@return: The list of nodes in the upstream of L{DestNode}
----------
NodeGraph.groupNodes
Groups the given nodes and returns the resulting L{GroupNode}.

@type  Nodes: list of  L{Node}
@param Nodes: the list of nodes to group.
@rtype: L{GroupNode}
@return: The new L{GroupNode} containing the given nodes.
@raise RuntimeError: Raised if any of the Nodes does not belong to this L{NodeGraph}.
----------
NodeGraph.importNodesFromArchive
Loads nodes from the archive directory exported by exportNodesAsArchive.

@type  DirPath: str
@param DirPath: The directory path to the node archive
@type  UuidsToLoad: list of str
@param UuidsToLoad: The list of UUID of nodes to partially load from the archive. If empty, all the nodes in the archive are loaded.
@type  UvIndexMap: QHash of  int, list of  int
@param UvIndexMap: Map to specify remapping of patches based on UvIndex. E.g. provide {0:[1,2],3:[]} to copy UV patch 0 to 1 and 2, then remove UV patch 3. If this argument is non-empty. It should be all inclusive. Patches not included in this map will be discarded.
@rtype: list of  L{Node}
@return: Returns the list of nodes imported from the archive
----------
NodeGraph.load
Loades the nodes in the file into this L{NodeGraph} and returns the loaded nodes.

@type  FilePath: str
@param FilePath: The file path from which the nodes areloaded.
@rtype: list of  L{Node}
@return: The loaded nodes.
----------
NodeGraph.nodeList
Returns a list of the nodes in this node graph.

B{Example Code}

This example returns a list of nodes in the root nodegraph of the currently-selected geoentity.

>>> # obtain the root level node graph of the current geo entity
>>> import mari
>>> nodeGraph = mari.geo.current().nodeGraph()
>>>
>>> # Obtain the list of node types
>>> nodeList = nodeGraph.nodeList()
>>>
>>> # Print the count of nodes
>>> print("+ %d nodes found" % (len(nodeList))

@rtype: list of  L{Node}
@return: A list of the nodes in this node graph.
----------
NodeGraph.nodesFromString
Loads and returns the nodes in the string into this L{NodeGraph}.

This takes in the string returnd by L{nodesToString()} and loads the nodes into this L{NodeGraph}.

@type  String: str
@param String: The string in which nodes are contained.
@rtype: list of  L{Node}
@return: Returns the nodes loaded.
----------
NodeGraph.nodesToString
Returns the string representation of the given nodes.

The returned string can be useful for copy&paste purpose. L{save()} will save this string into the resulting file.

@type  Nodes: list of  L{Node}
@param Nodes: The nodes to represent in the string.
@rtype: str
@return: The string represending the L{Nodes}.
@raise RuntimeError: Raised if any of the Nodes does not belong to this L{NodeGraph}.
----------
NodeGraph.nodesWithTag
Returns the list of nodes having the given L{Tag}.

@type  Tag: str
@param Tag: The tag of the nodes to be returned.
@rtype: list of  L{Node}
@return: The list of nodes having the given L{Tag}.
----------
NodeGraph.parentGeoEntity
Return the L{GeoEntity} this L{NodeGraph} belongs to if this L{NodeGraph} is not the root level network (i.e.

does not belong to a L{GroupNode}).

@rtype: L{GeoEntity}
@return: The L{GeoEntity} this L{NodeGraph} belongs to.
----------
NodeGraph.parentGroupNode
Returns the parent L{GroupNode} if this L{NodeGraph} is the child node graph of the L{GroupNode}.

@rtype: L{GroupNode}
@return: The parent L{GroupNode}
----------
NodeGraph.removeNode
Removes the given node from this node graph

@type  NodeToRemove: L{Node}
@param NodeToRemove: The L{Node} to be removed.
@rtype: None
----------
NodeGraph.save
Saves the given node to the specified file.

@type  FilePath: str
@param FilePath: The file path to save the given nodes to.
@type  Nodes: list of  L{Node}
@param Nodes: The nodes to save to the given file path.
@rtype: None
@raise RuntimeError: Raised if any of the Nodes does not belong to this L{NodeGraph}.
----------
NodeGraph.selectedNodeList
Returns a list of selected nodes in this node graph.

B{Example Code}

This example returns the list of selected nodes in the root nodegraph of the currently-selected geoentity.

>>> # obtain the root level node graph of the current geo entity
>>> import mari
>>> nodeGraph = mari.geo.current().nodeGraph()
>>>
>>> # Get the selected nodes
>>> selectedNodeList = nodeGraph.selectedNodeList()
>>>
>>> # Print the count of nodes
>>> print("+ %d selected nodes found" % (len(selectedNodeList))

@rtype: list of  L{Node}
@return: A list of the selected nodes in this node graph.
----------
NodeGraph.setActiveViewerInput
Changes the active Viewer node's input.

@type  InputNumber: int
@param InputNumber: Number of the new active Viewer node's input. It should be in a range from 0 to 9.
@rtype: None
----------
NodeGraph.topologicalSortTo
Returns the topologically sorted list of nodes towards the L{DestNode}.

@type  DestNode: L{Node}
@param DestNode: The destination node to topological sort nodes towards.
@type  ReverseOrder: bool
@param ReverseOrder: If True, the returned list will be in the reverse order.
@rtype: list of  L{Node}
@return: The topologically sorted list of nodes.
----------
NodeGraph.typeList
Returns a list of the types of nodes that can be created.

@rtype: list of str
@return: A list of the types of nodes that can be created.
----------
NodeGraph.updateSelectedBakePoints
Update all the selected bake point nodes in the graph, where we re-bake any of the out of date bake point nodes.

@rtype: None
----------
NodeGraph.viewerNode
Returns the viewer node of the node graph.

Mari's viewport shows the result of all the node graph processing up to the viewer node. The viewer node is a node to specify which node to view the node graph processing.

@rtype: L{Node}
@return: The viewer node of the node graph.
----------
NodeGraph.wouldConnectionBreakDAG
Returns whether the given connection would break directed acyclic graph (DAG).

This function tests whether making the connection between L{SourceNode} and DesNode would break directed acyclic graph.

@type  SourceNode: L{Node}
@param SourceNode: The source node of potential connection to test the DAG breakage.
@type  DestNode: L{Node}
@param DestNode: The destination node of potential connection to test the DAG breakage.
@rtype: bool
@return: Whether the connection would break DAG.
@raise RuntimeError: Raised if the two inputs do not belong to the same node graph.
----------
NodeManager.nodeCreated
This is emitted after a new node has been created.

@type  pNewNode: L{Node}
@param pNewNode: The newly-added node
@rtype: None
----------
ObjectSelectionGroup
A specialised selection group that consists of objects.
----------
ObjectSelectionGroup.geoEntityList
@rtype: list of  L{GeoEntity}
@return: A list of the objects associated to this selection group.
----------
OpenColorIO
Handles the L{OpenColorIO} colorspace transforms in the application.
----------
OpenColorIO.colorPickerMode
Returns the method in which we are to display color swatches and pickers.

@rtype: L{ColorPickerMode}
@return: The mode of the color swatches and pickers.
@see: L{setColorPickerMode()}
----------
OpenColorIO.colorPickerModeChanged
This is emitted after the method in which we are to display color swatches and pickers is modified.

@type  Mode: L{OpenColorIO.ColorPickerMode}
@rtype: None
----------
OpenColorIO.colorspace
Returns the colorspace at a position within an OCIO config file.

@type  Config: str
@param Config: The name of a standard OCIO config file or the path to a custom one.
@type  Index: int
@param Index: The index of the colorspace to return.
@rtype: str
@return: The colorspace at a particular position in the OCIO config file.
@raise ValueError: Raised if the OCIO config file is invalid or the index is out of range.
----------
OpenColorIO.colorspaceCount
Returns the number of colorspaces within an OCIO config file.

This doesn't include the extra options for the stages such as 'Automatic'.

@type  Config: str
@param Config: The name of a standard OCIO config file or the path to a custom one.
@rtype: int
@return: The number of colorspaces in the OCIO config file.
@raise ValueError: Raised if the OCIO config file is invalid.
----------
OpenColorIO.configDescription
Returns the internal description of an OCIO config file.

@type  Config: str
@param Config: The name of a standard OCIO config file or the path to a custom one.
@rtype: str
@return: The internal description of the OCIO config file.
@raise ValueError: Raised if the OCIO config file is invalid.
----------
OpenColorIO.currentColorspaceConfig
Returns the current colorspace configuration.

This will be the configuration of the current active image set. If no image set is active then the configuration of the current channel is returned. If no current configuration is active then None is returned.

@rtype: L{ColorspaceConfig}
@return: The current colorspace defaults.
----------
OpenColorIO.currentColorspaceDefaults
Returns the current colorspace defaults.

When a project is opened then this will be the colorspace defaults of the project. And if a project is not opened this will the global defaults for Mari.

@rtype: L{ColorspaceDefaults}
@return: The current colorspace defaults.
----------
OpenColorIO.defaultConfig
Returns the name of the standard OCIO config file used by default.

@rtype: str
@return: The name of the default OCIO config file.
----------
OpenColorIO.hasColorspace
Indicates whether a colorspace or role is present within an OCIO config file.

@type  Config: str
@param Config: The name of a standard OCIO config file or the path to a custom one.
@type  Name: str
@param Name: The name of the colorspace or role to look for.
@rtype: bool
@return: True if the colorspace is present, False otherwise.
----------
OpenColorIO.hasRole
Indicates whether a role is present within an OCIO config file.

@type  Config: str
@param Config: The name of a standard OCIO config file or the path to a custom one.
@type  Name: str
@param Name: The name of the role to look for.
@rtype: bool
@return: True if the role is present, False otherwise.
----------
OpenColorIO.isConfigValid
Indicates whether an OCIO config file is valid.

@type  Config: str
@param Config: The name of a standard OCIO config file or the path to a custom one.
@rtype: bool
@return: True if the OCIO config file is valid, False otherwise.
----------
OpenColorIO.isShaderTransformAccurate
Returns True if the given transform is accurate when run in shaders on the GPU.

By default False is returned if the transform requires a 3D LUT on the GPU, and True if no 3D LUT is required. Users can override the default and set the minimum 3D LUT size required for it to be accurate using the 'setShaderTransformAccuracy' method.

@type  Config: str
@param Config: The name of a standard OCIO config file or the path to a custom one.
@type  InputColorspace: str
@param InputColorspace: The colorspace of the input image
@type  OutputColorspace: str
@param OutputColorspace: The colorspace of the output image
@type  LutSize: int
@param LutSize: The size of the 3D LUT texture used on the GPU.
@rtype: bool
@return: Whether the corresponding colorspace transform will be accurate when run in shaders on the GPU.
@raise ValueError: Raised if the OCIO config file or either the input and output colorspaces are invalid.
----------
OpenColorIO.isStandardConfig
Returns True if a name is one of the standard OCIO config files packaged with Mari.

@type  Name: str
@param Name: The name to check.
@rtype: bool
@return: True if the name is a standard OCIO config.
----------
OpenColorIO.isTransformValid
Returns True if a colorspace transform is valid.

@type  Config: str
@param Config: The name of a standard OCIO config file or the path to a custom one.
@type  InputColorspace: str
@param InputColorspace: The colorspace of the input color
@type  OutputColorspace: str
@param OutputColorspace: The colorspace of the output color
@rtype: bool
@return: True if the transform is valid; False otherwise.
@raise ValueError: Raised if the OCIO config file or either the input and output colorspaces are invalid.
----------
OpenColorIO.lutSize
Returns the size of the 3D LUT used in color-correcting the user interface.

@rtype: int
@return: The size of the 3D LUT.
@see: L{setLutSize()}
----------
OpenColorIO.lutSizeChanged
This is emitted after the size of the 3D LUT used in color-correcting the user interface is modified.

@type  Size: int
@rtype: None
----------
OpenColorIO.parseColorspaceFromString
Returns the longest, right-most, colorspace substring from the given string.

@type  Config: str
@param Config: The name of a standard OCIO config file or the path to a custom one.
@type  Str: str
@param Str: The string to parse for colorspace.
@rtype: str
@return: The longest, right-most, colorspace substring.
@raise ValueError: Raised if the OCIO config file or either the input and output colorspaces are invalid.
----------
OpenColorIO.role
Returns the role at a position within an OCIO config file.

@type  Config: str
@param Config: The name of a standard OCIO config file or the path to a custom one.
@type  Index: int
@param Index: The index of the role to return.
@rtype: str
@return: The role at a particular position in the OCIO config file.
@raise ValueError: Raised if the OCIO config file is invalid or the index is out of range.
----------
OpenColorIO.roleCount
Returns the number of roles within an OCIO config file.

@type  Config: str
@param Config: The name of a standard OCIO config file or the path to a custom one.
@rtype: int
@return: The number of roles in the OCIO config file.
@raise ValueError: Raised if the OCIO config file is invalid.
----------
OpenColorIO.setColorPickerMode
Sets the method in which we are to display color swatches and pickers.

@type  Mode: L{ColorPickerMode}
@param Mode: The mode of the color swatches and pickers.
@rtype: None
@raise ValueError: Raised if the mode is invalid.
@see: L{colorPickerMode()}
----------
OpenColorIO.setLutSize
Sets the size of the 3D LUT used in color-correcting the user interface.

The size must be either 16, 32, 64, or 128.

@type  Size: int
@rtype: None
@raise ValueError: Raised if the size is invalid.
@see: L{lutSize()}
----------
OpenColorIO.setShaderTransformAccuracy
Sets the minimum size the 3D LUT needs to be for the transform to be considered accurate when run in shaders on the GPU.

@type  Config: str
@param Config: The name of a standard OCIO config file or the path to a custom one.
@type  InputColorspace: str
@param InputColorspace: The colorspace of the input image
@type  OutputColorspace: str
@param OutputColorspace: The colorspace of the output image
@type  MinimumLutSize: int
@param MinimumLutSize: The minimum size of the 3D LUT texture used on the GPU needs to be for the transform to accurate.
@rtype: None
@raise ValueError: Raised if the OCIO config file or either the input and output colorspaces are invalid. Also if the transform doesn't require a 3D LUT texture.
----------
OpenColorIO.setShaderTransformCode
Sets the associated GLSL source code to use, for the given transform, when run on the GPU.

This overrides the code returned by the L{OpenColorIO} library and can be used to give a more optimal transform.

>>> # This example overrides the 'sRGB' to 'linear' transform to avoid the use of the standard 3D LUT texture and give better accuracy
>>> mari.ocio.setShaderTransformCode(
>>> 'nuke-default',
>>> 'sRGB',
>>> 'linear',
>>> '''
>>> vec3 v1 = #Input.rgb;
>>> bvec3 mask = greaterThan(v1, vec3(0.04045));
>>> vec3 v2 = v1 / vec3(12.92);
>>> v1 = pow((v1 + vec3(0.055)) / vec3(1.055), vec3(2.4));
>>> #Output = vec4(mix(v2, v1, mask), #Input.a);
>>> ''')

@type  Config: str
@param Config: The name of a standard OCIO config file or the path to a custom one.
@type  InputColorspace: str
@param InputColorspace: The colorspace of the input image
@type  OutputColorspace: str
@param OutputColorspace: The colorspace of the output image
@type  Code: str
@param Code: The GLSL source code to use for the transform on the GPU.
@rtype: None
@return: Whether the corresponding colorspace transform will be accurate when run in shaders on the GPU.
@raise ValueError: Raised if the OCIO config file or either the input and output colorspaces are invalid. Also if the shader input or shader output are missing from the given GLSL source code.
----------
OpenColorIO.shaderTransformUsesLut
Returns True if the given transform requires a 3D LUT when run in shaders on the GPU.

This can be useful in determining how accurate the transform will be when run on the GPU as a 3D LUT is only an approximation so can introduce more error.

@type  Config: str
@param Config: The name of a standard OCIO config file or the path to a custom one.
@type  InputColorspace: str
@param InputColorspace: The colorspace of the input image
@type  OutputColorspace: str
@param OutputColorspace: The colorspace of the output image
@rtype: bool
@return: Whether the corresponding colorspace transform requires the use a 3D LUT texture on the GPU.
@raise ValueError: Raised if the OCIO config file or either the input and output colorspaces are invalid.
----------
OpenColorIO.standardConfigPath
Returns the absolute path of a standard OCIO config file packaged with Mari.

@type  Config: str
@param Config: The name of a standard OCIO config file packaged with Mari.
@rtype: str
@return: The absolute path to the OCIO config file.
@raise ValueError: Raised if 'Config' is not the name of a standard OCIO config file packaged with Mari.
----------
OpenColorIO.standardConfigs
Returns the names of the standard OCIO config files packaged with Mari.

@rtype: list of str
@return: A list of all standard OCIO config files packaged with Mari.
----------
OpenColorIO.toColorspace
Returns the corresponding colorspace for a role.

@type  Config: str
@param Config: The name of a standard OCIO config file or the path to a custom one.
@type  Role: str
@param Role: The role to return the corresponding colorspace for.
@rtype: str
@return: The colorspace that corresponds to the role.
@raise ValueError: Raised if the OCIO config file is invalid.
----------
OpenColorIO.transformColor
Applies a colorspace transform on a color value.

@type  Config: str
@param Config: The name of a standard OCIO config file or the path to a custom one.
@type  InputColorspace: str
@param InputColorspace: The colorspace of the input color
@type  OutputColorspace: str
@param OutputColorspace: The colorspace of the output color
@type  InputColor: L{Color}
@param InputColor: The color value to transform.
@rtype: L{Color}
@return: The resulting transformed output color value
@raise ValueError: Raised if the OCIO config file or either the input and output colorspaces are invalid.
----------
OpenColorIO.transformImage
Applies a colorspace transform from the given input colorspace to the given output colorspace on the given MriImage.

@type  Config: str
@param Config: The name of a standard OCIO config file or the path to a custom one.
@type  InputColorspace: str
@param InputColorspace: The colorspace of the input image
@type  OutputColorspace: str
@param OutputColorspace: The colorspace of the output image
@type  InputImage: L{Image}
@param InputImage: The image to transform.
@rtype: L{Image}
@return: The resulting transformed output image
@raise ValueError: Raised if the OCIO config file or either the input and output colorspaces are invalid.
----------
PaintBuffer
The paint buffer is the screen aligned plane that users paint onto.

It can be accessed from the L{CanvasManager} - for example: C{mari.canvases.paintBuffer()}

B{Example Code}

>>> # This example shows how to set or get the paint buffer depth
>>> import mari
>>> paint_buffer = mari.canvases.paintBuffer()
>>> original_depth = paint_buffer.depth()
>>> paint_buffer.setDepth(8)
>>> paint_buffer.depth()
8
>>> paint_buffer.setDepth(original_depth)
----------
PaintBuffer.aboutToBake
This is emitted just before baking occurs.

@rtype: None
----------
PaintBuffer.aboutToClear
This is emitted just before the paint buffer is cleared.

@rtype: None
----------
PaintBuffer.bake
Bakes the paint from the buffer down onto the currently selected channel.

@rtype: bool
@return: True if any projection occurred. If the buffer is empty, this will return False
----------
PaintBuffer.bakeAndClear
Bakes the paint from the buffer down onto the currently selected channel and then forces it tobe cleared.

@rtype: bool
@return: True if any projection occurred. If the buffer is empty, this will return False
----------
PaintBuffer.baked
This is emitted just after baking occurs.

@rtype: None
----------
PaintBuffer.clampColors
Returns the color clamping behavior of the projector.

@rtype: bool
@return: True if the colors are clamped to the 0..1 range on output
@see: L{setClampColors()}
----------
PaintBuffer.clear
Clears all paint from the buffer.

@rtype: None
----------
PaintBuffer.cleared
This is emitted just after the paint buffer has been cleared.

@rtype: None
----------
PaintBuffer.compImage
Composits the given image onto the paint buffer.

@type  CompImage: L{Image}
@param CompImage: the image to composite onto the paint buffer. This can be either L{Image} or QImage
@type  Undoable: bool
@param Undoable: Specifies whether it's possible to undo compositing the image onto the paint buffer
@type  BlendMode: str
@param BlendMode: the blend mode to use to composite the image onto the paint buffer
@rtype: None
----------
PaintBuffer.depth
Returns the current bit depth of the buffer.

@rtype: L{BufferDepth}
@return: The current bit depth
@see: L{setDepth()}
----------
PaintBuffer.depthChanged
This is emitted when the depth of the buffer is changed.

@type  NewDepth: L{PaintBuffer.BufferDepth}
@param NewDepth: The new depth of the paint buffer
@rtype: None
----------
PaintBuffer.getPaint
Returns a QImage containing the current paint buffer.

This captures the paint in the paint buffer and returns it as an 8 bit RGBA QImage.

QImage does not support higher bit depths, so any float or half data will be reduced to 8 bits.

@rtype: QImage
@return: A QImage which is the same size as the paint buffer resolution, and contains 8 bit RGBA data
----------
PaintBuffer.isDirty
Indicates whether the buffer has paint in it.

@rtype: bool
@return: True if the paint buffer has some paint in it, or False if not
----------
PaintBuffer.loadPaint
Saves the content of the paint buffer to an L{Image} in the L{ImageManager}.

@type  Paint: L{Image}
@param Paint: the L{Image} object to load into the paint buffer
@rtype: None
@raise ValueError: Emitted if the given L{Image} object is not valid.
----------
PaintBuffer.mirroring
Return the mirroring mode for the paint buffer.

@rtype: L{Mirroring}
@return: The current mirroring state of the paint buffer
@see: L{setMirroring()}
----------
PaintBuffer.pickColor
Pick a color from the paintbuffer.

This allows a script to pick pixel color values from the paintbuffer. The L{x} and L{y} position must be in the range returned by L{resolution()} The color returned may be a HDR value with r,g,b values above 1.0 This method is relatively slow to execute and should not be used to the query lots of pixels 


C{#Pick a pixel in the middle of the screen}

C{Size = mari.canvases.paintBuffer().resolution();}

C{c = mari.canvases.paintBuffer().pickColor(Size.width()/2, Size.height()/2)}

C{print c.toString()}

@type  x: int
@param x: The L{x} coordinate of the pixel.These coordinates are relative to the top left corner of the canvas
@type  y: int
@param y: The L{y} coordinate of the pixel.These coordinates are relative to the top left corner of the canvas
@rtype: L{Color}
@return: The color of the pixel at the paintbuffer location (L{x},L{y})
@raise ValueError: Emitted if x or y are outside of the range (0,0)-resolution()
----------
PaintBuffer.resolution
Returns the current resolution of the buffer.

@rtype: QSize
@return: The current resolution of the paint buffer. This will be one of the values reported by L{supportedResolutions()}
@see: L{setResolution()}
----------
PaintBuffer.resolutionChanged
This is emitted when the paint buffer is resized.

@type  Resolution: QSize
@param Resolution: The new size of the buffer in pixels
@rtype: None
----------
PaintBuffer.restoreContent
Restores the content of the paint buffer from the special internal clipboard

@rtype: None
@raise RuntimeError: Raised if there is no saved content in the special internal clipboard.
----------
PaintBuffer.rotation
Returns the rotation of the buffer in degrees.

@rtype: float
@return: The angle of rotation of the paint buffer in degrees
@see: L{setRotation()}
----------
PaintBuffer.rotationChanged
This is emitted when the rotation of the paint buffer changes.

@type  Angle: float
@param Angle: The new angle of rotation of the paint buffer in degrees
@rtype: None
----------
PaintBuffer.saveContent
Saves the content of the paint buffer to the special internal clipboard.

@rtype: None
----------
PaintBuffer.savePaint
Saves the content of the paint buffer to an L{Image} in the L{ImageManager}.

@rtype: L{Image}
@return: the L{Image} object of the saved paint buffer content
----------
PaintBuffer.scale
Returns the scaling factor of the buffer.

This is independent of the resolution.

@rtype: QSizeF
@return: The scaling factor of the paint buffer in world space
@see: L{setScale()}
----------
PaintBuffer.scaleChanged
This is emitted when the scale of the paint buffer changes.

@type  Scale: QSizeF
@param Scale: The new scaling factor of the paint buffer
@rtype: None
----------
PaintBuffer.setClampColors
Sets the color clamping behavior of the projector.

@type  ClampColors: bool
@param ClampColors: True to clamp the colors to the 0..1 range
@rtype: None
@see: L{clampColors()}
----------
PaintBuffer.setDepth
Sets the bit depth of the buffer.

This must be one of the options defined in L{BufferDepth}.

@type  Depth: L{BufferDepth}
@param Depth: The new bit depth of the buffer
@rtype: None
@see: L{depth()}
----------
PaintBuffer.setMirroring
Set the mirroring scheme for the paint buffer.

@type  Mirror: L{Mirroring}
@param Mirror: The new mirroring mode
@rtype: None
@see: L{mirroring()}, L{Mirroring}
----------
PaintBuffer.setPaint
Sets the contents of the paint buffer with a QImage.

This takes an RGBA QImage and copies it into the paint buffer. The QImage must be RGBA and the same resolution as the paint buffer (see L{resolution()}).

8 bit images will be converted to 16 or 32 bit where appropriate.

@type  PaintImage: QImage
@param PaintImage: The image to load into the paint buffer
@rtype: bool
@return: True if the paint was updated from the given image, or False otherwise
@raise ValueError: Raised if the image was invalid, or not of the correct resolution.
@attention: Any existing paint will be replaced without warning, so please be careful.
----------
PaintBuffer.setResolution
Sets the resolution of the buffer.

This must be one of the resolutions returned by L{supportedResolutions()}.

@type  Size: QSize
@rtype: bool
@return: True if the resolution was set, or if the buffer was already the requested size; False if the resolution could not be set for any reason other than not being in the supported list
@raise ValueError: Raised if the requested resolution is not supported.
@see: L{resolution()}
----------
PaintBuffer.setRotation
Sets the angle of rotation of the buffer in degrees.

Angles outside the range [0, 360] will be replaced with values wrapped into that range. For example, after calling setRotation(-10), L{rotation()} will return 350.

@type  Angle: float
@param Angle: The rotation angle.
@rtype: None
@see: L{rotation()}
----------
PaintBuffer.setScale
Sets the scaling factor of the buffer.

This does not change the resolution. 
C{mari.canvases.paintBuffer().setScale(PySide.QtCore.QSizeF(1,1))}

@type  Size: QSizeF
@param Size: The new scaling factor of the paint buffer.
@rtype: None
@see: L{scale()}
----------
PaintBuffer.setTranslation
Sets the translation, or offset from the origin, of the buffer.

C{mari.canvases.paintBuffer().setTranslation(PySide.QtCore.QPointF(0.1,0.1))}

@type  Translation: QPointF
@param Translation: The new translation of the paint buffer
@rtype: None
@see: L{translation()}
----------
PaintBuffer.supportedResolutions
Returns the list of resolutions that the paint buffer supports.

@rtype: list of  QSize
@return: A list of valid resolutions (in pixels) for the paint buffer
----------
PaintBuffer.translation
Returns the translation, or offset from the origin, of the buffer.

@rtype: QPointF
@return: The translation of the paint buffer in screen coordinates
@see: L{setTranslation()}
----------
PaintBuffer.translationChanged
This is emitted when the translation of the buffer changes.

@type  Translation: QPointF
@param Translation: The new translation of the paint buffer
@rtype: None
----------
PaintNode
Represents an image set node.

B{Example Code}

This example shows how to create a L{PaintNode}

>>> import mari
>>> nodeGraph = mari.geo.current().nodeGraph()
>>> paintNode = nodeGraph.createPaintNode( 1024, 1024, 8, mari.Color(1.0,1.0,0.0,1.0) )

This example obtains a paint node from the node graph of the current geo entity and

>>> for node in nodeGraph.nodeList():
...   if node.isPaintNode():
...     mari.app.log( "Found PaintNode : "+node.nodeName() )
----------
PaintNode.imageSet
Returns the image set this node holds.

@rtype: L{ImageSet}
@return: The image set this node holds.
@raise RuntimeError: Raised if the image set cannot be found.
----------
PaintNode.isPaintNode
Returns whether this node is a paint node.

@rtype: bool
@return: Whether this node is a paint node
----------
PaintableLayer
Paintable layers contain an image for each patch that can be painted directly.

You can access all types of layers from their containing L{Channel} objects - for example: C{channel.layerList()}

You can check for L{PaintableLayer} objects by calling L{Layer.isPaintableLayer()}:

>>> # This examples creates a paintable layer and checks if it's a paintable layer
>>> import mari
>>> channel = mari.geo.current().currentChannel()
>>> layer = channel.createPaintableLayer("Test")
>>> layer.isPaintableLayer()
True
----------
PaintableLayer.bleed
Returns True if the layer has Texture Bleed enabled.

@rtype: bool
@return: Return a Boolean
@see: L{setBleed()}
----------
PaintableLayer.exportImages
Exports a set of images from the layer.

This is the same as selecting "Export Selected Layers" from the GUI with only the given layer selected. To export the entire layer stack, call L{LayerStack.exportImages()}.

Pass in the path and template to export the files to - for example:

>>> import mari
>>> layer = mari.geo.current().currentChannel().currentLayer()
>>> layer.exportImages('/tmp/$CHANNEL.$LAYER.$UDIM.tif')

Only paintable and procedural layers can be exported individually in this way.

@type  PathAndTemplate: str
@param PathAndTemplate: The target path for the export and the template to export the files to, in a single string.
@type  Options: int
@param Options: Pass in a value other than the default to turn on an option, such as disabling "small uniforms". See L{Image.SaveOptions}.
@type  UVIndexList: list of  int
@param UVIndexList: Pass in a list of zero-based UV indices if desired to specify the patches to export images for. If not specified or empty, images will be exported for all indices. The UDIM for a patch is the zero-based UV index plus 1001.
@rtype: None
@raise ValueError: Raised if the path and template parameter was empty, or if an invalid UV index was specified.
@raise IOError: Raised if an error occurred with the export process.
@see: L{ProceduralLayer.exportImages()}, L{LayerStack.exportImages()}, L{importImages()}
----------
PaintableLayer.exportSelectedPatches
Exports images for the selected patches from this layer.

Pass in the path and template to export the files to - for example:

>>> layer.exportSelectedPatches('/tmp/$CHANNEL.$LAYER.$UDIM.tif')

Only paintable and procedural layers can be exported individually in this way.

@type  PathAndTemplate: str
@param PathAndTemplate: The target path for the export and the template to export the files to, in a single string.
@type  Options: int
@param Options: Pass in a value other than the default to turn on an option, such as disabling "small uniforms". See L{Image.SaveOptions}.
@rtype: None
@raise ValueError: Raised if the path and template parameter was empty, or if an invalid UV index was specified.
@raise IOError: Raised if an error occurred with the export process.
@see: L{ProceduralLayer.exportImages()}, L{LayerStack.exportImages()}, L{importImages()}
----------
PaintableLayer.imageSet
Returns the image set used by this layer.

@rtype: L{ImageSet}
@return: Return an image set.
@raise SystemError: Raised if the layers paint image set cannot be found.
----------
PaintableLayer.importImages
Imports a set of images into the layer.

This is the same as selecting "Import into Layer" from the GUI. To import into a layer stack, call L{LayerStack.importImages()}.

Pass in the path to the files and the template to import them from - for example:

>>> layer.importImages('/tmp/$CHANNEL.$LAYER.$UDIM.tif')

@type  PathAndTemplate: str
@param PathAndTemplate: The path to the files and the template to import them from, in a single string
@type  ScaleOption: L{ImageSet.ScaleChoice}
@param ScaleOption: When the existing patch and the image in the file to import are of different sizes, this indicates which of the two to rescale to match the other
@type  UVIndexList: list of  int
@param UVIndexList: Pass in a list of zero-based UV indices if desired to specify the patches to export images for. If not specified or empty, images will be exported for all indices. The UDIM for a patch is the zero-based UV index plus 1001.
@type  RemoveAlpha: bool
@param RemoveAlpha: Remove the alpha channel (convert RGBA to RGB).
@rtype: None
@raise ValueError: Raised if the path and template parameter was empty, or if an invalid UV index was specified.
@raise IOError: Raised if an error occurred with the import process.
@see: L{ProceduralLayer.exportImages()}, L{LayerStack.importImages()}, L{exportImages()}
----------
PaintableLayer.setBleed
Sets the Texture Bleed for this layer.

@type  bleed: bool
@param bleed: The new L{bleed} value
@rtype: None
@see: L{bleed()}
----------
Palette
A dockable widget class.

Palettes are dockable widgets that can be moved around and configured by the user.

You can access palettes through the L{PaletteManager} - for example: C{mari.palettes.list()}

B{Example Code}

>>> # This example shows how to create a palette with a label
>>> import mari, PySide
>>> label = PySide.QtGui.QLabel("Hello World")
>>> new_palette = mari.palettes.create("Hello World Palette","",label)
>>> mari.palettes.remove(new_palette.name());
----------
Palette.__init__
Creates a new palette with the given name.

@type  rName: str
@param rName: The name of the new palette to create. This must be non-empty and unique, or the function will raise an exception. The name will be initially used as both the full and short name for the palette.
@type  pBodyWidget: QWidget
@param pBodyWidget: The widget to set as the palette's body - i.e. the one that holds everything to display for the palette.
@rtype: L{Palette}
@raise ValueError: Throws a value error if the name is empty, of if a palette with the given name already exists.
----------
Palette.bringToFront
Brings the palette to the front of the other windows.

This can be used to bring the palette to the front of the group of palettes it is docked with, or to raise a floating palette above anything else it might currently be behind.

@rtype: None
@see: L{showInFront()}
----------
Palette.disable
Disables interaction with the palette.

@rtype: None
@see: L{setEnabled()}, L{enable()}
----------
Palette.enable
Enables interaction with the palette.

@rtype: None
@see: L{disable()}, L{setEnabled()}
----------
Palette.fullName
Returns the full name displayed on the palette title.

This is the same as L{name()}.

@rtype: str
@return: The full name displayed on the palette title.
@see: L{setFullName()}
----------
Palette.hide
Hides the palette.

@rtype: None
@see: L{setVisibility()}, L{show()}
----------
Palette.name
Returns the full name displayed on the palette title.

This is the same as L{fullName()}.

@rtype: str
@return: The full name displayed on the palette title.
----------
Palette.setBodyWidget
Sets the body widget of the palette.

This is the widget that holds everything to display for the palette.

@type  pBody: QWidget
@param pBody: The widget that holds everything to display for the palette
@rtype: None
----------
Palette.setCSHKey
Sets the context sensitive key, that is appended to the online documentation when the CSH button on this palette is triggered.

@type  Key: str
@param Key: The context sensitive key.
@rtype: None
----------
Palette.setEnabled
Enables or disables interaction with the palette.

@type  Enabled: bool
@rtype: None
@see: L{disable()}, L{enable()}
----------
Palette.setFullName
Sets the full name to be displayed on the palette title.

@type  rName: str
@param rName: The full name to be displayed on the palette title.
@rtype: None
@see: L{fullName()}
----------
Palette.setShortName
Sets the short name to be displayed on the palettes tab.

@type  rName: str
@param rName: The short name to be displayed on the palettes tab.
@rtype: None
@see: L{shortName()}
----------
Palette.setVisibility
Sets the visibility state of the palette.

@type  Visible: bool
@param Visible: True to show, or False to hide.
@rtype: None
@see: L{show()}, L{hide()}
----------
Palette.shortName
Returns the short name displayed on the palettes tab.

@rtype: str
@return: The short name displayed on the palettes tab.
@see: L{setShortName()}
----------
Palette.show
Shows the palette.

@rtype: None
@see: L{setVisibility()}, L{hide()}
----------
Palette.showInFront
Shows the palette and brings it to the front of other windows.

This is the equivalent of calling L{show()} and then L{bringToFront()}.

@rtype: None
----------
PaletteManager
Manages creation and manipulation of palettes (dockable widgets).

Palettes are dockable widgets that can be moved around and configured by the user.

B{Example Code}

>>> # This example shows how to create a palette with a label
>>> import mari, PySide
>>> label = PySide.QtGui.QLabel("Hello World")
>>> new_palette = mari.palettes.create("Hello Palette",label)
>>> mari.palettes.remove(new_palette.name());
----------
PaletteManager.create
Creates a new palette with the given name.

@type  rName: str
@param rName: The name of the new palette to create. This must be non-empty and unique, or the function will raise an exception. The name will be initially used as both the full and short name for the palette.
@type  pBodyWidget: QWidget
@param pBodyWidget: The widget to set as the palette's body - i.e. the one that holds everything to display for the palette. This can be any PySide widget. There used to be a method a second parameter as a string path, this is accepted but will be depricated. Use L{createWithIcon()} instead.
@rtype: L{Palette}
@raise ValueError: Raised if the name is empty, or if a palette with the given name already exists. A non-valid widget in pBodyWidget will also Raise this exception.
----------
PaletteManager.createWithIcon
Creates a new palette with the given name.

@type  rName: str
@param rName: The name of the new palette to create. This must be non-empty and unique, or the function will raise an exception. The name will be initially used as both the full and short name for the palette.
@type  rIconPath: str
@param rIconPath: The filename of the icon to use for the palette.
@type  pBodyWidget: QWidget
@param pBodyWidget: The widget to set as the palette's body - i.e. the one that holds everything to display for the palette.
@rtype: L{Palette}
@raise ValueError: Raised if the name is empty, or if a palette with the given name already exists.
----------
PaletteManager.find
Returns the palette with the given full name.

Note that this returns the palette with the given full name - i.e. the one displayed on the top of the palette - rather than the one on the palette tab.

@type  rName: str
@rtype: L{Palette}
@return: The palette object if found, or None if not.
@see: L{get()}
----------
PaletteManager.get
Returns the palette with the given full name.

Note that this returns the palette with the given full name - i.e. the one displayed on the top of the palette - rather than the one on the palette tab.

@type  rName: str
@rtype: L{Palette}
@return: The palette object.
@raise ValueError: Raised if no palette with the given full name was found.
@see: L{find()}
----------
PaletteManager.list
Returns a list of all registered palettes.

@rtype: list of  L{Palette}
----------
PaletteManager.remove
Removes, or deletes, the palette with the given name.

@type  rName: str
@param rName: The name of the palette to remove
@rtype: None
@raise ValueError: Raised if the name is empty, or if no palette with the given name exists.
----------
Particle
Provides L{Particle} scripting.
----------
Particle.availableOps
Returns a list all the available operations chains.

@rtype: list of str
----------
Particle.exportGeo
Exports a predefined set of attributes to a particle file on disk.

>>> geo_entity = mari.geo.current()
>>> mari.particle.exportGeo('/tmp/filename.bgeo', geo_entity, {0: 256, 10: 512 },
...                         mari.particle.EXPORT_NORMAL, 0)

@type  FileName: str
@param FileName: The name of the file to export to. Any existing file will be overwritten.
@type  Object: L{GeoEntity}
@param Object: The object to export attributes for.
@type  UVImageSizes: variant
@param UVImageSizes: A dictionary that maps integer patch indices to sizes to export at. Only patch indices specified in the dictionary will be exported.
@type  Flags: int
@param Flags: The options to export with. See L{ExportFlags}.
@type  Frame: int
@param Frame: The animated frame number to export for.
@type  GeoVersion: L{GeoEntityVersion}
@param GeoVersion: The geometry version to export for. If None then the current geometry version is used.
@rtype: bool
@return: True if the export completed successfully, or False otherwise.
@raise TypeError: Raised if the patch sizes dictionary was in the wrong format.
@raise ValueError: Raised if no object was given, no patch sizes are given, the patch indices are invalid, the patch sizes are invalid.
----------
Particle.exportImageSets
Exports a set of image sets to a particle file on disk.

The image sets must belong to the same object and have the same width and height. >>> geo_entity = mari.geo.current()
>>> image_set = geo_entity.currentImageSet()
>>> mari.particle.exportImageSets('/tmp/filename.bgeo', {'color' : image_set}, mari.particle.EXPORT_ALPHA,
...                               0, [0, 1])

@type  FileName: str
@param FileName: The name of the file to export to. Any existing file will be overwritten.
@type  ImageSets: variant
@param ImageSets: A dictionary that maps string particle attribute names, to export to, to image sets, to export from.
@type  Flags: int
@param Flags: The options to export with. See L{ExportFlags}.
@type  Frame: int
@param Frame: The animated frame number to export for.
@type  UVIndices: list of  int
@param UVIndices: Which patches to export for. Passing in an empty list will cause all patches to be exported.
@type  GeoVersion: L{GeoEntityVersion}
@param GeoVersion: The geometry version to export for. If None then the current geometry version is used.
@rtype: bool
@return: True if the export completed successfully, or False otherwise.
@raise ValueError: Raised if no image sets are given, the image sets are invalid, the patch indices are invalid, the patch sizes don't match or they don't belong to the same object.
----------
Particle.findOp
Returns the operations chain of the given name.

@type  Name: str
@param Name: The name of the operations chain to find.
@rtype: L{ParticleOp}
@return: The operations chain, or None if no operations chain exists for the given name.
----------
Particle.importImageSets
Imports into a set of image sets from a particle file on disk.

The image sets must belong to the same object and have the same width and height. >>> geo_entity = mari.geo.current()
>>> image_set = geo_entity.currentImageSet()
>>> mari.particle.importImageSets('/tmp/filename.bgeo', {'color' : image_set},
...                               mari.particle.INTERPOLATION_INVERSE_DISTANCE_WEIGHTED,
...                               mari.particle.IMPORT_BLEED_EDGES, 0, [0, 1])

@type  FileName: str
@param FileName: The name of the file to import to.
@type  ImageSets: variant
@param ImageSets: A dictionary that maps string particle attribute names, to import from, to image sets, to import into.
@type  Interpolation: L{InterpolationMethod}
@param Interpolation: Which method of interpolation to use when calculating the final color value from the closest particles.
@type  Flags: int
@param Flags: The options to import with. See L{ImportFlags}.
@type  Frame: int
@param Frame: The animated frame number to import to.
@type  UVIndices: list of  int
@param UVIndices: Which patches to import into. Passing in an empty list will cause all patches to be imported.
@type  GeoVersion: L{GeoEntityVersion}
@param GeoVersion: The geometry version to import to. If None then the current geometry version is used.
@type  SearchRange: float
@param SearchRange: The maximum distance allowed to be searched.
@type  SearchUnits: L{RangeUnits}
@param SearchUnits: The units of measure for the search range.
@type  Search: L{SearchMethod}
@param Search: The method used to search the particle cloud with from each of destination points.
@type  SampleCount: int
@param SampleCount: The number of samples to search for and interpolate together to produce the final color.
@rtype: bool
@return: True if the import completed successfully, or False otherwise.
@raise IOError: Raised if the file was invalid; if the file was missing data; if any of the file data was in the wrong format.
@raise TypeError: Raised if the image set dictionary was in the wrong format.
@raise ValueError: Raised if no image sets were supplied; if any of the image sets was invalid; if the image sets belong to different objects; if any of the patch indices was invalid; if any of the patch sizes didn't match between image sets.
----------
Particle.interpolationMethods
Returns a dictionary of user-friendly names to their associated enum value, for all the supported interpolation methods.

@rtype: variant
----------
Particle.rangeUnits
Returns a dictionary of user-friendly names to their associated enum value, for all the supported search range units.

@rtype: variant
----------
Particle.searchMethods
Returns a dictionary of user-friendly names to their associated enum value, for all the supported search methods.

@rtype: variant
----------
Particle.supportedFileFormats
Returns a list of all the supported particle file formats.

@rtype: list of str
----------
Particle.transferChannel
Copies a single channel from one object to another.

>>> src_geo_entity = mari.geo.get('Head1')
>>> src_channel = src_geo_entity.channel('diffuse')
>>> dst_geo_entity = mari.geo.get('Head2')
>>> mari.particle.transferChannel(src_channel, 0, [], dst_geo_entity, 0, [],
...                               mari.particle.INTERPOLATION_INVERSE_DISTANCE_WEIGHTED,
...                               mari.particle.IMPORT_BLEED_EDGES | mari.particle.IMPORT_FLATTEN)

@type  SourceChannel: L{Channel}
@param SourceChannel: The source channel to read from.
@type  SourceFrame: int
@param SourceFrame: The animated frame number to read from.
@type  SourceUVIndices: list of  int
@param SourceUVIndices: Which patches in the source to read from. Passing in an empty list will cause all source patches to be read from.
@type  DestinationObject: L{GeoEntity}
@param DestinationObject: The destination object to write into.
@type  DestinationFrame: int
@param DestinationFrame: The animated frame number to write to.
@type  DestinationUVIndices: list of  int
@param DestinationUVIndices: Which patches in the destination to write to. Passing in an empty list will cause all destination patches to be written to.
@type  Interpolation: L{InterpolationMethod}
@param Interpolation: Which method of interpolation to use when calculating the final color value from the closest particles.
@type  DestinationFlags: int
@param DestinationFlags: The options used in writing. See L{ImportFlags}.
@type  SourceGeoVersion: L{GeoEntityVersion}
@param SourceGeoVersion: The source geometry version to read from. If None then the current geometry version is used.
@type  DestinationGeoVersion: L{GeoEntityVersion}
@param DestinationGeoVersion: The destination geometry version to write into. If None then the current geometry version is used.
@type  SearchRange: float
@param SearchRange: The maximum distance allowed to be searched.
@type  SearchUnits: L{RangeUnits}
@param SearchUnits: The units of measure for the search range.
@type  FillColor: L{Color}
@param FillColor: The color used to fill the newly created destination image sets with.
@type  Search: L{SearchMethod}
@param Search: The method used to search the particle cloud with from each of destination points.
@type  SampleCount: int
@param SampleCount: The number of samples to search for and interpolate together to produce the final color.
@type  SourceFlags: int
@param SourceFlags: The options used in reading. See L{ExportFlags}.
@type  DestinationSize: L{ImageSet.Size}
@param DestinationSize: Used to specified the image size for all uv indices in the destination channel. If a size is not given then the size will match the source.
@rtype: L{Channel}
@return: A destination channel if the transfer completed successfully, or None otherwise.
@raise ValueError: Raised if no channel was supplied; if any of the patch indices was invalid; if no destination object was supplied.
----------
Particle.transferImageSets
Copies image data from one image set to another.

The image sets in the source list must belong to the same object and have the same width and height. This also applies to the destination list. >>> src_geo_entity = mari.geo.get('Head1')
>>> src_image_set = src_geo_entity.currentImageSet()
>>> dst_geo_entity = mari.geo.get('Head2')
>>> dst_image_set = dst_geo_entity.currentImageSet()
>>> mari.particle.transferImageSets([src_image_set], 0, [0, 1], [dst_image_set], 0, [0, 1],
...                                 mari.particle.INTERPOLATION_INVERSE_DISTANCE_WEIGHTED,
...                                 mari.particle.IMPORT_BLEED_EDGES)

@type  SourceImageSets: list of  L{ImageSet}
@param SourceImageSets: A list of source image sets to read from.
@type  SourceFrame: int
@param SourceFrame: The animated frame number to read from.
@type  SourceUVIndices: list of  int
@param SourceUVIndices: Which patches in the source to read from. Passing in an empty list will cause all source patches to be read from.
@type  DestinationImageSets: list of  L{ImageSet}
@param DestinationImageSets: A list of destination image sets to write into.
@type  DestinationFrame: int
@param DestinationFrame: The animated frame number to write to.
@type  DestinationUVIndices: list of  int
@param DestinationUVIndices: Which patches in the destination to write to. Passing in an empty list will cause all destination patches to be written to.
@type  Interpolation: L{InterpolationMethod}
@param Interpolation: Which method of interpolation to use when calculating the final color value from the closest particles.
@type  DestinationFlags: int
@param DestinationFlags: The options used in writing. See L{ImportFlags}.
@type  SourceGeoVersion: L{GeoEntityVersion}
@param SourceGeoVersion: The source geometry version to read from. If None then the current geometry version is used.
@type  DestinationGeoVersion: L{GeoEntityVersion}
@param DestinationGeoVersion: The destination geometry version to write into. If None then the current geometry version is used.
@type  SearchRange: float
@param SearchRange: The maximum distance allowed to be searched.
@type  SearchUnits: L{RangeUnits}
@param SearchUnits: The units of measure for the search range.
@type  Search: L{SearchMethod}
@param Search: The method used to search the particle cloud with from each of destination points.
@type  SampleCount: int
@param SampleCount: The number of samples to search for and interpolate together to produce the final color.
@type  SourceFlags: int
@param SourceFlags: The options used in reading. See L{ExportFlags}.
@rtype: bool
@return: True if the transfer completed successfully, or False otherwise.
@raise ValueError: Raised if no image sets were supplied; the number of source image sets doesn't match the number of destination image sets; if any of the image sets was invalid; if the image sets belong to different objects; if any of the patch indices was invalid; if any of the patch sizes didn't match between image sets.
----------
Particle.transferLayers
Copies layers from one object to another.

The layers in the source list must belong to the same object. >>> src_geo_entity = mari.geo.get('Head1')
>>> src_channel = src_geo_entity.channel('diffuse')
>>> src_layer = src_channel.layer('color')
>>> dst_geo_entity = mari.geo.get('Head2')
>>> dst_channel = dst_geo_entity.channel('diffuse')
>>> mari.particle.transferLayers([src_layer], 0, [], dst_channel, 0, [],
...                              mari.particle.INTERPOLATION_INVERSE_DISTANCE_WEIGHTED,
...                              mari.particle.IMPORT_BLEED_EDGES | mari.particle.IMPORT_FLATTEN)

@type  SourceLayers: list of  L{Layer}
@param SourceLayers: A list of source layers to read from.
@type  SourceFrame: int
@param SourceFrame: The animated frame number to read from.
@type  SourceUVIndices: list of  int
@param SourceUVIndices: Which patches in the source to read from. Passing in an empty list will cause all source patches to be read from.
@type  DestinationStack: L{LayerStack}
@param DestinationStack: The destination layer stack to write into.
@type  DestinationFrame: int
@param DestinationFrame: The animated frame number to write to.
@type  DestinationUVIndices: list of  int
@param DestinationUVIndices: Which patches in the destination to write to. Passing in an empty list will cause all destination patches to be written to.
@type  Interpolation: L{InterpolationMethod}
@param Interpolation: Which method of interpolation to use when calculating the final color value from the closest particles.
@type  DestinationFlags: int
@param DestinationFlags: The options used in writing. See L{ImportFlags}.
@type  SourceGeoVersion: L{GeoEntityVersion}
@param SourceGeoVersion: The source geometry version to read from. If None then the current geometry version is used.
@type  DestinationGeoVersion: L{GeoEntityVersion}
@param DestinationGeoVersion: The destination geometry version to write into. If None then the current geometry version is used.
@type  SearchRange: float
@param SearchRange: The maximum distance allowed to be searched.
@type  SearchUnits: L{RangeUnits}
@param SearchUnits: The units of measure for the search range.
@type  FillColor: L{Color}
@param FillColor: The color used to fill the newly created destination image sets with.
@type  Search: L{SearchMethod}
@param Search: The method used to search the particle cloud with from each of destination points.
@type  SampleCount: int
@param SampleCount: The number of samples to search for and interpolate together to produce the final color.
@type  SourceFlags: int
@param SourceFlags: The options used in reading. See L{ExportFlags}.
@rtype: list of  L{Layer}
@return: A list of destination layers if the transfer completed successfully, or an empty list otherwise.
@raise ValueError: Raised if no layers were supplied; if any of the layers was invalid; if the layers belong to different objects; if any of the patch indices was invalid; if no destination layer stack was supplied.
----------
ParticleOp
Provides L{Particle} operations chain scripting.
----------
ParticleOp.description
Returns a brief description of the operations chain.

@rtype: str
@return: A string containing the description.
----------
ParticleOp.execute
Executes the operations chain.

@rtype: bool
@return: True if all operations completed successfully, False otherwise.
----------
ParticleOp.name
Returns the name of the operations chain.

@rtype: str
@return: A string containing the name.
----------
ParticleOp.propertyWidget
Returns the properties widget for the operations chain.

@rtype: QWidget
@return: A widget with all operations properties exposed as a number of sub-widgets.
----------
PatchLinksManager
Handles patch image linking.

Using this manager, you can create and managed named groups of linked images. Linked patches share their underlying image contents, so if you paint on one linked patch, all other linked patches are updated.

Currently, the API restricts linkage to L{Image} objects on the same L{ImageSet}. At some point in the future, which restriction will be removed. Some methods require an seemingly redundant L{ImageSet} parameter to make provision for such a change.

B{Example Code}

>>> # This example creates a patch link between 1001 and 1011
>>> import mari
>>> geo = mari.geo.current()
>>> patch_1001 = geo.patch(0)
>>> patch_1011 = geo.patch(10)
>>> layer = geo.currentChannel().createPaintableLayer("Test")
>>> mari.patch_links.linkPatches([patch_1001,patch_1011],"Test Link",layer.imageSet())
>>> print mari.patch_links.groupNamesForImageSet(layer.imageSet())[0]
Test Link
----------
PatchLinksManager.canLinkImageInternals
Checks whether the input images can be linked based on their internal structure.

L{Images} can be linked if 
  - they have the same dimensions,
  - they have the same pixel format,
  - they belong to the same L{ImageSet} and
  - the image set is not a L{Ptex} image set.

@type  Images: list of  L{Image}
@rtype: bool
----------
PatchLinksManager.canLinkImages
Checks whether the input images can be linked into an existing/new group with the specified group name.

This will check whether the input images, and any existing images linked in the group indexed by the specified groupname, can have their internals linked. It also checks whether any of the images are already part of other link groups, in which case they can not be linked, and this method will return False.

@type  Images: list of  L{Image}
@param Images: Container of input L{Image} objects.
@type  GroupName: str
@param GroupName: The name for the group in which the images need to be linked.
@rtype: bool
@return: True if the images can be linked in a group with the specified group name, and False if not.
@raise RuntimeError: Raised if any of the input images are not valid.
@raise ValueError: Raised if GroupName is an empty string.
@see: L{canLinkImageInternals()}
----------
PatchLinksManager.canLinkPatchInternals
Checks whether the input patches for the specified image set can be linked based on their underlying image's internal structure.

This is a convenience function which will look up the underlying images for the patches (similar to what can be done by using method mari.GeoEntity.patchImage), and then checks whether the image internals can be linked.

@type  Patches: list of  L{GeoPatch}
@param Patches: Container of input L{GeoPatch} objects.
@type  pImageSet: L{ImageSet}
@param pImageSet: The L{ImageSet} object containing the images for the patches.
@rtype: bool
@return: True if the patches internals can be linked, or False if not.
@raise RuntimeError: Raised if any of the input patches are not valid.
@raise ValueError: Raised if pImageSet isn't a valid L{ImageSet}.
@see: L{canLinkImageInternals()}, L{mari.GeoEntity.patchImage()}
----------
PatchLinksManager.canLinkPatches
Checks whether the underlying images for the given patches on the specified image set can be linked into a new/existing group with the specified group name.

This is a convenience function which will look up the underlying images for the given patch-image set combination, and then calls L{canLinkImages()}.

@type  Patches: list of  L{GeoPatch}
@param Patches: Container of input L{GeoPatch} objects.
@type  GroupName: str
@param GroupName: The name for the group in which the patches need to be linked.
@type  pImageSet: L{ImageSet}
@param pImageSet: The L{ImageSet} object containing the images for the patches.
@rtype: bool
@return: True if the underlying images for the patches can be linked in a group with the specified group name, or False if not.
@raise RuntimeError: Raised if any of the input patches are not valid.
@raise ValueError: Raised if GroupName is an empty string or if pImageSet isn't a valid L{ImageSet}.
@see: L{canLinkImages()}, L{mari.GeoEntity.patchImage()}
----------
PatchLinksManager.generateUniqueGroupName
Generates a unique name which hasn't yet been used to index a group of linked patches, which you can use to create a uniquely named group of linked patches.

@rtype: str
@return: String containing the unique name.
----------
PatchLinksManager.groupAdded
Emitted when a new link group has been added.

@type  GroupName: str
@param GroupName: String name of the group that was added.
@rtype: None
----------
PatchLinksManager.groupNames
Gets the names of all existing link groups.

@rtype: list of str
@return: Container of strings for the names.
----------
PatchLinksManager.groupNamesForImageSet
Gets the names of all link groups (if any) which link patch images on the specified image set.

@type  pImageSet: L{ImageSet}
@param pImageSet: L{ImageSet} object for which the lookup must be done.
@rtype: list of str
@return: Container of string for the names.
@raise ValueError: Raised if pImageSet isn't a valid L{ImageSet} object.
----------
PatchLinksManager.groupRemoved
Emitted when a link group has been removed.

@type  GroupName: str
@param GroupName: String name of the group that was renamed.
@rtype: None
----------
PatchLinksManager.groupRenamed
Emitted when a link group has been renamed.

@type  OldName: str
@param OldName: The previous name.
@type  NewName: str
@param NewName: The new name.
@rtype: None
----------
PatchLinksManager.imageGroup
Gets the name of the link group, if any, containing the specified image.

@type  Img: L{Image}
@param Img: L{Image} object for which the lookup must be done.
@rtype: str
@return: String name for the group. If L{Img} is not part of any link groups, and empty string is returned.
@raise ValueError: Raised if Img isn't a valid L{Image} object.
----------
PatchLinksManager.imageUnlinked
Emitted when an L{Image} object has been unlinked.

@type  Img: L{Image}
@param Img: L{Image} object which was unlinked.
@rtype: None
----------
PatchLinksManager.images
Gets the images which are part of the specified link group.

@type  GroupName: str
@param GroupName: String name indexing the group which images will be returned.
@rtype: list of  L{Image}
@return: Container of L{Image} objects which are part of the specified group. If no no such group exists, an empty container is returned.
@raise ValueError: Raised if GroupName is an empty string.
----------
PatchLinksManager.imagesLinked
Emitted when a set of L{Images} object have been linked.

@type  Images: list of  L{Image}
@param Images: Container of linked L{Image} objects.
@rtype: None
----------
PatchLinksManager.isImageLinked
Checks if the image is part of any link groups.

@type  Img: L{Image}
@param Img: L{Image} object which must be checked.
@rtype: bool
@return: True if the image has been linked, and False if not.
@raise ValueError: Raised if Img isn't a valid L{Image}.
----------
PatchLinksManager.isPatchLinked
Check if the image for the patch on the given image set has been linked.

@type  Patch: L{GeoPatch}
@param Patch: L{GeoPatch} object which must be checked.
@type  pImageSet: L{ImageSet}
@param pImageSet: L{ImageSet} object containing the image indicated by the L{Patch}.
@rtype: bool
@return: True if the patch image is linked, and False if not.
@raise ValueError: Raised if Patch isn't a valid L{GeoPatch} or if pImageSet isn't a valid L{ImageSet}.
@see: L{mari.GeoEntity.patchImage()}, L{isImageLinked()}
----------
PatchLinksManager.linkImages
Link the input images into a new/existing group with the specified group name.

This method will check the images are linkable by using L{canLinkImages()}, and if so, it will link them. If the images are linked into an existing group, their contents will immediately be updated to match that of other images in the link group.

@type  Images: list of  L{Image}
@param Images: Container of L{Image} objects to be linked into an existing/new group.
@type  GroupName: str
@param GroupName: A name string indexing an existing group, or a name for a new group.
@rtype: None
@raise RuntimeError: Raised if the images could not be linked.
@raise ValueError: Raised if Images is not a list of valid image objects, or if GroupName is an empty string.
@see: L{canLinkImages()}, L{generateUniqueGroupName()}
----------
PatchLinksManager.linkPatches
Convenience function to link the images for the patches on the specified image set.

This essentially looks up the images for the patches, and then calls L{linkImages()}.

@type  Patches: list of  L{GeoPatch}
@param Patches: Container of input L{GeoPatch} objects.
@type  GroupName: str
@param GroupName: A name string indexing an existing group, or a name for a new group.
@type  pImageSet: L{ImageSet}
@param pImageSet: L{ImageSet} object containing the images indicated by the patches.
@rtype: None
@raise RuntimeError: Raised if the patch images could not be linked.
@raise ValueError: Raised if Patches is not a container of valid patch objects, or if pImageSet isn't a valid L{ImageSet}, or if GroupName is an empty string.
@see: L{linkImages()}, L{mari.GeoEntity.patchImage()}
----------
PatchLinksManager.linkSelectedPatches
Convenience method to link the currently selected patches on the specified image set.

@type  GroupName: str
@param GroupName: String name indexing an existing group, or a name for a new group, into which the patch images must be linked.
@type  pImageSet: L{ImageSet}
@param pImageSet: L{ImageSet} object containing the images which must be linked.
@rtype: None
@raise RuntimeError: Raised if the selected patches could not be linked.
@raise ValueError: Raised if GroupName is an empty string, or if pImageSet isn't a valid L{ImageSet} object.
@see: L{linkPatches()}, L{linkImages()}
----------
PatchLinksManager.linkedImages
Gets the group of linked images of which the input image is part.

@type  Img: L{Image}
@param Img: L{Image} object for which the lookup must be done.
@rtype: list of  L{Image}
@return: Container of L{Image} objects. The container will be empty if no images are linked against L{Img}.
----------
PatchLinksManager.linkedPatches
Gets the group of linked patches of which the input patch is part.

@type  Patch: L{GeoPatch}
@param Patch: L{GeoPatch} object for which the lookup must be done.
@type  pImageSet: L{ImageSet}
@param pImageSet: L{ImageSet} object which contains the underlying image objects. If L{pImageSet} is None, the current image set is used.
@rtype: list of  L{GeoPatch}
@return: Container of L{Image} objects. The container will be empty if no images are linked against Img.
----------
PatchLinksManager.patchGroup
Gets the name of the link group, if any, containing the specified patch image on the specified image set.

@type  Patch: L{GeoPatch}
@param Patch: L{GeoPatch} object for which the lookup must be done.
@type  pImageSet: L{ImageSet}
@param pImageSet: L{ImageSet} object containing the images.
@rtype: str
@return: String name for the group. If L{Patch} is not part of any link groups, and empty string is returned.
@raise ValueError: Raised if Patch isn't a valid L{GeoPatch} object, or if pImageSet isn't a valid L{ImageSet} object.
----------
PatchLinksManager.patches
Gets the patches which are part of the specified link group on the specified or current image set.

@type  GroupName: str
@param GroupName: String name indexing the link group for which pathces must be retrieved.
@type  pImageSet: L{ImageSet}
@param pImageSet: L{ImageSet} object which contains the underlying L{Image} objects. If L{pImageSet} is None, the current image set is used for the lookup.
@rtype: list of  L{GeoPatch}
@return: Container or L{GeoPatch} objects.
@raise ValueError: Raised if GroupName is an empty string.
@see: L{images()}
----------
PatchLinksManager.removeGroup
Removes a group of linked patch images.

@type  GroupName: str
@param GroupName: String name indexing the group which must be removed.
@rtype: None
@raise RuntimeError: Raised if removing the named group failed.
@raise ValueError: Raised if GroupName is an empty string.
----------
PatchLinksManager.renameGroup
Renames a group of linked patch images.

@type  OldName: str
@param OldName: String specifying the name of the group.
@type  NewName: str
@param NewName: String specifying the new name for the group.
@rtype: None
@raise RuntimeError: Raised if the group does not exist, or if it could not be renamed.
@raise ValueError: Raised if OldName or NewName are invalid strings.
----------
PatchLinksManager.unlinkImage
Unlinks the specified image from all other images.

@type  Img: L{Image}
@param Img: L{Image} object to unlink.
@rtype: None
@raise RuntimeError: Raised if the Img could not be unlinked.
@raise ValueError: Raised if Img isn't a valid L{Image} object.
----------
PatchLinksManager.unlinkPatch
Unlinks the image for the patch on the specified image set from all other images.

@type  Patch: L{GeoPatch}
@param Patch: The L{GeoPatch} object specifying the image which must be unlinked.
@type  pImageSet: L{ImageSet}
@param pImageSet: The L{ImageSet} object containing the image.
@rtype: None
@raise RuntimeError: Raised if the Patch could not be unlinked in pImageSet.
@raise ValueError: Raised if Patch isn't a valid L{GeoPatch} object, or if pImageSet isn't a valid L{ImageSet} object.
@see: L{unlinkImage()}, L{mari.GeoEntity.patchImage()}
----------
PatchLinksManager.unlinkSelectedPatches
Unlinks the patch images for the selected patches on the specified image set.

@type  pImageSet: L{ImageSet}
@param pImageSet: L{ImageSet} object containing the images (corresponding to the selected patches) which must be unlinked.
@rtype: None
@raise ValueError: Raised if pImageSet isn't a valid L{ImageSet} object.
----------
PatchSelectionGroup
A specialised selection group that consists of patches.
----------
PatchSelectionGroup.patchList
@rtype: list of  L{GeoPatch}
@return: A list of the UV patch objects associated to this selection group.
----------
PointLight
An object for creating lighting effects on a 3D mesh.

You can access lights through the L{LightManager} - for example: C{mari.lights.list()}
----------
PointLight.ambient
Returns the ambient color of the light.

@rtype: L{Color}
@return: The ambient color
@see: L{setAmbient()}
----------
PointLight.constantAttenuation
Return the constant attenuation value for this light.

@rtype: float
@return: The constant attenuation value
@see: L{setConstantAttenuation()}
----------
PointLight.diffuse
Returns the diffuse color of the light.

@rtype: L{Color}
@return: The diffuse color
@see: L{setDiffuse()}
----------
PointLight.fixedTo
Returns the type of object that the light is fixed to.

Lights can be fixed to either the world or the camera. This allows lights to follow the view, ensuring models are illuminated at all times.

@rtype: L{FixedTo}
@return: L{Light.SCENE} if the light is fixed to the scene, or L{Light.CAMERA} if fixed to the camera.
@see: L{setFixedTo()}
----------
PointLight.linearAttenuation
Return the linear attenuation value for this light.

@rtype: float
@return: The linear attenuation value
@see: L{setLinearAttenuation()}
----------
PointLight.position
Returns the position of the light in the scene.

@type  Frame: int
@param Frame: The frame to retrieve the position for. Use 0 (the default) when there is no animation.
@rtype: L{VectorN}
@return: The position of the light in the scene
@see: L{setPosition()}
----------
PointLight.quadraticAttenuation
Return the quadratic attenuation value for this light.

@rtype: float
@return: The quadratic attenuation value
@see: L{setQuadraticAttenuation()}
----------
PointLight.renderShadows
Return whether to render shadows.

@rtype: bool
@return: Whether to render shadows
@see: L{setRenderShadows()}
----------
PointLight.setAmbient
Sets the specular L{Color} of the light.

@type  NewColor: L{Color}
@param NewColor: The new specular color for the light
@rtype: None
@see: L{ambient()}
----------
PointLight.setConstantAttenuation
Set the constant attenuation for the light.

@type  Atten: float
@param Atten: The new constant attenuation for the light
@rtype: None
@see: L{constantAttenuation()}
----------
PointLight.setDiffuse
Set the diffuse color of the light.

@type  NewColor: L{Color}
@param NewColor: The new diffuse color for the light
@rtype: None
@see: L{diffuse()}
----------
PointLight.setFixedTo
Sets the type of object that the light should be fixed to.

@type  TargetType: L{FixedTo}
@param TargetType: L{Light.SCENE} if the light is to be fixed to the scene, or L{Light.CAMERA} if fixed to the camera.
@rtype: None
@see: L{fixedTo()}
----------
PointLight.setLinearAttenuation
Set the linear attenuation for the light.

@type  Atten: float
@param Atten: The new linear attenuation for the light
@rtype: None
@see: L{linearAttenuation()}
----------
PointLight.setPosition
Sets the position of the light in the scene.

Positions can only be set on the default frame (0) at present.

@type  pTranslation: L{VectorN}
@param pTranslation: The new position of the light
@rtype: None
@see: L{position()}
----------
PointLight.setQuadraticAttenuation
Set the quadratic attenuation for the light.

@type  Atten: float
@param Atten: The new quadratic attenuation for the light
@rtype: None
@see: L{quadraticAttenuation()}
----------
PointLight.setRenderShadows
Set whether to render shadows.

@type  Render: bool
@param Render: Whether to render shadows
@rtype: None
@see: L{renderShadows()}
----------
PointLight.setSpecular
Sets the specular L{Color} of the light.

@type  NewColor: L{Color}
@param NewColor: The new specular color for the light
@rtype: None
@see: L{specular()}
----------
PointLight.setSpotCutoff
Set the Spot cutoff component of the light.

@type  Cutoff: float
@param Cutoff: The new spot cutoff of the light
@rtype: None
@see: L{spotCutoff()}
----------
PointLight.setSpotDirection
Set the spot direction for this light.

@type  Direction: L{VectorN}
@param Direction: The new spot direction for this light
@rtype: None
@see: L{spotDirection()}
----------
PointLight.setSpotExponent
Set the Spot exponent component of the light.

@type  Exponent: float
@param Exponent: The new spot exponent of the light
@rtype: None
@see: L{spotExponent()}
----------
PointLight.specular
Returns the specular color of the light.

@rtype: L{Color}
@return: The specular color
@see: L{setSpecular()}
----------
PointLight.spotCutoff
Return the spot cutoff for the light.

@rtype: float
@return: The spot cutoff value
@see: L{setSpotCutoff()}
----------
PointLight.spotDirection
Return the spot direction for this light.

@rtype: L{VectorN}
@return: The spot direction value for this light
@see: L{setSpotDirection()}
----------
PointLight.spotExponent
Return the spot exponent of this light.

@rtype: float
@return: The spot exponent of the light
@see: L{setSpotExponent()}
----------
PostFilter
A post processing, image space color management filter.

Post processing filters can be applied to the canvas display after rendering. These filters can be used for color correction, bloom, or other fancy effects. Filters are written as GLSL shader fragments, and can have uniform values and texture data as well.

L{PostFilter} instances can be created by calling the various "create" functions on a L{PostFilterCollection}.

B{Example Code}

>>> # This examples creates a new FileLUTFilter object through GLRender and PostFilterCollection
>>> import mari
>>> filter_collection = mari.gl_render.createPostFilterCollection("New Filter Collection")
>>> file_lut = filter_collection.createFileLUT("New File LUT")
>>> mari.gl_render.deletePostFilterCollection(filter_collection)
----------
PostFilter.enabled
Returns whether the filter is enabled.

DEPRICATED: This function will be removed in a future version. Please use 'enabled = (filter.flags() & filter.POSTFILTER_ENABLED) is filter.POSTFILTER_ENABLED'.

@rtype: bool
@return: True if the filter is enabled
@see: L{setEnabled()}
----------
PostFilter.flags
Returns the flags of the filter.

@rtype: int
@return: The flags of the filter. See L{PostFilterFlags}.
@see: L{setFlags()}
----------
PostFilter.flagsChanged
Emitted when the flags changes.

@type  Flags: int
@param Flags: The new flags.
@rtype: None
----------
PostFilter.name
Returns the name of the filter.

@rtype: str
@return: The unique name of the filter
----------
PostFilter.setEnabled
Used to enables or disable the filter.

DEPRICATED: This function will be removed in a future version. Please use 'filter.setFlags(filter.flags() | filter.POSTFILTER_ENABLED)'.

@type  Enabled: bool
@param Enabled: Whether the filter is to be enabled or disabled
@rtype: None
@see: L{enabled()}
----------
PostFilter.setFlags
Modifies the flags of the filter.

@type  Flags: int
@param Flags: The flags of the filter. See L{PostFilterFlags}.
@rtype: None
@see: L{flags()}
----------
PostFilterCollection
A collection of post processing, image space filters.

These filters are applied to the canvas display after rendering. These filters can be used for color correction, bloom or other fancy effects. Filters are written as GLSL shader fragments, and can have uniform values and texture data as well.

L{PostFilterCollection} instances can be created by calling L{GLRender.createPostFilterCollection()}.

B{Example Code}

>>> # This examples creates a new FileLUTFilter object through GLRender and PostFilterCollection
>>> import mari
>>> filter_collection = mari.gl_render.createPostFilterCollection("New Filter Collection")
>>> file_lut = filter_collection.createFileLUT("New File LUT")
>>> mari.gl_render.deletePostFilterCollection(filter_collection)
----------
PostFilterCollection.clear
Removes all of the filters held by the collection.

@rtype: None
----------
PostFilterCollection.createCustomLUT
Creates a new custom LUT post processing filter that can be applied to the viewport.

@type  Name: str
@param Name: The name for the new filter
@type  Index: int
@param Index: The index to insert the new filter at. If -1 is given, the new filter will be appended to the end of the collection
@rtype: L{CustomLUTFilter}
@return: A new post process custom LUT filter object
----------
PostFilterCollection.createFileLUT
Creates a new file LUT post processing filter that can be applied to the viewport.

@type  Name: str
@param Name: The name for the new filter
@type  Index: int
@param Index: The index to insert new filter at. If -1 is given, the new filter will be appended to the end of the collection
@rtype: L{FileLUTFilter}
@return: A new post process file LUT filter object
----------
PostFilterCollection.createGLSL
Creates a new GLSL post processing filter that can be applied to the viewport.

Mari supports post-render processing effects. These can be used to color-correct, blur, filter or warp the viewport display to achieve different effects.

Filters are implemented as two snippets of GLSL shader code: 
  - The L{DefinitionsSnippet} defines uniforms and functions required for the filter
  - The L{BodySnippet} contains the implementation of the filter itself
As multiple instances of a filter can be created, we need to give each instance a unique ID. To do this, all uniforms and function names in the shader should have a _$ID_ appended to their names. Mari takes this token internally and adds a unique ID. This preventing name collisions in shaders. For example, a definitions snippet that looks like:

C{uniform float ScaleX_$ID_;}

C{uniform float ScaleY_$ID_;}

will be translated internally into:

C{uniform float ScaleX1;}

C{uniform float ScaleY2;}

Body snippets should be protected with braces, and can expect the color value of the pixel being processed to be available in a vec4 called "Out".

If you wanted to simply multiply the viewport display pixels by a floating point value, for example, you could write something like:

C{definition_snippet = "uniform float ScaleValue_$ID_;"}

C{body_snippet = "{ Out.rgb *= ScaleValue_$ID_; }"}

The values passed into the shader can be controlled by modifying a metadata value on the L{PostFilter} object. The metadata value should have the same name and type as the uniform, but should not include the _$ID_. In the scaling example above, we could add some metadata to the filter called ScaleValue, and this would then be passed into the shader automatically.

@type  Name: str
@param Name: The name for the new filter
@type  DefinitionsSnippet: str
@param DefinitionsSnippet: A snippet of GLSL code that defines the uniforms and functions used by this post process filter
@type  BodySnippet: str
@param BodySnippet: A snippet of GLSL code that defines the body of the post process filter
@type  Index: int
@param Index: The index to insert the new filter at. If -1 is given, the new filter is appended to the end of the collection
@rtype: L{GLSLFilter}
@return: A new post process filter object
----------
PostFilterCollection.filters
Returns the post process filters in the collection.

These post process filters are executed in order.

@rtype: list of  L{PostFilter}
@return: A list of all post process filters within the collection
----------
PostFilterCollection.find
Returns the first occurrence of a filter with the given name.

@type  Name: str
@param Name: The name of filter to find
@rtype: L{PostFilter}
@return: A filter with the given name, or None if not found
----------
PostFilterCollection.flags
Returns the flags of the collection.

@rtype: int
@return: The flags of the collection. See L{PostFilterCollectionFlags}.
@see: L{setFlags()}
----------
PostFilterCollection.indexOf
Returns the index of a filter.

@type  Filter: L{PostFilter}
@param Filter: The filter to return the index of
@type  StartAt: int
@param StartAt: Index to start searching from
@rtype: int
@return: The index position of the first occurrence of a filter in the collection, searching forward from index position L{StartAt}. Returns -1 if no matching item was found
----------
PostFilterCollection.isReadOnly
Returns whether the collection is read only.

DEPRICATED: This function will be removed in a future version. Please use 'read_only = collection.flags() is (collection.POSTFILTERCOLLECTION_EDITABLE | collection.POSTFILTERCOLLECTION_REMOVABLE)'.

@rtype: bool
----------
PostFilterCollection.move
Moves a single filter within the collection.

@type  Filter: L{PostFilter}
@param Filter: The filter to move
@type  Index: int
@param Index: The index to move the filter to
@rtype: None
----------
PostFilterCollection.name
Returns the name of the collection.

@rtype: str
@return: The unique name of the collection.
----------
PostFilterCollection.remove
Deletes (removes) a filter from the collection.

@type  Filter: L{PostFilter}
@param Filter: The filter to delete
@rtype: None
@raise ValueError: Raised if the filter is not a member of this collection.
----------
PostFilterCollection.setFlags
Modifies the flags of the collection.

@type  Flags: int
@param Flags: The flags of the collection. See L{PostFilterCollectionFlags}.
@rtype: None
@see: L{flags()}
----------
PostFilterCollection.setReadOnly
Sets whether the collection is read only.

DEPRICATED: This function will be removed in a future version. Please use 'collection.setFlags(collection.POSTFILTERCOLLECTION_EDITABLE | collection.POSTFILTERCOLLECTION_REMOVABLE)'.

@type  ReadOnly: bool
@rtype: None
----------
PostFilterCollection.size
Returns the number of filters in the collection.

@rtype: int
----------
Preferences
Manages retrieval and modification of user preferences.

Mari separates preferences in groups and subgroups. In the preference dialog, a group is represented by a tab, and a subgroup by a group box.

Preference groups and individual preferences are accessed in a similar way to a folder and file structure. For example, calling C{list()} might return C{('Data/', 'Scripts/')} , and their subgroups could be displayed by calling C{list('Data')} .

All preferences have a group and subgroup, so values will always be accessed in the form:

B{Example Code}

>>> import mari
>>> original_autosave_interval = mari.prefs.get('Data/Autosave/autosaveInterval')
>>> mari.prefs.set('Data/Autosave/autosaveInterval',15)
>>> mari.prefs.get('Data/Autosave/autosaveInterval')
15
>>> mari.prefs.set('Data/Autosave/autosaveInterval',original_autosave_interval)
----------
Preferences.get
Returns the value of the preference with the given path.

The path matching is case insensitive.

@type  Path: str
@param Path: The path to the preference
@rtype: variant
@return: The current value of the preference
----------
Preferences.list
Returns a list of the available preferences or preference groups in the given path.

The path matching is case insensitive.

@type  Path: str
@param Path: The path to list groups, subgroups, or preferences for
@rtype: list of str
----------
Preferences.prettyPropertyName
Method used to filter and catch changes to dynamic properties.

@type  PropertyName: str
@rtype: str
----------
Preferences.remove
Deregisters the preference of the given path.

The path matching is case insensitive.

@type  Path: str
@param Path: The path to the preference
@rtype: None
@raise ValueError: Raised if no preference with the given path was found.
----------
Preferences.set
Modifies the value of the preference with the given path.

The path matching is case insensitive.

@type  Path: str
@param Path: The path to the preference
@type  Value: variant
@param Value: The new value to store
@rtype: None
----------
Preferences.setChangedScript
Sets the script to execute if the preference of the given path is changed.

The path matching is case insensitive.

@type  Path: str
@param Path: The path to the preference
@type  ChangedScript: str
@param ChangedScript: The script to execute if the preference is changed
@rtype: None
@raise ValueError: Raised if no preference with the given path was found.
----------
Preferences.setDefault
Sets the value to reset the preference of the given path to.

The path matching is case insensitive.

@type  Path: str
@param Path: The path to the preference
@type  Default: variant
@param Default: The value to be reset to. A value of 'None' disables reset
@rtype: None
@raise ValueError: Raised if no preference with the given path was found.
----------
Preferences.setDisplayName
Sets the used when presenting the preference of the given path to the user.

The path matching is case insensitive.

@type  Path: str
@param Path: The path to the preference
@type  DisplayName: str
@param DisplayName: The name used when presenting the preference to the user
@rtype: None
@raise ValueError: Raised if no preference with the given path was found.
----------
Preferences.setItemList
Sets the list of available options the preference of the given path is allowed to be set to.

The path matching is case insensitive.

@type  Path: str
@param Path: The path to the preference
@type  ItemList: list of str
@param ItemList: The list of available options the value is allowed to be set to
@rtype: None
@raise ValueError: Raised if no preference with the given path was found or it's not supported on the type.
----------
Preferences.setRange
Sets the allowed range of the preference of the given path.

The path matching is case insensitive.

@type  Path: str
@param Path: The path to the preference
@type  Min: variant
@param Min: The minimum value possible
@type  Max: variant
@param Max: The maximum value possible
@rtype: None
@raise ValueError: Raised if no preference with the given path was found or it's not supported on the type.
----------
Preferences.setStep
Sets the step size used when incrementing the preference of the given path.

The path matching is case insensitive.

@type  Path: str
@param Path: The path to the preference
@type  Step: variant
@param Step: The step size used when incrementing the value
@rtype: None
@raise ValueError: Raised if no preference with the given path was found or it's not supported on the type.
----------
ProceduralLayer
Procedural layers use GPU processing operations to generate image data.

These layers will normally take up no disk space, but consume GPU processing time to calculate their image data whenever it is visible. As an alternative, they can be cached, which will consume disk space for the cached image data, but decrease GPU processing time.

You can access all types of layers from their containing L{Channel} objects - for example: C{channel.layerList()}

You can check for L{ProceduralLayer} objects by calling L{Layer.isProceduralLayer()}:

B{Example Code}

>>> #This example finds procedural layers in the current channel
>>> import mari
>>> procedural_layers = []
>>> channel = mari.geo.current().currentChannel()
>>> for layer in channel.layerList():
...     if layer.isProceduralLayer():
...         procedural_layers.append(layer)

>>> #This example creates an "Brightness" procedural layers in the current channel
>>> import mari
>>> channel = mari.geo.current().currentChannel()
>>> layer = channel.createProceduralLayer("Constant","Basic/Constant")
>>> layer.isProceduralLayer()
True
----------
ProceduralLayer.convertToPaintable
Converts the layer into a paintable layer.

As this operation changes the layer type, it is suggested that you reobtain a reference to this layer.

@type  SelectedOnly: bool
@param SelectedOnly: Whether or not to bake the result into all patches or only the selected patches.
@rtype: None
----------
ProceduralLayer.exportImages
Exports a set of images from the layer.

This is the same as selecting "Export Selected Layers" from the GUI with only the given layer selected. To export the entire layer stack, call L{LayerStack.exportImages()}.

Pass in the path and template to export the files to - for example:

>>> import mari
>>> layer = mari.geo.current().currentChannel().currentLayer()
>>> layer.exportImages('/tmp/$CHANNEL.$LAYER.$UDIM.tif')

Only paintable and procedural layers can be exported individually in this way.

@type  PathAndTemplate: str
@param PathAndTemplate: The target path for the export and the template to export the files to, in a single string.
@type  Options: int
@param Options: Pass in a value other than the default to turn on an option, such as disabling "small uniforms". See L{Image.SaveOptions}.
@type  UVIndexList: list of  int
@param UVIndexList: Pass in a list of zero-based UV indices if desired to specify the patches to export images for. If not specified or empty, images will be exported for all indices. The UDIM for a patch is the zero-based UV index plus 1001.
@rtype: None
@raise ValueError: Raised if the path and template parameter was empty, or if an invalid UV index was specified.
@raise IOError: Raised if an error occurred with the export process.
@see: L{PaintableLayer.exportImages()}, L{LayerStack.exportImages()}, L{PaintableLayer.importImages()}
----------
ProceduralLayer.exportSelectedPatches
Exports images for the selected patches from this layer.

Pass in the path and template to export the files to - for example:

>>> layer.exportSelectedPatches('/tmp/$CHANNEL.$LAYER.$UDIM.tif')

Only paintable and procedural layers can be exported individually in this way.

@type  PathAndTemplate: str
@param PathAndTemplate: The target path for the export and the template to export the files to, in a single string.
@type  Options: int
@param Options: Pass in a value other than the default to turn on an option, such as disabling "small uniforms". See L{Image.SaveOptions}.
@rtype: None
@raise ValueError: Raised if the path and template parameter was empty, or if an invalid UV index was specified.
@raise IOError: Raised if an error occurred with the export process.
@see: L{ProceduralLayer.exportImages()}, L{LayerStack.exportImages()}, importImages()
----------
ProceduralLayer.getProceduralParameter
Retrieves the current value of a parameter from this procedural layer.

@type  ParameterName: str
@param ParameterName: The name of the parameter to inspect.
@rtype: variant
@return: The current value of the parameter.
@raise ValueError: Raised if name of the parameter does not match any existing items. Or there is an issue with the image value.
@raise TypeError: Raised if the parameter does not relate to an image.
@see: L{setProceduralParameter()}
----------
ProceduralLayer.getProceduralParameterAsImage
Retrieves the current value of a parameter from this procedural layer and, if possible, return the L{Image} it relates to.

@type  ParameterName: str
@param ParameterName: The name of the parameter to inspect.
@rtype: L{Image}
@return: L{Image} of the parameter. None if not image is assigned.
@raise ValueError: Raised if name of the parameter does not match any existing items.
@see: L{getProceduralParameter()}
----------
ProceduralLayer.proceduralName
Get the name of the procedural type.

@rtype: str
@return: The name of the type of procedural, which will be of the form C{'Cloud.procedural'}
@deprecated: Please use the more reliable function L{proceduralType()} instead.
----------
ProceduralLayer.proceduralParameters
Returns the list of parameters on this procedural layer.

@rtype: list of str
@return: A list of the parameter names for this procedural layer.
----------
ProceduralLayer.proceduralType
Get the name of the procedural type.

@rtype: str
@return: The name of the type of procedural, which will be of the form C{'Procedural/Fractal/Cloud'}
----------
ProceduralLayer.setProceduralParameter
Sets the value of a parameter on the procedural layer.

@type  ParameterName: str
@param ParameterName: The name of the parameter to modify.
@type  NewValue: variant
@param NewValue: The new value for the parameter. This can be of a variety of types.
@rtype: None
@raise ValueError: Raised if the parameter could not be found, or was invalid.
@see: L{getProceduralParameter()}
----------
Project
Provides access to a currently open project.

A project stores information about a currently open user session. It contains the geometry textures, reference images, and all associated user settings. This object provides basic access to the project.

Data for the project is stored in Mari's internal caching system. To export the project fully the user may archive it.

Projects can be accessed through the L{ProjectManager} - for example: C{mari.projects.current()}

Note that it is not possible to obtain a L{Project} object for a project that is not currently open. To obtain information about an available unopened project, get a L{ProjectInfo} object using a function call like the following: C{mari.projects.find('blacksmith')}

B{Example Code}

>>> # This example shows how to obtain the Project object representing the current project
>>> import mari
>>> project = mari.projects.current()
>>> print project.className()
Project
----------
Project.close
Closes the project.

@type  ConfirmIfModified: bool
@param ConfirmIfModified: Set to False to suppress the confirmation dialog that normally appears if the project has been modified.
@rtype: None
----------
Project.closing
This is emitted when the project is about to close.

@rtype: None
----------
Project.colorspaceDefaults
Returns the colorspace defaults for the project.

@rtype: L{ColorspaceDefaults}
@return: The colorspace defaults.
@see: L{setColorspaceDefaults()}
----------
Project.colorspaceDefaultsChanged
This is emitted after the colorspace defaults are modified for this object.

@type  Defaults: L{ColorspaceDefaults}
@rtype: None
----------
Project.info
Returns information about the current project.

@rtype: L{ProjectInfo}
@return: An object describing the current project
----------
Project.isDirty
Returns the dirty (modified) status of the project.

Mari maintains a dirty state for projects when they are open. If a project is dirty it has been modified since it was loaded. Only dirty projects are saved. If a project is dirty when it is closed the user will be presented with a dialog asking them if they wish to save. Saving a project clears the dirty state.

This is the same as L{isModified()}.

@rtype: bool
@return: True if the project is dirty, and has been modified since it was opened, or False otherwise
----------
Project.isModified
Returns the modified status of the project.

This is the same as L{isDirty()}.

@rtype: bool
@return: True if the project has been modified since it was opened, or False otherwise
----------
Project.lightingMode
Returns the current lighting mode set on the main model.

@rtype: L{LightingMode}
@return: The lighting mode set.
@see: L{setLightingMode()}
----------
Project.name
Returns the name of the project.

@rtype: str
@return: The name of the project.
----------
Project.remapConfigColorspaces
Switches a given set of colorspaces for another in all configurations in the project.

@type  ColorspaceRemappings: QMap of  str, variant
@param ColorspaceRemappings: Table used to define what a particular colorspace should map to, where the key is the old colorspace we want to swap, and the value is the new colorspace we want to swap it to.
@type  FileName: str
@param FileName: Only remap if the L{OpenColorIO} configuration file matches this. If empty string is given then the remapping is done regardless of the L{OpenColorIO} configuration file.
@type  Stages: list of  int
@param Stages: The colorspace stages to consider for remapping. Used to selectively ignore colorspaces at certain stages such as the output stage. If an empty list is given then all stages are considered.
@rtype: None
@raise ValueError: Raised if the colorspace remapping table is empty. If any of the stages are invalid.
----------
Project.removeInvalidImageTags
Check all the images in this project and removes any invalid tags on them.

@rtype: bool
@return: Whether any invalid tag was removed.
----------
Project.save
Saves the project.

@type  ForceSave: bool
@param ForceSave: Set to True to force the save to be performed even if the project has not been modified
@rtype: None
----------
Project.saved
This is emitted after the project is saved.

@rtype: None
----------
Project.setColorspaceDefaults
Sets the colorspace defaults for the project.

@type  Defaults: L{ColorspaceDefaults}
@param Defaults: The colorspace defaults.
@rtype: None
@raise ValueError: Raised if the colorspace defaults are invalid.
@see: L{colorspaceDefaults()}
----------
Project.setLightingMode
Sets the lighting mode on the main model.

@type  Mode: L{LightingMode}
@param Mode: The lighting mode to set.
@rtype: None
@see: L{lightingMode()}
----------
Project.updatePatchResolutionInfo
Updates the GUI overlay resolution information for all of the patches in the project.

This can be useful to update patch resolution information that is out of date after patches have been resized.

@rtype: None
----------
Project.uuid
Returns the UUID of the project.

@rtype: str
@return: The UUID of the project, as a string.
----------
ProjectInfo
Holds preview information about an available project.

These objects provide summary information about the projects that are available in the user's cache directory.

You can set metadata on L{ProjectInfo} objects to be accessed at any time, including when the project is closed. This data will persist automatically, without the need for an explicit save. You can also add metadata items to the tool tip text displayed when the user hovers their mouse over the project icon.

You can access project information through the L{ProjectManager} - for example: C{mari.projects.list()}

B{Example Code}

>>> # This example shows how to print the list of names of existing projects to the application log
>>> import mari
>>> for project_info in mari.projects.list():
...     mari.app.log(project_info.name())
----------
ProjectInfo.addMetadataToToolTip
Adds the metadata item to the tool tip display for the project.

Hovering the mouse pointer over a project icon will display a short summary of information about the project. Call this function to add the metadata item with the specified name to that display.

If the metadata item is already in the tool tip display, this function will do nothing.

The list of metadata items to display is itself stored in the metadata item 'ToolTipItems'. You can also manipulate this directly as a list of strings if desired.

@type  Name: str
@param Name: The name of the metadata item to display
@rtype: None
@raise ValueError: Raised if no metadata item with the given name exists.
@see: L{removeMetadataFromToolTip()}
----------
ProjectInfo.autosavePath
Returns the autosave path.

@rtype: str
----------
ProjectInfo.cacheDiskUsage
Return the disk cache usage of this project in bytes.

If this returns 0 the cache usage may not have been calculated on this project. Older projects may be in this state.

@rtype: qint64
@raise RuntimeError: If the size has not been calculated for this project yet. Old projects may not have this value calculated. Loading and re-saving the project will solve this problem.
----------
ProjectInfo.close
Closes the project.

@type  ConfirmIfModified: bool
@param ConfirmIfModified: If True (the default), a confirmation dialog is displayed if the project has been modified.
@rtype: None
@raise RuntimeError: Raised if the project is already closed.
----------
ProjectInfo.createdTime
Returns the time and date that the project was created.

@rtype: QDateTime
----------
ProjectInfo.isEnabled
Returns if the porjected is enabled, i.e.

can be opened, or not. If the project is enabled it is available to open in the GUI. If disabled, the project is greyed out and unavailable to open through the GUI. The project may still be opened using L{open()}.

@rtype: bool
@return: True is enabled, False if disabled.
----------
ProjectInfo.isMinionProject
Return True if this project was created using Mari Minion.

@rtype: bool
@return: True if Mari Minion was used to create this project, False otherwise
----------
ProjectInfo.isNull
Returns True if this is a null record, and the project is invalid.

@rtype: bool
----------
ProjectInfo.isOpen
Returns True if the project is open, or False otherwise.

@rtype: bool
----------
ProjectInfo.lastModifiedTime
Returns the time and date of the last modification to the project.

@rtype: QDateTime
----------
ProjectInfo.modelPath
Returns the path to the model file used in the project.

For projects that contain multiple models, this will return the currently selected one.

For models with multiple versions, the currently selected version will be used.

@rtype: str
@see: L{modelPathList()}
----------
ProjectInfo.modelPathList
Returns the paths to all model files used in the project.

For models with multiple versions, the currently selected version will be used.

@rtype: list of str
@see: L{modelPath()}
----------
ProjectInfo.name
Returns the name of the project.

@rtype: str
----------
ProjectInfo.numChannels
Returns the number of channels in the project.

@rtype: int
@deprecated: This function always returns zero, and so is of no use. It will be removed in a future version.
----------
ProjectInfo.open
Opens the project.

@rtype: L{Project}
@return: The newly opened project.
@raise IOError: Raised if the project was found, but there was an error opening it.
@raise RuntimeError: Raised if there was already a project open, since only one can be open at a time.
----------
ProjectInfo.projectDirectories
Returns the directory for the project.

@rtype: list of str
----------
ProjectInfo.projectPath
Returns the project path.

@rtype: str
----------
ProjectInfo.recentIndex
Returns the index of the project in the list of recently opened projects.

@rtype: int
@return: The index of the project in the recent projects list, starting from 0 for the first. If the project is not in the list, the result will be -1.
----------
ProjectInfo.removeMetadataFromToolTip
Removes the metadata item from the tool tip display for the project.

If the metadata item is not currently in the tool tip display, this function will do nothing.

If the metadata item is removed, it will also be automatically removed from the tool tip display, so there is no need to call this function in that case.

The list of metadata items to display is itself stored in the metadata item 'ToolTipItems'. You can also manipulate this directly as a list of strings if desired.

@type  Name: str
@param Name: The name of the metadata item to remove
@rtype: None
@raise ValueError: Raised if no metadata item with the given name exists.
@see: L{addMetadataToToolTip()}
----------
ProjectInfo.setEnabled
Sets the project to enabled or disabled.

@type  Enabled: bool
@param Enabled: If True, the project will be available to open in the GUI. If False, the project will not be available to be open in the GUI. The project may still be opened using L{open()}.
@rtype: None
----------
ProjectInfo.subcachePath
Returns the subcache path for the project.

@rtype: str
----------
ProjectInfo.uuid
Returns the UUID of the project.

@rtype: str
----------
ProjectInfo.version
Returns the version of Mari that the project was saved in.

This will include only major and minor version numbers, so for example both 1.3v1 and 1.3v2 will be shown as 1.3.

In some cases, such as for older projects without version information, this may be a string such as "Unknown".

@rtype: str
@return: The version of Mari that the project was saved in
----------
ProjectInfo.versionHistory
Returns the history of Mari versions the project has been saved in.

@rtype: str
@return: A list of the Mari version numbers that the project has been saved in, starting with the one in which it was saved. Some data may be missing from projects created or saved in Mari versions that do not support this functionality.
----------
ProjectManager
Handles opening, closing, and general manipulation of projects.

Information about the available projects can be obtained using the L{list()} method. This returns L{ProjectInfo} objects to describe the projects can be opened. These projects will only be available as L{Project} objects after opening.

B{Example Code}

>>> # This example shows how to obtain the Project object representing the current project
>>> import mari
>>> project = mari.projects.current()
----------
ProjectManager.aboutToArchive
This is emitted just before a project is archived.

@type  UUID: str
@param UUID: The unique identifier of the project
@rtype: None
@see: L{archived()}
----------
ProjectManager.aboutToClose
This is emitted just before a project is closed.

@type  CurrentProject: L{Project}
@param CurrentProject: The project Mari is about to close
@rtype: None
@see: L{closed()}
----------
ProjectManager.aboutToCloseProject
(Deprecated) This is emitted just before a project is closed.

@type  CurrentProject: L{Project}
@param CurrentProject: The project Mari is about to close
@rtype: None
@deprecated: This signal is deprecated, and will be removed in a future version. Please use L{aboutToClose()} instead.
----------
ProjectManager.aboutToExport
This is emitted just before an export operation.

This signal is emitted before an export operation, and allows message hooks to be attached to Images, for example.

@rtype: None
----------
ProjectManager.aboutToOpen
This is emitted just before a new project is opened.

@type  UUID: str
@param UUID: The unique identifier of the project Mari is about to open
@rtype: None
@see: L{opened()}
----------
ProjectManager.aboutToOpenProject
(Deprecated) This is emitted just before a new project is opened.

@type  UUID: str
@param UUID: The unique identifier of the project Mari is about to open
@rtype: None
@deprecated: This signal is deprecated, and will be removed in a future version. Please use L{aboutToOpen()} instead.
----------
ProjectManager.aboutToSave
This is emitted just before a project is saved.

@type  ProjectToSave: L{Project}
@param ProjectToSave: The project about to be saved
@rtype: None
@see: L{saved()}
----------
ProjectManager.aboutToSaveNew
This is emitted when a new project has been created, and is about to be saved.

This can be used to apply modifications to a project before its initial save, for example.

@type  NewProject: L{Project}
@param NewProject: The newly-created project
@rtype: None
@see: L{created()}
----------
ProjectManager.aboutToSaveNewProject
(Deprecated) This is emitted when a new project has been created, and is about to be saved.

This can be used to apply modifications to a project before its initial save, for example.

@type  NewProject: L{Project}
@param NewProject: The newly-created project
@rtype: None
@deprecated: This signal is deprecated, and will be removed in a future version. Please use L{aboutToSaveNew()} instead.
----------
ProjectManager.aboutToSaveProject
(Deprecated) This is emitted just before a project is saved.

@type  ProjectToSave: L{Project}
@param ProjectToSave: The project about to be saved
@rtype: None
@deprecated: This signal is deprecated, and will be removed in a future version. Please use L{aboutToSave()} instead.
----------
ProjectManager.archive
Archives the project with the given UUID or name into a .mra file.

@type  rUUIDOrName: str
@param rUUIDOrName: The UUID or name of the project to archive. This is checked in the same way as in L{open()}.
@type  rTargetFileName: str
@param rTargetFileName: The file name of the archive to create.
@rtype: None
@raise RuntimeError: Raised if the user cancelled the operation.
@raise ValueError: Raised if no project with the given UUID or name could be found.
@raise RuntimeError: Raised if the project could not be archived because it was open.
@raise IOError: Raised if an I/O error occurred during the archiving process.
----------
ProjectManager.archived
This is emitted after a project is successfully archived.

@type  UUID: str
@param UUID: The unique identifier of the project
@rtype: None
@see: L{aboutToArchive()}
----------
ProjectManager.cachePath
Returns the path to the Mari cache directory, where the projects are stored.

@rtype: str
@return: The absolute path to the cache
----------
ProjectManager.close
Closes the project.

@type  ConfirmIfModified: bool
@param ConfirmIfModified: Set to False to suppress the confirmation dialog that normally appears if the project has been modified.
@rtype: None
----------
ProjectManager.closed
This is emitted after a project is closed.

@rtype: None
@see: L{aboutToClose()}
----------
ProjectManager.copy
Makes a duplicate of the project with the given UUID or name.

This is the same as L{duplicate()}.

@type  rUUIDOrName: str
@param rUUIDOrName: The UUID or name of the project to archive. This is checked in the same way as in L{open()}.
@rtype: None
@raise RuntimeError: Raised if the user cancelled the operation.
@raise ValueError: Raised if no project with the given UUID or name could be found.
@raise RuntimeError: Raised if the project could not be archived because it was open or in use.
@raise IOError: Raised if an I/O error occurred during the duplication process.
@see: L{duplicate}
----------
ProjectManager.create
Creates and opens a new project with the parameters supplied.

Many parameters of the channels that are imported are ignored, such as the size and bit depth, which are read from the file.

At least one channel must be created or imported. If not, an exception will be raised.

Projects currently cannot be created while another project is open.

Options controlling the geometry load can be passed to the function in the dictionary parameter L{ProjectMetaOptions}. The dictionary keys must be strings, and the values can be any simple type (i.e., no lists or other containers). The geometry loader plug-in that interprets the mesh to be loaded will receive the options passed in here that it recognises, and the others will be ignored.

When used in combination with the C API, this allows users to pass in parameters with specified names to a custom geometry loader. See the C API documentation for further details.

For the built-in geometry types, the meta keys currently supported are: 
  - "MappingScheme" - geometry mapping scheme (type L{MeshOptions}).
  - "MultipleGeometries" - how to handle multiple geometries in a single object (type L{MultipleGeometryOptions}).
  - "PtexFaceSizeScheme" - L{Ptex} specific: scheme to use for face texture size calculations (type L{PtexFaceSizeScheme}).
  - "PtexFaceSize" - L{Ptex} specific: size to use with the scheme above (type int).
  - "PtexImageFormat" - L{Ptex} specific: image data format (type L{PtexFormat}).
  - "PtexFaceColor" - L{Ptex} specific: color to clear faces to (type L{Color}).
  - "PtexImportFilename" - L{Ptex} specific: import an existing L{Ptex} file onto the .obj geoemtry (type string).
  - "PtexShowCreationDialog" - L{Ptex} specific: show the L{Ptex} creation dialog after mesh loading (type Bool; default is False from Python).
  - "EachMeshCreatesObject" - each mesh can either create an Object or each be a geometry within a single Object. This is currently L{Ptex} specific. (type Bool; default is True).
  - "MergeType" - merging of geometries can be either single-mesh or just-merge-nodes (L{GeoManager.MergeType}).
  - "MergeSelectionGroupWithSameNameType" - merging of face selection groups that have the same name (L{GeoManager.MergeSelectionGroupWithSameNameType}) - default is L{GeoManager.MERGESELECTIONGROUP_DO_NOT_MERGE}
  - "CreateSelectionSets" - specify whether to create selection sets from face groups (L{GeoManager.CreateSelectionSetOptions}) - default value is L{GeoManager.SELECTION_GROUPS_CREATE_FROM_FACE_GROUPS}
  - "FrameOffset" - specify the start frame in Mari's timeline to import the geometry (default value is zero).
Here is an example of creating a L{Ptex} project that does not show the L{Ptex} creation dialog after mesh loading:

>>> import mari, os
>>> EmptyChannels = []
>>> project_meta_options = dict()
>>> project_meta_options["MappingScheme"] = mari.projects.FORCE_PTEX
>>> project_meta_options["MultipleGeometries"] = mari.projects.MERGE_GEOMETRIES
>>> project_meta_options["PtexFaceSizeScheme"] = mari.projects.PTEX_WORLD_SPACE_DENSITY_SIZE
>>> project_meta_options["PtexFaceSize"] = 16
>>> project_meta_options["PtexImageFormat"] = mari.projects.PTEXFORMAT_HALF
>>> project_meta_options["PtexFaceColor"] = mari.Color(1, 0.25, 1, 1)
>>> project_meta_options["MergeType"] = mari.geo.MERGETYPE_SINGLE_MESH
>>> project_meta_options["CreateSelectionSets"] = mari.geo.SELECTION_GROUPS_CREATE_FROM_FACE_GROUPS
>>> obj_file = os.path.join(mari.resources.path(mari.resources.EXAMPLES),"Objects","cube.obj")
>>> try:
...     mari.projects.create("ptex_example", obj_file, EmptyChannels, EmptyChannels, project_meta_options)
... except:
...     pass

Here is an example of creating a L{Ptex} project from a number of .ptx files, treating each as a geometry within a single Object:

>>> import mari
>>> ptxFiles = [ "body.ptx", "head.ptx", "larm.ptx", "rarm.ptx" ]
>>> EmptyChannels = []
>>> project_meta_options = dict()
>>> project_meta_options["EachMeshCreatesObject"] = False
>>> try:
...     mari.projects.create("ptexoneobjmanygeos", ptxFiles, EmptyChannels, EmptyChannels, project_meta_options)
... except:
...     pass

Here is an example of creating a project with frames 1 to 10 of an animated geometry, starting at frame 1001 on the timeline:

>>> import mari
>>> EmptyChannels = []
>>> project_meta_options = dict()
>>> project_meta_options["StartFrame"] = 1
>>> project_meta_options["EndFrame"] = 10
>>> project_meta_options["FrameOffset"] = 1000
>>> try:
...     mari.projects.create("test", "/tmp/animatedGeo.abc", EmptyChannels, EmptyChannels, project_meta_options)
... except:
...     pass

Creating an alembic project is slightly different, in the sense that you can additionally pass in a list of items/nodes/objects to load from the file. The latter is a list of dictionary items, each dictionary having the name of the object to load as key and flags to specify whether children of the object should be selected as well and whether the children objects should be merged or not (using the enum type GeometryImportFlags); the latter has all of its children and merged by default.

Here is an example of creating a project from an alembic file, with everything merged (by default)

>>> import mari
>>> EmptyChannels = []
>>> project_meta_options = dict()
>>> mari.projects.create("test", "/tmp/animatedGeo.abc", EmptyChannels, EmptyChannels, project_meta_options)

Here is an example of creating a project from an alembic file, with root object(and its children) un-merged

>>> import mari
>>> EmptyChannels = []
>>> project_meta_options = dict()
>>> mari.projects.create("test", "/tmp/animatedGeo.abc", EmptyChannels, EmptyChannels, project_meta_options, [{"/":mari.geo.GEOMETRY_IMPORT_DONT_MERGE_CHILDREN}, ])

Here is an example of creating a project from an alembic file, with a child object (and its children) selected and merged. Please note that passing None as value to the dictionary of the object to load will set its value to defaults, which is select and merge of of its children objects.

>>> import mari
>>> project_meta_options = dict()
>>> mari.projects.create("test", "/tmp/village.abc", [], [], project_meta_options, [{"/Person/Head":None}, ])

Merging of objects can be of two types, namely SINGLE_MESH or JUST_MERGE_NODES. While both of the latters combine multiple geometries into one GeoEnity, the former (the default one as well) goes an extra step further to combine the various geometries into one single geometry inside that L{GeoEntity}; this can lead to more efficient patch layout in the case of PTex. The merge type can be passed in as part of the project_meta_options, as follows:

>>> import mari
>>> project_meta_options = dict()
>>> project_meta_options["MergeType"] = mari.geo.MERGETYPE_JUST_MERGE_NODES
>>> mari.projects.create("test", "/tmp/animatedGeo.abc", [], [], project_meta_options)

@type  Name: str
@param Name: The name of the project to create.
@type  MeshPaths: variant
@param MeshPaths: A single path or list of paths to the object file(s) that the project should load.
@type  ChannelsToCreate: list of  L{ChannelInfo}
@param ChannelsToCreate: A list of L{ChannelInfo} objects that contain information about the channels to create - such as their size, color depth, and other properties. Generally the channels in this list will not also be imported.
@type  ChannelsToImport: list of  L{ChannelInfo}
@param ChannelsToImport: A list of L{ChannelInfo} objects that specify information on the channels that should be imported. These should include valid paths and file template so the textures can be loaded correctly. Imported channels do not need to be included in the rChannelsToCreate list.
@type  ProjectMetaOptions: variant
@param ProjectMetaOptions: A dictionary of project creation meta options (see above).
@type  ObjectsToLoad: variant
@param ObjectsToLoad: This is a list of objects to load from the file. Each item of the list is a dictionary that contains the name of the objects to load and various geometry import flags to specify whether the children of the current object are to be selected and whether they are to be merged as well.
@type  ColorspaceSettings: L{ColorspaceDefaults}
@param ColorspaceSettings: The global colorspace settings of the project.
@rtype: None
@raise ValueError: Raised if no mesh paths were supplied.
@raise ValueError: Raised if invalid colorspace settings were supplied.
@raise TypeError: Raised if the mesh paths parameter was not a string or list of strings.
@raise RuntimeError: Raised if another project is already open.
@raise RuntimeError: Raised if the mesh types are invalid for project creation.
----------
ProjectManager.created
This is emitted when a new project has been created, after it has been saved.

This can be used to perform responses to the successful save of a new project.

@type  NewProject: L{Project}
@param NewProject: The newly-created project
@rtype: None
@see: L{aboutToSaveNew()}
----------
ProjectManager.current
Returns the interface to the current project, or None if nothing is loaded.

@rtype: L{Project}
@return: The currently open project, or None if no project is open
----------
ProjectManager.duplicate
Makes a duplicate of the project with the given UUID or name.

This is the same as L{copy()}.

@type  rUUIDOrName: str
@param rUUIDOrName: The UUID or name of the project to archive. This is checked in the same way as in L{open()}.
@rtype: None
@raise RuntimeError: Raised if the user cancelled the operation.
@raise ValueError: Raised if no project with the given UUID or name could be found.
@raise RuntimeError: Raised if the project could not be archived because it was open or in use.
@raise IOError: Raised if an I/O error occurred during the duplication process.
@see: L{copy}
----------
ProjectManager.exported
This is emitted just after an export operation.

This signal is emitted after an export operation, and allows for post-processing or cleanup after export.

@rtype: None
----------
ProjectManager.exportedSummary
This is emitted just after an export operation.

@type  Summary: str
@param Summary: A string containing a summary of what has been exported. This signal is emitted just after an export operation, and includes a summary of what has been exported.
@rtype: None
----------
ProjectManager.extract
Extracts a .mra project archive into a usable project.

@type  rFileName: str
@param rFileName: The file name of the archive to extract
@rtype: L{ProjectInfo}
@return: An object with information about the newly extracted project
@raise RuntimeError: Raised if the user cancelled the operation.
@raise ValueError: Raised if no project with the given UUID or name could be found, or if the supplied file name is invalid.
@raise IOError: Raised if an I/O error occurred during the extraction process.
----------
ProjectManager.find
Returns information about the project with the given UUID or name, if one exists.

This function first tries to find and open a project with the given string as a UUID, and if that fails, it tries again looking for the string as a project name.

@type  rUUIDOrName: str
@param rUUIDOrName: The UUID or name of the project to look for.
@rtype: L{ProjectInfo}
@return: An object describing the project with the given UUID or name if found, or None if not.
@see: L{get()}
----------
ProjectManager.get
Returns information about the project with the given UUID or name.

This function first tries to find and open a project with the given string as a UUID, and if that fails, it tries again looking for the string as a project name.

@type  rUUIDOrName: str
@param rUUIDOrName: The UUID or name of the project to look for.
@rtype: L{ProjectInfo}
@return: An object describing the project with the given UUID or name.
@raise ValueError: Raised if no project matching the given UUID or name was found.
@see: L{find()}
----------
ProjectManager.list
Returns a list of L{ProjectInfo} objects, which contain information about the available projects.

@rtype: list of  L{ProjectInfo}
@return: A list of objects describing the available projects
----------
ProjectManager.names
Returns the names of the available projects.

@rtype: list of str
@return: The names of the available projects
----------
ProjectManager.open
Opens the project with the given UUID or name.

This function first tries to find and open a project with the given string as a UUID, and if that fails, it tries again looking for the string as a project name.

If both attempts fail, it raises an exception.

@type  rUUIDOrName: str
@param rUUIDOrName: The UUID or name of the project to open.
@type  Allowed: L{AllowedVersions}
@param Allowed: Determines the project versions of Mari that can be loaded. The default is to only allow loading projects that were saved in older versions of Mari or the current one.
@rtype: L{Project}
@return: The newly opened project.
@raise ValueError: Raised if no project with the given UUID or name could be found.
@raise IOError: Raised if the project was found, but there was an error opening it - including if the project was from a different version of Mari to those specified as allowed.
@raise RuntimeError: Raised if there was already a project open, since only one can be open at a time.
----------
ProjectManager.opened
This is emitted just after a project is opened.

@type  NewProject: L{Project}
@param NewProject: The newly-opened project
@type  NewlyCreated: bool
@param NewlyCreated: True if the project has just been created, or False otherwise
@rtype: None
@see: L{aboutToOpen()}
----------
ProjectManager.openedProject
(Deprecated) This is emitted just after a project is opened.

@type  NewProject: L{Project}
@param NewProject: The newly-opened project
@rtype: None
@deprecated: This signal is deprecated, and will be removed in a future version. Please use L{opened()} instead.
----------
ProjectManager.projectClosed
(Deprecated) This is emitted after a project is closed.

@rtype: None
@deprecated: This signal is deprecated, and will be removed in a future version. Please use L{closed()} instead.
----------
ProjectManager.projectCreated
(Deprecated) This is emitted when a new project has been created, after it has been saved.

This can be used to perform responses to the successful save of a new project.

@type  NewProject: L{Project}
@param NewProject: The newly-created project
@rtype: None
@deprecated: This signal is deprecated, and will be removed in a future version. Please use L{created()} instead.
----------
ProjectManager.projectSaved
(Deprecated) This is emitted just after a project is saved.

@type  SavedProject: L{Project}
@param SavedProject: The project that was saved
@rtype: None
@deprecated: This signal is deprecated, and will be removed in a future version. Please use L{saved()} instead.
----------
ProjectManager.remove
Removes, or deletes, the project with the given UUID or name.

@type  rUUIDOrName: str
@param rUUIDOrName: The UUID or name of the project to remove. This is checked in the same way as in L{open()}.
@rtype: None
@raise ValueError: Raised if no project with the given UUID or name could be found.
@raise RuntimeError: Raised if the project could not be removed because it was open or in use, or if the user cancelled the operation.
----------
ProjectManager.rename
Changes the name of a project.

@type  OldName: str
@param OldName: The UUID or name of the project to modify
@type  NewName: str
@param NewName: The new name for the project. This must not be an empty string.
@rtype: None
@raise ValueError: Raised if no project with the given name exists, or if the new name was empty.
----------
ProjectManager.saved
This is emitted just after a project is saved.

@type  SavedProject: L{Project}
@param SavedProject: The project that was saved
@rtype: None
@see: L{aboutToSave()}
----------
ProjectManager.showCreateDialog
Displays the project creation dialog box.

@rtype: None
----------
ProjectionManager
Handles settings used to project the paint buffer into a scene.
----------
ProjectionManager.paintingMode
Returns the current paint compositing mode.

@rtype: str
@return: The current painting mode as a string, such as 'Multiply' or 'Lighten'.
@see: L{setPaintingMode()}
----------
ProjectionManager.paintingModeList
Returns the list of possible painting modes.

@rtype: list of str
@return: The list of possible painting modes.
----------
ProjectionManager.setPaintingMode
Sets the paint compositing mode of projection.

@type  PaintingMode: str
@param PaintingMode: The new painting mode as a string, such as 'Multiply' or 'Lighten'. See the GUI for a full list of available painting modes.
@rtype: None
@raise ValueError: Raised if the specified mode is unknown.
@see: L{paintingMode()}
----------
Projector
Projectors store the specific camera details of a particular view.

This includes the rotation, zoom, and orientation of the view, plus the current paintable area, painting mode, and mask settings. This is much like a bookmark or snapshot of a view.

Use the L{camera()} attached to the projector to access its camera-like properties, such as its current position and orientation.

You can access projectors through the L{ProjectorManager} - for example: C{mari.projectors.list()}

B{Example Code}

>>> # This examples shows how to create a new projector
>>> import mari
>>> projector = mari.projectors.create("Test Projector")
>>> print projector.name()
Test Projector
>>> mari.projectors.remove(projector.name())
----------
Projector.aboutToSaveImage
This is emitted just before a unproject image is saved.

@type  SaveImage: L{Image}
@param SaveImage: The image that is going to be saved
@rtype: None
----------
Projector.bitDepth
Returns the current bit depth of the projector.

@rtype: L{BitDepth}
@return: The current bit depth of the projector
@see: L{setBitDepth()}
----------
Projector.camera
Returns the camera attached to the projector.

Use this to access the projector's camera-like properties, such as its current position and orientation.

@rtype: L{Camera}
----------
Projector.clampColors
Returns the color clamping behavior of the projector.

@rtype: bool
@return: True if the colors are clamped to the 0..1 range on output, or False otherwise
@see: L{setClampColors()}
----------
Projector.depthProjectionMode
Returns the type of depth-dependent projection onto object faces.

@rtype: L{DepthProjectionMode}
@return: The current type of projection
@see: L{setDepthProjectionMode()}
----------
Projector.exportColorspaceConfig
Returns the colorspace configuration for export of the projector.

@rtype: L{ColorspaceConfig}
@return: The colorspace configuration for export.
@see: L{setExportColorspaceConfig()}
----------
Projector.exportColorspaceConfigChanged
This is emitted after the colorspace configuration for export is modified for the projector.

@type  Config: L{ColorspaceConfig}
@rtype: None
----------
Projector.exportOptions
Returns the options passed to the file writer.

@rtype: variant
@return: The options that are used in exporting images.
@see: L{setExportOptions()}
----------
Projector.exportPath
Returns the file path to export the projection to.

@rtype: str
@return: The file path that projection images are exported to
@see: L{setExportPath()}
----------
Projector.format
Returns the pixel format of the projection as a string.

@rtype: str
@raise RuntimeError: Raised if the current format is not supported.
@see: L{setFormat()}
----------
Projector.frameOffset
Returns the frame offset of the projection.

@rtype: int
@return: The frame offset of the projection
@see: L{setFrameOffset()}
----------
Projector.frameOffsetChanged
This is emitted when the frame offset is changed.

@type  Offset: int
@param Offset: The new frame offset
@rtype: None
----------
Projector.height
Returns the pixel height of the projection.

@rtype: int
@return: The height in pixels of the projection
----------
Projector.importColorspaceConfig
Returns the colorspace configuration for import of the projector.

@rtype: L{ColorspaceConfig}
@return: The colorspace configuration for import.
@see: L{setImportColorspaceConfig()}
----------
Projector.importColorspaceConfigChanged
This is emitted after the colorspace configuration for import is modified for the projector.

@type  Config: L{ColorspaceConfig}
@rtype: None
----------
Projector.importFromFile
Sets the camera to the projector's view and imports the given image into the paint buffer.

If no path is provided, the current import path is used. Otherwise, this function sets the current import path to the one provided.

This function is similar to L{projectFromFile()}, but does not bake the loaded paint buffer.

@type  Path: str
@param Path: The file path to import the projection image from. If the path is empty, the current value of L{importPath()} is used.
@rtype: None
@raise IOError: Raised if the file from the updated image import path does not exist.
@see: L{projectFromFile()}
----------
Projector.importPath
Returns the file path to import the projection from.

@rtype: str
@return: The file path to import projection images from
@see: L{setImportPath()}
----------
Projector.lightingMode
Returns the detail level of the lighting calculations.

@rtype: L{LightingMode}
@return: The current lighting mode
@see: L{setLightingMode()}
----------
Projector.makeCurrent
Changes the camera's settings to those of the projector.

@rtype: None
@see: L{ProjectorManager.setCurrent()}
----------
Projector.name
Returns the name of the projector.

@rtype: str
@return: The name of the projector.
@see: L{setName()}
----------
Projector.nameChanged
This is emitted after the shader has been renamed.

@type  NewName: str
@param NewName: The new name of the shader
@rtype: None
----------
Projector.paintingMode
Returns the current paint compositing mode.

@rtype: str
@return: The current painting mode as a string, such as 'Multiply' or 'Lighten'.
@see: L{setPaintingMode()}
----------
Projector.project
Imports an image and projects onto the geometry in the projector's view.

This reads an image from the current image import path into the paint buffer and bakes it.

@rtype: None
@raise IOError: Raised if the file from the current image import path does not exist.
@see: L{importPath()}, L{projectFromFile()}
----------
Projector.projectFromFile
Projects the given image file onto the geometry in the projector's view.

If no path is provided, the current import path is used. Otherwise, this is the equivalent of calling L{setImportPath()} and then L{project()}.

This function is similar to L{importFromFile()}, but also bakes the loaded paint buffer.

@type  Path: str
@param Path: The file path to import the projection image from, or an empty string to use the current value of L{importPath()}
@rtype: None
@raise IOError: Raised if the file from the updated image import path does not exist.
@see: L{project()}, L{importFromFile()}
----------
Projector.rotation
Returns the rotation of the projector's projection.

@rtype: float
@see: L{setRotation()}
----------
Projector.save
Save the projector data to a file.

@type  FileName: str
@param FileName: The absolute path, file name, and extension to save the projector data to.
@rtype: None
----------
Projector.scale
Returns the scale of the projection.

@rtype: L{VectorN}
@see: L{setScale()}
----------
Projector.setBitDepth
Sets the bit depth of the projector.

When unprojecting, the projector can render at varying bit depths. This method give control over the bit depth used.

@type  Depth: L{BitDepth}
@param Depth: The bit depth of the unprojection image. This should be suitable for the output image format - e.g. unprojecting to a PNG file with floating point bit depth will fail.
@rtype: None
@raise ValueError: Raised if the bit depth provided was invalid.
@see: L{bitDepth()}
----------
Projector.setClampColors
Sets the color clamping behavior of the projector.

@type  ClampColors: bool
@param ClampColors: True to clamp the colors to the 0..1 range, or False to not clamp
@rtype: None
@see: L{clampColors()}
----------
Projector.setDepthProjectionMode
Sets the type of depth-dependent projection onto object faces.

@type  ProjectionMode: L{DepthProjectionMode}
@param ProjectionMode: The new type of projection
@rtype: None
@see: L{depthProjectionMode()}
----------
Projector.setExportColorspaceConfig
Sets the colorspace configuration for export of the channel.

@type  Config: L{ColorspaceConfig}
@param Config: The colorspace configuration for export.
@rtype: None
@raise ValueError: Raised if the colorspace configuration is invalid.
@see: L{exportColorspaceConfig()}
----------
Projector.setExportOptions
Sets the options passed to the file writer.

These can be used to pass options to the file writer, in dictionary format. For example:

C{projector.setExportOptions({'Quality': 78.0, 'Scanline': True})}

@type  Options: variant
@param Options: The options that are used in exporting images.
@rtype: None
@see: L{exportOptions()}
----------
Projector.setExportPath
Sets the path that the projector will export images to.

@type  Path: str
@param Path: The file path to export projection images to
@rtype: None
@see: L{exportPath()}
----------
Projector.setFormat
Sets the pixel format of the projection from a string.

@type  Format: str
@rtype: None
@raise ValueError: Raised if the requested format is not supported.
@see: L{format()}
----------
Projector.setFrameOffset
Sets the frame offset, when using the imported path with the timeline.

@type  Offset: int
@param Offset: The frame offset from 0 to 9999
@rtype: None
@raise ValueError: Raised if the offset is out of range.
@see: L{frameOffset()}
----------
Projector.setImportColorspaceConfig
Sets the colorspace configuration for import of the projector.

@type  Config: L{ColorspaceConfig}
@param Config: The colorspace configuration for import.
@rtype: None
@raise ValueError: Raised if the colorspace configuration is invalid.
@see: L{importColorspaceConfig()}
----------
Projector.setImportPath
Sets the file path that the projector will import images from.

@type  Path: str
@param Path: The file path to import projection images from
@rtype: None
@see: L{importPath()}
----------
Projector.setLightingMode
Sets the detail level of the lighting calculations.

@type  NewMode: L{LightingMode}
@param NewMode: The new lighting mode
@rtype: None
@see: L{lightingMode()}
----------
Projector.setName
Sets the projector's name.

@type  Name: str
@rtype: None
@raise ValueError: Raised if the name is empty, or if a projector with the given name already exists.
@raise RuntimeError: Raised if no projector is open.
@see: L{name()}
----------
Projector.setPaintingMode
Sets the paint compositing mode of the projector.

@type  PaintingMode: str
@param PaintingMode: The new painting mode as a string, such as 'Multiply' or 'Lighten'. See the GUI for a full list of available painting modes.
@rtype: None
@raise ValueError: Raised if the specified mode is unknown.
@see: L{paintingMode()}
----------
Projector.setRotation
Sets the rotation of the projector's projection

@type  Rotation: float
@rtype: None
@raise ValueError: Throws a value error if the vector is not a 2D vector.
@see: L{rotation()}
----------
Projector.setScale
Sets the scale of the projection.

@type  pScale: L{VectorN}
@rtype: None
@see: L{scale()}
----------
Projector.setSize
Sets the projection size in pixels.

@type  Width: int
@type  Height: int
@rtype: None
@raise ValueError: Raised if the requested size is not supported.
----------
Projector.setTranslation
Sets the translation of the projector's projection

@type  pTranslation: L{VectorN}
@rtype: None
@raise ValueError: Throws a value error if the vector is not a 2D vector.
@see: L{translation()}
----------
Projector.setUseShader
Sets the shader to use for unprojection.

@type  UseShader: str
@param UseShader: The name of the shader to use for unprojection.
@rtype: None
@raise ValueError: Raised if the specified shader is unknown.
@see: L{useShader()}
----------
Projector.translation
Returns the translation of the projector's projection.

@rtype: L{VectorN}
@see: L{setTranslation()}
----------
Projector.unproject
Exports an image from the projector's view to the current export path.

@rtype: None
@see: L{unprojectToFile()}, L{exportPath()}
----------
Projector.unprojectToFile
Exports an image from the projector's view to the given file.

If no path is provided, the current export path is used. Otherwise, this is the equivalent of calling L{setExportPath()} and then L{unproject()}.

The I{options} parameter can be used to pass options to the file writer, in dictionary format. For example:

C{projector.unprojectToFile('/tmp/test.jpg', {'IntegerSetting': 1, 'StringSetting': 'Hello'})}

@type  Path: str
@param Path: The file path to export the projection image to, or an empty string to use the current value of L{exportPath()}
@type  Options: variant
@param Options: This is an optional parameter which can be used to pass options to the file writer. See above for details.
@rtype: None
@see: L{unproject()}
----------
Projector.useShader
Returns the name of the shader used for unprojection.

@rtype: str
@return: The name of the shader used for unprojection.
@see: L{setUseShader()}
----------
Projector.useShaderList
Returns a list of shader names that can be used for unprojection.

@rtype: list of str
@return: A list of shader names that can be used for unprojection.
----------
Projector.width
Returns the pixel width of the projection.

@rtype: int
@return: The width in pixels of the projection
----------
ProjectorManager
This object manages projectors in the project, including creation and listing.

B{Example Code}

>>> # This examples shows how to create a new projector
>>> import mari
>>> projector = mari.projectors.create("Test Projector")
>>> print projector.name()
Test Projector
>>> mari.projectors.remove(projector.name())
----------
ProjectorManager.create
Creates a new projector with the given name.

@type  Name: str
@param Name: The name of the new projector to create. This must be non-empty and unique.
@rtype: L{Projector}
@raise ValueError: Raised if the name is empty, or if a projector with the given name already exists.
@raise RuntimeError: Raised if no project is currently open.
----------
ProjectorManager.current
Returns the currently selected projector.

@rtype: L{Projector}
@return: The currently selected projector
@raise RuntimeError: Raised if no project is currently open.
@see: L{setCurrent()}
----------
ProjectorManager.find
Returns the projector with the given name, if found.

@type  Name: str
@param Name: The name of the projector to look for
@rtype: L{Projector}
@return: The projector if found, or None if not
----------
ProjectorManager.get
Returns the projector with the given name.

@type  Name: str
@param Name: The name of the projector to look for
@rtype: L{Projector}
@return: The projector with the given name
@raise ValueError: Raised if no projector with the given name exists
----------
ProjectorManager.list
Returns a list of all projectors in the project.

@rtype: list of  L{Projector}
@return: A list of all projectors in the project
@raise RuntimeError: Raised if no project is currently open.
----------
ProjectorManager.load
Loads a projector from the given file path.

Requests for projector loading are routed to the correct plugin based on file extension.

The following is an example of loading a camera from an alembic file with some additional camera options:

>>> import mari
>>> filePath = "/tmp/test.abc"
>>> options = ["FrameOffset = 1", "StartFrame = 2", "EndFrame=4"]
>>> camerasToLoad = ["/CameraTopPersp/CameraTopPersp"]
>>> mari.projectors.load(filePath, options, camerasToLoad)

@type  Path: str
@param Path: The path to the file to be loaded. A file may contain multiple projectors.
@type  Options: list of str
@param Options: This is an optional parameter which can be used to pass options to the file loader. L{Options} should be in I{name=value} format. Some examples are StartFrame, EndFrame and FrameOffset.
@type  CameraNames: variant
@param CameraNames: This is an optional list of cameras to load from the file. Each item of the list is a string, corresponding to the name of the camera in the source file.
@rtype: list of  L{Projector}
@return: A list of the projectors loaded from the given file, empty list on failure
@raise RuntimeError: Raised if no project is currently open.
@raise ValueError: Raised if the options list contains invalid items.
----------
ProjectorManager.names
Returns a list of the names of all projectors in the project.

@rtype: list of str
@return: The names of all projectors in the project
@raise RuntimeError: Raised if no projet is currently open.
----------
ProjectorManager.quick
Returns the quick projection settings.

@rtype: L{QuickProjector}
@return: The quick projection settings.
@raise RuntimeError: Raised if no project is currently open.
----------
ProjectorManager.remove
Removes, or deletes, the projector with the given name.

@type  Name: str
@param Name: The name of the projector to remove
@rtype: None
----------
ProjectorManager.selection
Returns a list of all projectors in the project that are selected.

@rtype: list of  L{Projector}
@return: A list of all selected projectors in the project
@raise RuntimeError: Raised if no project is currently open.
----------
ProjectorManager.setCurrent
Sets the current projector.

@type  Current: L{Projector}
@param Current: The projector to make current
@rtype: None
@see: L{Projector.makeCurrent()}, L{current()}
----------
PropertySource
This API provides functionality for objects that expose a number of built in properties.

Objects within Mari can have two forms of properties, built in values or metadata. Built in properties are hard coded onto objects and cannot be removed or their characteristics modified. This API provides generic functionality for objects that expose these built in properties for scripting.

C{def PrintPropertyInfo(Obj):}

C{for Property in Obj.propertiesList():}

C{print Property, "=", Obj.getProperty(Property)}

C{print "  Display Name  :", Obj.propertyDisplayName(Property)}

C{print "  Can reset     :", Obj.canResetProperty(Property)}

C{print "  Is Enum       :", Obj.propertyIsEnum(Property)}

C{if Obj.propertyIsEnum(Property) == True:}

C{for value in Obj.propertyEnumValues(Property):}

C{print "                    :" , value}

C{print "  Has MinMax    :", Obj.propertyHasMinMax(Property)}

C{print "  Is Read Only  :", Obj.propertyIsReadOnly(Property)}

C{print "  Tooltip       :", Obj.propertyTooltip(Property)}

C{if Obj.propertyHasMinMax(Property)==True:}

C{print "   MinMax Values:", Obj.propertyMinMax(Property)}

Properties on an object are refered to by a path normally of the form subobject/group/property Subobjects are separate sub-components of an object that expose properties through the main object . Proprties can be get/set/reset, and you can query various attributes of the property such as min and max values and the tooltip if one is provided.
----------
PropertySource.canResetProperty
Query if a given property can be automatically reset to a default value.

C{print mari.tools.currentTool().canResetProperty( mari.tools.currentTool().propertiesList()[0])}

@type  PropertyName: str
@param PropertyName: The name of the property to query, this should be found in the list returned by L{propertiesList()}
@rtype: bool
@raise ValueError: Raised if the given property is not found on this object
----------
PropertySource.getProperty
Return the value of a given property.

C{print mari.tools.currentTool().getProperty( mari.tools.currentTool().propertiesList()[0])}

@type  PropertyName: str
@param PropertyName: The name of the property to query, this should be found in the list returned by L{propertiesList()}
@rtype: variant
@raise ValueError: Raised if the given property is not found on this object
----------
PropertySource.propertiesList
Return the list of properties that can be set on this object.

C{print mari.tools.currentTools().propertiesList( )}

@rtype: list of str
@return: a list of strings. Each entry is the full name of a property that can be set on this object
----------
PropertySource.propertyDisplayName
Return the display name of a given property, this is the name that should be presented to the user.

C{print mari.tools.currentTool().propertyDisplayName( mari.tools.currentTool().propertiesList()[0])}

@type  PropertyName: str
@param PropertyName: The name of the property to query, this should be found in the list returned by L{propertiesList()}
@rtype: str
@raise ValueError: Raised if the given property is not found on this object
----------
PropertySource.propertyEnumValues
Return the valid values for an enum type property.

C{print mari.tools.currentTool().propertyEnumValues( mari.tools.currentTool().propertiesList()[0])}

@type  PropertyName: str
@param PropertyName: The name of the property to query, this should be found in the list returned by L{propertiesList()}
@rtype: list of str
@raise ValueError: Raised if the given property is not found on this object
@raise ValueError: Raised if the given property is not an enum type property
----------
PropertySource.propertyHasMinMax
Query if a given property has defined min and max values.

C{print mari.tools.currentTool().propertyHasMinxMax( mari.tools.currentTool().propertiesList()[0])}

@type  PropertyName: str
@param PropertyName: The name of the property to query, this should be found in the list returned by L{propertiesList()}
@rtype: bool
@raise ValueError: Raised if the given property is not found on this object
----------
PropertySource.propertyIsEnum
Query if a given property is an enumerated type.

C{print mari.tools.currentTool().propertyIsEnum( mari.tools.currentTool().propertiesList()[0])}

@type  PropertyName: str
@param PropertyName: The name of the property to query, this should be found in the list returned by L{propertiesList()}
@rtype: bool
@raise ValueError: Raised if the given property is not found on this object
----------
PropertySource.propertyIsReadOnly
Query if a given property is read only.

C{print mari.tools.currentTool().propertyIsReadOnly( mari.tools.currentTool().propertiesList()[0])}

@type  PropertyName: str
@param PropertyName: The name of the property to query, this should be found in the list returned by L{propertiesList()}
@rtype: bool
@raise ValueError: Raised if the given property is not found on this object
----------
PropertySource.propertyMinMax
Query the min and max values for a given property.

C{print mari.tools.currentTool().propertyMinMax( mari.tools.currentTool().propertiesList()[0])}

@type  PropertyName: str
@param PropertyName: The name of the property to query, this should be found in the list returned by L{propertiesList()}
@rtype: list of  variant
@raise ValueError: Raised if the given property is not found on this object
@raise ValueError: Raised if the given property does not proviude min max values
----------
PropertySource.propertyTooltip
Query the tooltip for a given property, if non is found an empty string will be returned.

C{print mari.tools.currentTool().propertyTooltip( mari.tools.currentTool().propertiesList()[0])}

@type  PropertyName: str
@param PropertyName: The name of the property to query, this should be found in the list returned by L{propertiesList()}
@rtype: str
@raise ValueError: Raised if the given property is not found on this object
----------
PropertySource.resetProperty
Reset the given property to the default value, if the given property cannot be reset this method will simply return without error.

C{mari.tools.currentTool().resetProperty( mari.tools.currentTool().propertiesList()[0])}

@type  PropertyName: str
@param PropertyName: The name of the property to query, this should be found in the list returned by L{propertiesList()}
@rtype: None
@raise ValueError: Raised if the given property is not found on this object
----------
PropertySource.setProperty
Set the value of a given property.

C{mari.tools.currentTool().setProperty( mari.tools.currentTool().propertiesList()[0],2.0)}

@type  PropertyName: str
@param PropertyName: The name of the property to set, this should be found in the list returned by L{propertiesList()}
@type  NewValue: variant
@param NewValue: The new value for the property
@rtype: None
@raise ValueError: Raised if the given property is not found on this object or the value passed is incompatible
@raise ValueError: Raised if the property is read only
@raise eInternal: Raised if some other problem was encountered when setting the property
----------
Ptex
Provides L{Ptex} image set scripting.
----------
Ptex.__init__
Constructs a new L{Ptex} wrapper.

This is a helper class for dealing with L{Ptex} image sets. It should be constructed by passing in a pointer to an existing L{Ptex} image set.

@type  pPtexImageSet: L{ImageSet}
@param pPtexImageSet: A pointer to an L{ImageSet} object to wrap
@rtype: L{Ptex}
----------
Ptex.doubleFaceSize
Doubles the size of the texture of the L{Ptex} face.

@type  FaceId: int
@param FaceId: The ID of the face to double the size of.
@rtype: None
@raise RuntimeError: Raised if an error was detected during face resizing.
----------
Ptex.exportToPtexFile
Exports an image set as a L{Ptex} file.

@type  PtexPathName: str
@param PtexPathName: L{Ptex} path name to export to.
@type  IncludeGeo: bool
@param IncludeGeo: Include geometry as meta data.
@type  IncludeAdjacency: bool
@param IncludeAdjacency: Include adjacency information.
@type  GenerateMipMaps: bool
@param GenerateMipMaps: Generate mipmaps using the L{Ptex} library.
@type  IncludeUserAttributes: bool
@param IncludeUserAttributes: Include user attributes from the image set.
@type  RemapQuads: bool
@param RemapQuads: Remap all quad face texture data from triangle layout to quad layout.
@rtype: None
@raise RuntimeError: Raised if an error was detected while exporting to the .ptx file.
----------
Ptex.faceCount
Returns the number of faces in this L{Ptex} texture.

@rtype: int
@return: The face count.
@deprecated: This method will be removed in a future version. Please use L{geoFaceCount()} instead.
----------
Ptex.faceSize
Returns the size in pixels of the given face.

@type  FaceId: int
@param FaceId: The ID of the face to query.
@rtype: QSize
@return: The size in pixels of the face.
----------
Ptex.floodFillFace
Floodfills a face within the L{Ptex} texture to a given color.

@type  FaceId: int
@type  FillColor: L{Color}
@rtype: None
@raise RuntimeError: Raised if an error was detected while flooding filling faces. FaceId The ID of the face to fill. FillColor The color that the face will be filled with.
----------
Ptex.geoFaceCount
Returns the number of faces in this L{Ptex} texture.

@rtype: int
@return: The total face count of the various geometries contained in a GeoVersion.
----------
Ptex.halveFaceSize
Halves the size of the texture of the L{Ptex} face.

@type  FaceId: int
@param FaceId: The ID of the face to halve the size of.
@rtype: None
@raise RuntimeError: Raised if an error was detected during face resizing.
----------
Ptex.hash
Returns a unique identifier for this L{Ptex} image set.

Mari maintains hashes of ptex data for internal book-keeping. These hashes are assumed to be universally unique (256bit skein hash). These hashes can be used to determine if an L{Ptex} image set has changed since some given checkpoint. A different hash means different ptex data.

@rtype: str
@return: A hash string that uniquely identifies this version of this L{Ptex} image set, or an empty string on failure.
----------
Ptex.importFromPtexFile
Import a compatible L{Ptex} file onto an existing image set.

@type  PtexPathName: str
@param PtexPathName: L{Ptex} pathname to import from.
@type  RemapQuads: bool
@param RemapQuads: Remap all quad face texture data from quad layout to triangle layout.
@rtype: None
@raise RuntimeError: Raised if an error was detected while importing from the .ptx file.
----------
Ptex.resizeFace
Resizes a face within the L{Ptex} texture.

@type  FaceId: int
@param FaceId: The ID of the face to resize.
@type  NewSize: QSize
@param NewSize: The new size of the face. This must be a size returned by L{validFaceSizes()}.
@rtype: None
@raise RuntimeError: Raised if an error was detected during face resizing.
----------
Ptex.resizeFaceToTexelDensity
Resizes a face within the L{Ptex} texture to a world space texel density.

@type  FaceId: int
@param FaceId: The ID of the face to resize.
@type  Density: float
@param Density: The texel density to use in the resize calculations.
@rtype: None
@raise RuntimeError: Raised if an error was detected during face resizing.
----------
Ptex.validFaceSizes
Returns the list of valid face sizes for L{Ptex} faces.

@rtype: list of  int
@return: A list of valid face sizes.
----------
QuickProjector
Projectors store the specific camera details of a particular view.

This includes the rotation, zoom, and orientation of the view, plus the current paintable area, painting mode, and mask settings. This is much like a bookmark or snapshot of a view.

You can access projectors through the L{ProjectorManager} - for example: C{mari.projectors.list()}

B{Example Code}

>>> # This example shows how to the path of the quick projector
>>> import mari
>>> mari.projectors.quick().setPath("/tmp/quick_unprojection.png")
----------
QuickProjector.bitDepth
Returns the current bit depth of the projector.

@rtype: L{BitDepth}
@return: The current bit depth of the projector
@see: L{setBitDepth()}
----------
QuickProjector.clampColors
Returns the color clamping behavior of the projector.

@rtype: bool
@return: True if the colors are clamped to the 0..1 range on output, or False otherwise
@see: L{setClampColors()}
----------
QuickProjector.height
Returns the pixel height of the projection.

@rtype: int
@return: The height in pixels of the projection
----------
QuickProjector.lightingMode
Returns the detail level of the lighting calculations.

@rtype: L{LightingMode}
@return: The current lighting mode
@deprecated: This function no longer does anything. It will be removed in a future version.
@see: L{setLightingMode()}
----------
QuickProjector.path
Returns the file path to export the projection to.

@rtype: str
@return: The file path that projection images are exported to
@see: setExportPath(), L{setPath()}
----------
QuickProjector.setBitDepth
Sets the bit depth of the projector.

When unprojecting, the projector can render at varying bit depths. This method give control over the bit depth used.

@type  Depth: L{BitDepth}
@param Depth: The bit depth of the unprojection image. This should be suitable for the output image format - e.g. unprojecting to a PNG file with floating point bit depth will fail.
@rtype: None
@raise ValueError: Raised if the bit depth provided was invalid.
@see: L{bitDepth()}
----------
QuickProjector.setClampColors
Sets the color clamping behavior of the projector.

@type  ClampColors: bool
@param ClampColors: True to clamp the colors to the 0..1 range, or False to not clamp
@rtype: None
@see: L{clampColors()}
----------
QuickProjector.setLightingMode
Sets the detail level of the lighting calculations.

@type  NewMode: L{LightingMode}
@param NewMode: The new lighting mode
@rtype: None
@raise ValueError: Raised if the requested mode is not supported by the specified file format.
@deprecated: This function no longer does anything. It will be removed in a future version.
@see: L{lightingMode()}
----------
QuickProjector.setPath
Sets the path that the projector will export images to.

@type  Path: str
@param Path: The file path to export projection images to
@rtype: None
@see: exportPath(), L{path()}
----------
QuickProjector.setSize
Sets the projection size in pixels.

@type  Width: int
@type  Height: int
@rtype: None
@raise ValueError: Raised if the requested size is not supported.
----------
QuickProjector.width
Returns the pixel width of the projection.

@rtype: int
@return: The width in pixels of the projection
----------
ResourceInfo
This provides access to Mari's resource paths and some related system functions.

The paths supplied should be accessed using a string identifier returned from one of the appropriate functions. Note that new paths cannot currently be registered through scripting.

The current value of a path can be accessed with code like the following: C{mari.resources.path(mari.resources.USER_SCRIPTS)}

Many paths can be overridden by environment variables that match their string identifiers. For example, C{mari.resources.USER_SCRIPTS} is set to the string "MARI_SCRIPT_PATH", and if an environment variable with that name is found when Mari launches, the user scripts path will be set to its contents.

The paths that can be modified by users will generally have string identifiers that begin with "MARI_", which also makes the environment variables clearer. Alternatively, an individual path can be checked for modifiability by calling C{mari.scripts.setPath()} on it; the function will raise an exception if the path is not user-modifiable.

B{Example Code}

>>> # This example shows how to obtain the path to example directory
>>> import mari
>>> example_dir_path = mari.resources.path(mari.resources.EXAMPLES)
----------
ResourceInfo.createIcon
Constructs a QIcon for the given file name from Mari's stock icon library.

@type  IconFileName: str
@param IconFileName: The file name of the icon in Mari's stock icon library
@rtype: QIcon
@return: object for the given icon file name
----------
ResourceInfo.customPluginPaths
Returns the list of plugin paths specified by environment variable MARI_CUSTOM_PLUGINS_PATH.

@rtype: list of str
----------
ResourceInfo.disableEnviromentKeyValues
Refreshes all environment paths to mari default values, instead of reading from the environment.

@rtype: None
----------
ResourceInfo.flattenedSequenceTemplate
Returns the default template used for flattened image sequences.

@rtype: str
@return: The default template used for flattened image sequences
@see: L{setFlattenedSequenceTemplate()}
----------
ResourceInfo.path
Retrieves the value of a registered path as a single string.

The available registered paths are listed in the I{System Paths} and I{User Paths} sections above.

@type  Key: str
@param Key: The string identifier of the path.
@rtype: str
@return: The value of the path.
@raise AttributeError: Raised if the supplied key does not match a path entry.
@see: L{pathList()}, L{setPath()}
----------
ResourceInfo.pathList
Retrieves the value of a registered path as a list of strings.

The available registered paths are listed in the I{System Paths} and I{User Paths} sections above.

The strings are combined into a single one by joining with instances of the standard path specifier - ':' on Linux/OS X, and ';' on Windows.

@type  Key: str
@param Key: The string identifier of the path.
@rtype: list of str
@return: A list of the values in the path.
@raise AttributeError: Raised if the supplied key does not match a path entry.
@see: L{setPathList()}, L{path()}
----------
ResourceInfo.ptexFlattenedSequenceTemplate
Returns the default template used for flattened L{Ptex} image sequences.

@rtype: str
@return: The default template used for flattened L{Ptex} image sequences
@see: L{setPtexFlattenedSequenceTemplate()}
----------
ResourceInfo.ptexSequenceTemplate
Returns the default template used for L{Ptex} image sequences.

@rtype: str
@return: The default template used for L{Ptex} image sequences
@see: L{setPtexSequenceTemplate()}
----------
ResourceInfo.refreshAllPaths
Refreshes all paths from environment variables to account for any changes.

This calls L{refreshPath()} for all available paths.

This is used to take into account any path modifications applied by environment variable changes on start up. The standard start up process calls this function when setting up the 'mari' module so that users can set up their environment variables for paths using Python's C{sitecustomize.py} if desired.

@rtype: None
----------
ResourceInfo.refreshPath
Refreshes the given path from its environment variable, in case of any changes.

If the specified path is read from an environment variable (see L{ResourceInfo} for details), this will look for the variable, and if found and non-empty, it will set the path to the corresponding value.

For paths that are not read from environment variables, or not modifiable by the user, this operation will do nothing.

@type  Key: str
@rtype: None
@raise AttributeError: Raised if the supplied key does not match a path entry.
----------
ResourceInfo.sequenceTemplate
Returns the default template used for image sequences.

@rtype: str
@return: The default template used for image sequences
@see: L{setSequenceTemplate()}
----------
ResourceInfo.sequenceToken
Returns the token that should be used to identity sequences of images.

@rtype: str
@return: The token to identify image sequences
@see: L{setSequenceToken()}
----------
ResourceInfo.setFlattenedSequenceTemplate
Sets the default template used for flattened image sequences.

@type  Name: str
@param Name: The new default template to use for flattened image sequences
@rtype: None
@see: L{flattenedSequenceTemplate()}
----------
ResourceInfo.setPath
Sets the value of a registered path to a single string.

The available registered paths are listed in the I{System Paths} and I{User Paths} sections above.

Note that no new paths can be registered through scripting at this stage.

@type  Key: str
@param Key: The string identifier of the path.
@type  NewPath: str
@param NewPath: The new value for the path. This must not be empty.
@rtype: None
@raise AttributeError: Raised if the supplied key does not match a path entry.
@raise ValueError: Raised if the new path is empty.
@raise RuntimeError: Raised if the path is not user-modifiable.
@see: L{setPathList()}, L{path()}
----------
ResourceInfo.setPathList
Sets the value of a registered path to a list of strings.

The strings are combined into a single one by joining with instances of the standard path specifier - ':' on Linux/OS X, and ';' on Windows.

The available registered paths are listed in the I{System Paths} and I{User Paths} sections above.

Note that no new paths can be registered through scripting at this stage.

@type  Key: str
@param Key: The string identifier of the path.
@type  NewPathList: list of str
@param NewPathList: The new value for the path. If this is empty, the path is not changed.
@rtype: None
@raise AttributeError: Raised if the supplied key does not match a path entry.
@raise ValueError: Raised if NewPathList is empty.
@raise RuntimeError: Raised if the path is not user-modifiable.
@see: L{pathList()}, L{setPath()}
----------
ResourceInfo.setPtexFlattenedSequenceTemplate
Sets the default template used for flattened L{Ptex} image sequences.

@type  Name: str
@param Name: The new default template to use for flattened L{Ptex} image sequences
@rtype: None
@see: L{ptexFlattenedSequenceTemplate()}
----------
ResourceInfo.setPtexSequenceTemplate
Sets the default template used for L{Ptex} image sequences.

@type  Name: str
@param Name: The new default template to use for L{Ptex} image sequences
@rtype: None
@see: L{ptexSequenceTemplate()}
----------
ResourceInfo.setSequenceTemplate
Sets the default template used for image sequences.

@type  Name: str
@param Name: The new default template to use for image sequences
@rtype: None
@see: L{sequenceTemplate()}
----------
ResourceInfo.setSequenceToken
Sets the sequence token to be used to replace the number in a sequence of images.

By default, this is "$INDEX". Other examples are: $UDIM (WETA), @, ####

@type  Token: str
@param Token: The new sequence token to use.
@rtype: None
@see: L{sequenceToken()}
----------
ResourceInfo.settingsFilePath
Returns the path to the given settings file.

This allows a settings file to be overridden in a local settings folder.

@type  Name: str
@param Name: The file name of the settings file to retrieve the path for
@rtype: str
@return: The resolved file path. This is not guaranteed to exist.
----------
ResourceInfo.showPDF
Displays a PDF file in the system's default viewer.

@type  Path: str
@param Path: The file path of the PDF to view
@rtype: None
----------
ResourceInfo.showURL
Displays a URL in the system's default web browser.

@type  Url: str
@param Url: The URL of the web site to display.
@rtype: None
@raise ValueError: Raised if the URL is invalid.
@raise RuntimeError: Raised if the external browser could not be successfully launched.
----------
ScriptAction
An action to run a Python script, which can be assigned to a menu and/or shortcut.

B{Example Code}

>>> # This example creates an action to print "Hello World" to the log and executes the action
>>> import mari
>>> action = mari.actions.create("MyCustomActions/Print Hello","mari.app.log('Hello World')")
>>> action.trigger()
----------
ScriptAction.script
Returns the script currently set for the action.

@rtype: str
@see: L{setScript()}
----------
ScriptAction.setScript
Modifies the script to run for the action.

@type  rScript: str
@rtype: None
@see: L{script()}
----------
ScriptAction.triggered
This is emitted when the action is triggered by Python or GUI interaction.

@rtype: None
@see: L{trigger()}
----------
SelectionGroup
A selection group object.
----------
SelectionGroup.entityName
Returns the name of the selection group.

@rtype: str
@return: The name of the selection group.
@see: L{setEntityName()}
----------
SelectionGroup.name
Returns the name of the object.

@rtype: str
@return: The name of this object
----------
SelectionGroup.nameChanged
Emitted when the selection group is renamed.

@type  name: str
@param name: The new L{name}.
@rtype: None
----------
SelectionGroup.selectionMode
Return the selection mode of the group.

@rtype: L{SelectionGroupManager.SelectionMode}
@return: The selection mode of the group.
----------
SelectionGroup.setEntityName
Sets the L{name} of the selection group.

@type  name: str
@param name: The L{name} to set for the selection group
@rtype: None
@see: L{entityName()}
----------
SelectionGroupManager
Manages the selection groups in the scene.
----------
SelectionGroupManager.createSelectionGroupFromSelection
Create new group from current selection in project.

@type  name: str
@param name: The L{name} to set for the selection group.
@rtype: None
@raise RuntimeError: Raised if no project was open.
----------
SelectionGroupManager.current
Returns the currently selected selection group.

@rtype: L{SelectionGroup}
@return: The currently selected selection group.
@raise ValueError: Raised if no project was open.
----------
SelectionGroupManager.hiddenChanged
Emitted when the L{hidden} state of a selection L{group} in the scene is changed.

@type  group: L{SelectionGroup}
@param group: The affected selection L{group}.
@type  hidden: bool
@param hidden: The locked state.
@rtype: None
----------
SelectionGroupManager.list
Returns a list of all selection groups in the project.

@rtype: list of  L{SelectionGroup}
@return: List of selection groups in the project.
@raise ValueError: Raised if no project was open.
----------
SelectionGroupManager.lockedChanged
Emitted when the L{locked} state of a selection L{group} in the scene is changed.

@type  group: L{SelectionGroup}
@param group: The affected selection L{group}.
@type  locked: bool
@param locked: The L{locked} state.
@rtype: None
----------
SelectionGroupManager.modeChanged
Emitted when the L{mode} of a selection L{group} in the scene is changed.

@type  group: L{SelectionGroup}
@param group: The affected selection L{group}.
@type  mode: L{SelectionGroupManager.SelectionMode}
@param mode: The selection L{mode}.
@rtype: None
----------
SelectionGroupManager.removeSelectionGroup
Remove a selection L{group} from the project.

@type  group: L{SelectionGroup}
@param group: The selection L{group} to remove.
@rtype: None
@raise RuntimeError: Raised if no project was open.
----------
SelectionGroupManager.sceneSelectionMode
Returns the current mode of the selection in the project.

@rtype: L{SelectionMode}
@return: The current mode of selection.
----------
SelectionGroupManager.select
Selects a selection L{group} from the project.

@type  group: L{SelectionGroup}
@param group: The selection L{group} to select.
@rtype: None
@raise RuntimeError: Raised if no project was open.
----------
SelectionGroupManager.selectModeChanged
Emitted when the selection L{mode} in the scene changes.

@type  mode: L{SelectionGroupManager.SelectionMode}
@param mode: The new selection L{mode}.
@rtype: None
----------
SelectionGroupManager.selectedChanged
Emitted when the L{selected} state of a selection L{group} in the scene is changed.

@type  group: L{SelectionGroup}
@param group: The affected selection L{group}.
@type  selected: bool
@param selected: The L{selected} state.
@rtype: None
----------
SelectionGroupManager.selection
Returns a list of all selected selection groups in the project.

@rtype: list of  L{SelectionGroup}
@return: List of selected selection groups in the project.
@raise ValueError: Raised if no project was open.
----------
SelectionGroupManager.selectionGroupAdded
Emitted when a selection L{group} is added.

@type  group: L{SelectionGroup}
@param group: The new selection L{group}.
@rtype: None
----------
SelectionGroupManager.selectionGroupRemoved
Emitted when a selection L{group} is removed.

@type  group: L{SelectionGroup}
@param group: The selection L{group}.
@rtype: None
----------
SelectionGroupManager.setSelectionMode
Sets the L{mode} of selection in the scene.

@type  mode: L{SelectionMode}
@param mode: The selection L{mode} to set
@rtype: None
----------
SelectionGroupManager.visibleChanged
Emitted when the visibility state of a selection L{group} in the scene is changed.

@type  group: L{SelectionGroup}
@param group: The affected selection L{group}.
@type  visible: bool
@param visible: The visibility state.
@rtype: None
----------
Settings
A group of settings.

Users can load and save their own custom settings within Mari.

B{Example Code}

>>> # This examples shows how to store a user settings
>>> import mari
>>> settings = mari.Settings()
>>> settings.setValue("Test Setting","Hello World")
>>> print settings.value("Test Setting")
Hello World
----------
Settings.__init__
Sets to the settings specified by the given components.

@rtype: L{Settings}
----------
Settings.beginGroup
Appends prefix to the current group.

Starts a named nested set of values. All values set after this call and before the next L{endGroup()} will be accessable only via the groups namespace.

@type  Prefix: str
@param Prefix: Value to append
@rtype: None
@see: L{value}
----------
Settings.endGroup
Resets the group to what it was before the corresponding 'beginGroup()' call.

Ends a named nested set of values. All values set before this call and after the previous L{beginGroup()} will be accessable only via the groups namespace.

@rtype: None
@see: L{value}
----------
Settings.setValue
Sets the value of setting key to value.

If the key already exists, the previous value is overwritten.

@type  Key: str
@param Key: Setting key
@type  Value: variant
@param Value: New value of the setting
@rtype: None
@see: L{value()}
----------
Settings.value
Returns the value for setting key.

If the setting doesn't exist, returns defaultValue. If no default value is specified, 'None' is returned.

If the key was set within a L{beginGroup()} and L{endGroup()} the group's path must be appended to the L{Key} path

C{settings = mari.Settings()}

C{settings.beginGroup('foo')}

C{settings.setValue('bar', True)}

C{settings.endGroup()}

C{print settings.value('foo/bar')}

@type  Key: str
@param Key: Setting key
@type  DefaultValue: variant
@param DefaultValue: Value returned if the setting doesn't exist
@rtype: variant
@return: The value of the setting, or the default if the setting doesn't exist.
@see: L{setValue()}
----------
Shader
Provides access to Mari's real-time layer based display shaders.

Shaders are modules that combine the layer system's L{Channel} objects to produce a rendered output.

You can access shaders from a L{GeoEntity} - for example: C{mari.geo.current().shaderList()}

B{Example Code}

>>> # This example shows how to obtain the current shader
>>> import mari
>>> current_shader = mari.geo.current().currentShader()
>>> print current_shader.className()
Shader
----------
Shader.channelList
Returns a list of the L{Channel} objects in use by the shader.

@rtype: list of  L{Channel}
@return: The list of L{Channel} objects.
----------
Shader.diffuseType
Returns the path of the diffuse component of the shader.

@rtype: str
@return: The path of the diffuse component of the shader, which will be of the form C{'Lighting/Diffuse/Lambertian'} - or an empty string if this is a standalone shader.
@see: L{layeredType()}, L{standaloneType()}, L{specularType()}
----------
Shader.getParameter
Retrieves the current value of a parameter from this shader.

@type  ParameterName: str
@param ParameterName: The name of the parameter to inspect.
@rtype: variant
@return: The current value of the parameter.
@raise ValueError: Raised if name of the parameter does not match any existing items.
@raise SystemError: Raised if there is problem obtaining the parameter value.
@see: L{setParameter()}
----------
Shader.inputList
Returns a list of the shader's input names and channel pairs.

@rtype: QVariantList
@return: The list of name and L{Channel} tuple.
----------
Shader.inputNameList
Returns a list of the names of shader inputs.

@rtype: list of str
@return: The list of names of the shader inputs.
----------
Shader.isInputForShaderStacks
Returns True if the input will only accept channels that are ShaderStacks.

@type  InputName: str
@rtype: bool
----------
Shader.isLayeredShader
Returns True if the shader can contain ShaderStack channels.

@rtype: bool
----------
Shader.isLocked
Indicates whether this shader is locked and, if so, unmodifiable.

@rtype: bool
@return: True if this shader is locked, or False if unlocked.
----------
Shader.isStackShader
Returns True if the shader is used in a ShaderStack channel.

@rtype: bool
----------
Shader.isSystemShader
Returns True if the shader is one of the special system shaders.

@rtype: bool
@see: L{GeoEntity.systemShader()}
----------
Shader.layeredType
Returns the path of the shader, if it is of a layered type.

@rtype: str
@return: The path of the shader, which will be of the form C{'Lighting/Layered/Layered'} - or an empty string if this is not a layered shader.
@see: L{standaloneType()}, L{specularType()}, L{diffuseType()}
----------
Shader.makeCurrent
Sets this shader as the currently active shader on its L{GeoEntity}.

@rtype: None
----------
Shader.name
Returns the name of the shader.

@rtype: str
@return: The name of this shader.
@see: L{setName()}
----------
Shader.nameChanged
This is emitted after the shader has had its name changed.

@type  NewName: str
@param NewName: The new name.
@rtype: None
----------
Shader.parameterNameList
Returns the list of parameter names for this shader.

@rtype: list of str
@return: A list of the parameter names for this shader.
----------
Shader.parameterValueChanged
This is emitted when a parameter value is changed.

@type  Name: str
@param Name: The name of the parameter that has been changed.
@type  Value: variant
@param Value: The new value of the parameter.
@rtype: None
----------
Shader.setInput
Sets the channel to use on the named input.

@type  InputName: str
@param InputName: The name of the input to change.
@type  Input: L{Channel}
@param Input: The channel to set the named input to. This value can be None to clear an input.
@rtype: None
@raise ValueError: Raised if the parameter could not be found, or was invalid.
----------
Shader.setName
Sets the name of the shader.

@type  Name: str
@param Name: The new name for the shader.
@rtype: None
@see: L{name()}
----------
Shader.setParameter
Sets the value of a parameter on the shader.

@type  ParameterName: str
@param ParameterName: The name of the parameter to modify.
@type  NewValue: variant
@param NewValue: The new value for the parameter. This can be of a variety of types.
@rtype: None
@raise ValueError: Raised if the parameter could not be found, or was invalid.
@see: L{getParameter()}
----------
Shader.shaderNode
Returns the node graph node that corresponds to this L{Shader}.

the node graph node that corresponds to this L{Shader}

@rtype: L{Node}
----------
Shader.specularType
Returns the path of the specular component of the shader.

@rtype: str
@return: The path of the specular component of the shader, which will be of the form C{'Lighting/Specular/Blinn'} - or an empty string if this is a standalone shader.
@see: L{layeredType()}, L{standaloneType()}, L{diffuseType()}
----------
Shader.standaloneType
Returns the path of the shader, if it is of a standalone type.

@rtype: str
@return: The path of the shader, which will be of the form C{'Lighting/Standalone/Standard Lighting'} - or an empty string if this is not a standalone shader.
@see: L{layeredType()}, L{specularType()}, L{diffuseType()}
----------
ShaderLayer
L{Shader} layers contain a shader objects in a layer stack.

L{Shader} layers use an internal shader to produce the result.

You can check for L{ShaderLayer} objects by calling L{Layer.isShaderLayer()}:

>>> layer = channel.layer('Layer 2')
>>> if layer.isShaderLayer():
...     print "Found a shader layer"
----------
ShaderLayer.shader
Returns the shader that is within this layer.

@rtype: L{Shader}
@return: Returns a shader
----------
Shelf
A shelf is a place where the user can bookmark objects such as brushes, images, and colors.

B{Example Code}

>>> # This example shows how to obtain the "Personal" shelf
>>> import mari
>>> personal_shelf = mari.shelves.find("Personal")
>>> print personal_shelf.className()
Shelf
----------
Shelf.exportTo
Exports the shelf to the folder specified as a set of XML and image files.

All resources will be localized into the location.

@type  DirectoryPath: str
@param DirectoryPath: The path to the directory the shelf should be exported to
@type  GenerateCatalog: bool
@param GenerateCatalog: Indicates whether to generate a catalog for the shelf
@rtype: None
@raise IOError: Raised if the export failed.
----------
Shelf.name
Returns the name of the shelf.

@rtype: str
@return: The name of the shelf
@see: L{setName()}
----------
Shelf.saveAs
Saves the shelf to the given file name.

@type  rFileName: str
@param rFileName: The file name to save the shelf to
@rtype: None
@raise RuntimeError: Raised if the save failed.
----------
Shelf.setName
Sets the name of the shelf.

@type  NewName: str
@param NewName: The new name for the shelf
@rtype: None
@see: L{name()}
----------
ShelfManager
This manages the available shelves, or sets of item bookmarks.

B{Example Code}

>>> # This example shows how to obtain the "Personal" shelf
>>> import mari
>>> personal_shelf = mari.shelves.find("Personal")
>>> print personal_shelf.className()
Shelf
----------
ShelfManager.find
Returns the shelf with the given name.

@type  Name: str
@param Name: The name of the shelf to look for
@rtype: L{Shelf}
@return: The shelf with the given name if found, or None otherwise
----------
ShelfManager.list
Returns a list of all the available shelves.

@rtype: list of  L{Shelf}
@return: A list of all of the available shelves
----------
ShelfManager.names
Returns a string list of the names of all of the available shelves.

@rtype: list of str
@return: A string list of the names of all of the available shelves
----------
SliderBase
Base class for a slider widget.

Provides the base functionality for a custom slider widget in Mari.

B{Example Code}

>>> # This example creates a new FloatSlider object, add it to a QWidget and show it
>>> import mari
>>> import PySide
>>> float_slider = mari.FloatSlider()
>>> container = PySide.QtGui.QWidget()
>>> container.setLayout(PySide.QtGui.QHBoxLayout())
>>> float_slider.addToLayout(container.layout())
>>> container.show()
----------
SliderBase.addToLayout
Adds the slider to the given layout.

@type  Layout: QLayout
@param Layout: The layout to add the slider widget to
@rtype: None
@raise ValueError: Raised if the given layout is null.
----------
SliderBase.blockSignals
Disables or re-enables the emission of signals from the object.

If L{Block} is True, this will block the emission of signals from this object - i.e., emitting a signal will not invoke anything connected to it. If L{Block} is False, any previous blocking will be deactivated.

Signals are always enabled by default.

When using this function, you should store the return value, which is the previous setting for whether signals were blocked. When your processing has finished, you should call this function again with the previous value. This will ensure that signals will not be re-enabled earlier than intended.

@type  Block: bool
@param Block: True to block signals, or False to unblock them - but see above for why this should generally be called with a stored value instead of an explicit False
@rtype: bool
@return: The previous value of whether signals were blocked.
----------
SliderBase.isEnabled
Returns whether the slider is enabled.

@rtype: bool
----------
SliderBase.logarithmic
Returns whether or not the slider is logarithmic.

@rtype: bool
@return: Whether or not the slider is logarithmic.
@see: L{setLogarithmic()}
----------
SliderBase.precision
Returns the number of decimal places for the slider.

@rtype: int
@return: The number of decimal places of the slider.
@see: L{setPrecision()}
----------
SliderBase.range
Returns the upper and lower limits for the slider.

@type  Min: double
@param Min: The lower limit of the slider.
@type  Max: double
@param Max: The upper limit of the slider.
@rtype: None
@see: L{setRange()}
----------
SliderBase.rangeMax
Returns the upper limit for the slider.

@rtype: double
@return: The upper limit of the slider.
----------
SliderBase.rangeMin
Returns the lower limit for the slider.

@rtype: double
@return: The lower limit of the slider.
----------
SliderBase.setEnabled
Sets whether the slider is enabled.

@type  Enabled: bool
@rtype: None
----------
SliderBase.setLogarithmic
Sets whether or not the slider is logarithmic.

@type  IsLogarithmic: bool
@param IsLogarithmic: Whether or not the slider is logarithmic.
@rtype: None
@see: L{logarithmic()}
----------
SliderBase.setPrecision
Sets the number of decimal places for the slider.

@type  NumDecimalPlaces: int
@param NumDecimalPlaces: The number of decimal places of the slider.
@rtype: None
@see: L{precision()}
----------
SliderBase.setRange
Sets the upper and lower ranges for the slider.

@type  Min: double
@param Min: The lower limit of the slider.
@type  Max: double
@param Max: The upper limit of the slider.
@rtype: None
@see: L{range()}
----------
SliderBase.setStepSize
Sets the size of each slider click.

@type  StepSize: double
@param StepSize: The step size of the slider.
@rtype: None
@see: L{stepSize()}
----------
SliderBase.stepSize
Returns the size of each slider click.

@rtype: double
@return: The step size of the slider.
@see: L{setStepSize()}
----------
Snapshot
A copy of the state of an object at a particular time.

By creating snapshots, users can easily preserve the state of an object and return to that state at some later time.

For example, this could be used to preserve the history of a design, or to try new ideas without risking the current textures. The user could snapshot the current state, paint some modifications, ask for approval, and if the changes are not accepted, quickly and easily revert to the previous state.

B{Example Code}

>>> # This example shows how to obtain the current channel of the current GeoEntity object
>>> import mari
>>> channel = mari.geo.current().currentChannel()
>>> channel_snapshot = channel.createSnapshot("Test Snapshot")
----------
Snapshot.creationDate
Returns the date and time that the snapshot was created.

@rtype: QDateTime
@return: The date and time of creation of the snapshot
@see: L{setCreationDate()}
----------
Snapshot.creationDateChanged
This is emitted when the date or time of creation changes for the snapshot.

@type  DateTime: QDateTime
@param DateTime: The new date and time
@rtype: None
----------
Snapshot.creator
Returns the name of the user who created the snapshot.

@rtype: str
@return: The user name of the creator of the snapshot
@see: L{setCreator()}
----------
Snapshot.creatorChanged
This is emitted when the creator of the snapshot changes.

@type  Creator: str
@param Creator: The new creator of the snapshot
@rtype: None
----------
Snapshot.hasPreview
Indicates whether the snapshot has a valid preview image set.

@rtype: bool
@return: True if a valid preview has been set, or False otherwise
@see: L{setPreview()}, L{preview()}
----------
Snapshot.id
Returns the identifier of the snapshot.

@rtype: str
@return: The identifier of the snapshot. This UUID may not be human readable, and may take the form of a long number string.
@see: L{setID()}
----------
Snapshot.idChanged
This is emitted when the ID of the snapshot changes.

@type  NewID: str
@param NewID: The new identifier of the snapshot
@rtype: None
----------
Snapshot.name
Returns the descriptive name of the snapshot.

@rtype: str
@return: The name of the snapshot
@see: L{setName()}
----------
Snapshot.nameChanged
This is emitted when the name of the snapshot changes.

@type  Name: str
@param Name: The new name for this snapshot
@rtype: None
----------
Snapshot.preview
Returns a preview image of the snapshot.

@rtype: QPixmap
@return: The current preview image
@note: Preview images are not created for snapshots automatically. L{Canvas.captureImage()} can provide useful data for this purpose.
@see: L{setPreview()}, L{hasPreview()}
----------
Snapshot.previewChanged
This is emitted after the preview image for the snapshot changes.

@type  pSnapshot: L{Snapshot}
@rtype: None
----------
Snapshot.setCreationDate
Sets the date of the creation of the snapshot.

@type  DateTime: QDateTime
@param DateTime: The date and time the snapshot was created
@rtype: None
@see: L{creationDate()}
----------
Snapshot.setCreator
Sets the name of the creator of the snapshot.

The creator is set automatically from the system on creation of a snapshot.

This method can be used to override the default value if required.

@type  Creator: str
@param Creator: The name of the person who created the snapshot
@rtype: None
@see: L{creator()}
----------
Snapshot.setID
Sets the identifier of the snapshot.

The identifier is any (generally numeric) reproducible string to identify the snapshot or group of snapshots. If no custom ID is supplied, one is generated internally.

The ID can be used to group snapshots together across objects. For example, if you want to create a snapshot of five different objects at the same time, you can generate an ID and assign it to all of the snapshots. This makes an association between them, and then they can then be used as a group.

An example of this is the "snapshot all channels" option. In that case, all of the snapshots maintain the same ID, and can be reverted as a set.

@type  NewID: str
@param NewID: The new identifier to use. This does not need to be unique between snapshots.
@rtype: None
@see: L{id()}
----------
Snapshot.setName
Changes the descriptive name of the snapshot that is displayed to users.

There is no required naming standard for snapshots, so this can be written as clearly as desired - e.g. "new test version".

@type  NewName: str
@param NewName: A descriptive name for the snapshot for users
@rtype: None
@raise ValueError: Raised if the supplied name string was empty.
@see: L{name()}
----------
Snapshot.setPreview
Sets the preview image of the snapshot.

@type  NewImage: QPixmap
@param NewImage: The new preview image to store
@rtype: None
@see: L{hasPreview()}, L{preview()}
----------
Snapshotable
An object that can have copies of its state taken at particular times.

A L{Snapshot} is a copy of the state of an object at a particular time. Objects of this type can have snapshots of their state taken.
----------
Snapshotable.createSnapshot
Creates a new snapshot of the object.

@type  Name: str
@param Name: A descriptive name for this snapshot. There is no restriction on naming convention, so it is recommended to make this clear, such as "new test version".
@type  ID: str
@param ID: An optional identifier for this snapshot. This value can be used to group together sets of snapshots, as described in L{Snapshot.setID()}.
@rtype: L{Snapshot}
@return: The newly created snapshot.
----------
Snapshotable.deleteSnapshot
Deletes the given snapshot.

@type  ShotToDelete: L{Snapshot}
@param ShotToDelete: The snapshot to delete
@rtype: None
@raise ValueError: The snapshot provided was invalid, or not owned by this object.
@warning: This method cannot be undone, so please use caution.
----------
Snapshotable.findSnapshotWithID
Returns the snapshot with the given identifier, if found.

If more than one snapshot with the given identifier exists, the first one will be returned.

@type  ID: str
@param ID: The shot identifier to search for
@rtype: L{Snapshot}
@return: The first snapshot with the given identifier, or None
----------
Snapshotable.revertToSnapshot
Reverts the state of the object to that in the given snapshot.

@type  OldSnapshot: L{Snapshot}
@param OldSnapshot: A valid snapshot of this object
@rtype: None
@raise ValueError: The snapshot provided was invalid, or not owned by this object.
----------
Snapshotable.snapshotAdded
This is emitted after a snapshot is created for this object.

@type  NewSnapshot: L{Snapshot}
@rtype: None
----------
Snapshotable.snapshotList
Returns a list of the snapshots available on the object.

@rtype: list of  L{Snapshot}
@return: A list of the available snapshots
----------
Snapshotable.snapshotRemoved
This is emitted after a snapshot is deleted for this object.

@type  OldSnapshot: L{Snapshot}
@rtype: None
----------
Tool
This is the base API for Mari's viewport tools.

You can access canvas objects through the L{CanvasManager} - for example: C{mari.canvases.current()}
----------
Tool.cursor
Returns cursor used for this tool.

C{mari.tools.currentTool().cursor()}

@rtype: QCursor
@return: A QCursor containing the cursor for this tool
----------
Tool.description
Returns a brief description of the tool.

C{print mari.tools.currentTool().description()}

@rtype: str
@return: A string containing the description
----------
Tool.help
Returns the help string for this tool.

C{print mari.tools.currentTool().help()}

@rtype: str
@return: A string containing help information for this tool.
----------
Tool.icon
Return the main icon for the tool.

C{mari.tools.currentTool().icon()}

@rtype: QIcon
@return: A QIcon representing the main icon for the tool
----------
Tool.iconActive
Return the icon to be displayed when the tool is active.

C{mari.tools.currentTool().iconActive()}

@rtype: QIcon
@return: A QIcon representing the active icon for the tool
----------
Tool.information
Return information about the current state of the tool.

C{print mari.tools.currentTool().information()}

@rtype: str
@return: A string containing information about the state of the tool. Brush Radius etc.
----------
Tool.name
Return the name of the tool.

C{print mari.tools.currentTool().name()}

@rtype: str
@return: A string containing the name of the tool
----------
ToolBar
A tool bar widget.

Users can create their own custom tool bars, and add any pre-defined or custom actions as they wish.

B{Example Code}

>>> # This example shows how to create a toolbar and add a label to it
>>> import mari, PySide
>>> label = PySide.QtGui.QLabel("Hello World")
>>> toolbar = mari.app.createToolBar("Hello World Toolbar")
>>> toolbar.addWidget(label)
>>> mari.app.deleteToolBar("Hello World Toolbar")
----------
ToolBar.actionsList
Returns the paths of the actions in this toolbar.

@rtype: list of str
----------
ToolBar.addAction
(Deprecated) Adds an action based on the action repository path.

@type  Path: str
@param Path: The path to the new action to add
@type  Pos: list of  int
@param Pos: The point at which the new action should be added, as a list of integers - e.g. [1, 2]
@type  Removable: bool
@param Removable: Defines whether the action can be removed from the toolbar
@rtype: bool
@deprecated: This function will be removed in a future version. Please use L{addActionBefore()} instead.
----------
ToolBar.addActionBefore
Adds an action based on the action repository path.

@type  Path: str
@param Path: The path to the new action to add
@type  InsertBefore: QAction
@param InsertBefore: The action before which the new aciton is added. If None, the new action is added to the end
@type  Removable: bool
@param Removable: Defines whether the action can be removed from the toolbar
@rtype: bool
----------
ToolBar.addActionList
Adds a list of actions based on the action repository path.

@type  Actions: list of str
@param Actions: List of actions
@type  Removable: bool
@param Removable: Boolean showing whether the action should be removable from the toolbar
@rtype: None
----------
ToolBar.addActionObject
Adds the given action to the toolbar as the toolbar's last item.

@type  Object: QAction
@param Object: The action to add
@rtype: None
----------
ToolBar.addSeparator
Adds a separator to the end of the toolbar.

@rtype: None
----------
ToolBar.addWidget
Adds the given widget to the toolbar as the toolbar's last item.

@type  Widget: QWidget
@param Widget: The widget to add
@rtype: None
----------
ToolBar.hide
Hides the toolbar from view.

@rtype: None
@see: L{show()}, L{setVisibility()}, L{isVisible()}
----------
ToolBar.insertSeparator
Inserts a separator into the toolbar in front of the toolbar item associated with the given action.

@type  Path: str
@param Path: The path to the action to insert a separator before
@rtype: None
@raise ValueError: Raised if the requested action was not found.
----------
ToolBar.insertWidget
Inserts the given widget in front of the toolbar item associated with the given action.

@type  Path: str
@param Path: The path to the action to insert the widget before
@type  Widget: QWidget
@param Widget: The widget to insert
@rtype: None
@raise ValueError: Raised if the requested action was not found.
----------
ToolBar.isLocked
Indicates whether this toolbar is locked, and if so, unmodifiable.

Toolbars can only have new actions dragged onto them when unlocked.

@rtype: bool
@return: True if this image is locked, or False if unlocked
@see: L{lock()}, L{unlock()}, L{setLocked()}
----------
ToolBar.isVisible
Indicates whether this toolbar is visible.

@rtype: bool
@return: True if the toolbar is visible, or False if not.
@see: L{show()}, L{setVisibility()}, L{hide()}
----------
ToolBar.lock
Locks the toolbar to prevent modifications.

Toolbars can only have new actions dragged onto them when unlocked.

@rtype: None
@see: L{isLocked()}, L{setLocked()}, L{unlock()}
----------
ToolBar.setLocked
Locks or unlocks the toolbar, to optionally prevent modifications.

Toolbars can only have new actions dragged onto them when unlocked.

@type  Locked: bool
@rtype: None
@see: L{isLocked()}, L{lock()}, L{unlock()}
----------
ToolBar.setSpacing
Sets the spacing between widgets inside the toolbar.

@type  Spacing: int
@rtype: None
@see: L{spacing()}
----------
ToolBar.setVisibility
Shows or hides the toolbar.

@type  Visible: bool
@param Visible: True to show the toolbar, or False to hide it.
@rtype: None
@see: L{show()}, L{isVisible()}, L{hide()}
----------
ToolBar.show
Shows the toolbar again after a previous L{hide()} operation.

@rtype: None
@see: L{setVisibility()}, L{isVisible()}, L{hide()}
----------
ToolBar.spacing
Returns the spacing between widgets inside the toolbar.

@rtype: int
@see: L{setSpacing()}
----------
ToolBar.unlock
Unlocks the toolbar and allows modifications.

Toolbars can only have new actions dragged onto them when unlocked.

@rtype: None
@see: L{isLocked()}, L{lock()}, L{setLocked()}
----------
ToolManager
Provides access to the various interactive user tools.

B{Example Code}

>>> # This example shows how to print the name of the current tool
>>> import mari
>>> print mari.tools.current()
Paint (P)
----------
ToolManager.current
Returns the name of the current tool.

C{print mari.tools.current()}

@rtype: str
@return: The name of the active tool
@see: L{currentHelpString()}, L{setCurrent()}
----------
ToolManager.currentHelpString
Returns the help string for the current tool.

C{print mari.tools.currentHelpString()}

@rtype: str
@return: The help string for the active tool
@see: L{current()}
----------
ToolManager.currentTool
Returns a handle to the current tool.

C{T = mari.tools.currentTool()}

C{print T.name()}

@rtype: L{Tool}
@return: A Handle to the current tool
@see: L{setCurrentTool()}
----------
ToolManager.getTool
Return a handle to the given tool.

C{T = mari.tools.getTool('Paint')}

C{print T.name()}

@type  Name: str
@param Name: The name of the tool requested
@rtype: L{Tool}
@return: A handle to the requested tool
@raise ValueError: Raised if the given tool is not found
----------
ToolManager.loadBrushes
Loads a brushes file into the brush library.

@type  Path: str
@param Path: The path to the brush file to open.
@rtype: None
@raise ValueError: Raise if the file could not be openned or used as a brush
----------
ToolManager.names
Returns the names of the available tools.

C{print mari.tools.names()}

@rtype: list of str
@return: The list of available tools
----------
ToolManager.setCurrent
Sets the current tool by name.

C{mari.tools.setCurrent('Paint')}

@type  Name: str
@rtype: None
@see: L{names()}, L{current()}
----------
ToolManager.setCurrentTool
Set the current tool via a tool handle.

C{BlurTool = mari.tools.getTool('Blur')}

C{mari.tools.setCurrentTool( BlurTool )}

@type  NewTool: L{Tool}
@param NewTool: A handle to the new tool to activate
@rtype: None
@raise ValueError: Raised if the tool handle is invalid
@see: L{currentTool()}
----------
ToolManager.toolsList
Return list of the available tools.

C{for T in mari.tools.toolsList():}

C{print T.name()}

@rtype: list of  L{Tool}
@return: A list of handles to the available tools
----------
VectorN
Objects of this class hold multi-dimensional coordinates.

Coordinates that represent UV, 3D, or 4D values should all be stored in objects of this type.

B{Example Code}

>>> # This example shows how to obtain the position of the 1st light
>>> import mari
>>> lights = mari.lights.list()
>>> light_position = lights[0].position()
>>> print light_position.className()
VectorN
----------
VectorN.__init__
Constructs a new vector.

A vector can be constructed from up to four components. The specified parameters should be either all float values for these components, or one single parameter which is a list containing float values.

For example: 
  - C{mari.VectorN(1, 2)        // 2D vector}
  - C{mari.VectorN(1, 2, 3)     // 3D vector}
  - C{mari.VectorN([1, 2, 3])   // 3D vector}

@type  X: variant
@param X: Optional first element (float, or list of floats)
@type  Y: variant
@param Y: Optional second element (float)
@type  Z: variant
@param Z: Optional third element (float)
@type  W: variant
@param W: Optional fourth element (float)
@rtype: L{VectorN}
----------
VectorN.asTuple
Returns the elements of the vector as a tuple.

@rtype: tuple of  float
@return: The elements of the vector in a tuple - e.g., (1.0, 2.0, 3.0)
----------
VectorN.length
Returns the length of the vector.

This is the same as L{size()}.

@rtype: int
@return: The length of the vector
----------
VectorN.size
Returns the size of the vector.

This is the same as L{length()}.

@rtype: int
@return: The size of the vector
----------
VectorN.w
Returns the 3rd component.

@rtype: float
----------
VectorN.x
Returns the 0th component.

@rtype: float
----------
VectorN.y
Returns the 1st component.

@rtype: float
----------
VectorN.z
Returns the 2nd component.

@rtype: float
